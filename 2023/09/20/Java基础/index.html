<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Java基础 | 互联网新贵邓醒</title><meta name="author" content="Xing Deng"><meta name="copyright" content="Xing Deng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java基础常量变量类型运算符方法流程控制数组类对象封装构造方法静态继承Stringsuperthis抽象类接口多态final权限内部类集合Collection:单列集合 List的特点是元素有序、元素可重复。 Set的特点是元素无序，而且不可重复。 List接口的主要实现类有java.util.ArrayList和java.util.LinkedList Set接口的主要实现类有java.uti">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="http://dengliantong.cn/2023/09/20/Java%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="互联网新贵邓醒">
<meta property="og:description" content="Java基础常量变量类型运算符方法流程控制数组类对象封装构造方法静态继承Stringsuperthis抽象类接口多态final权限内部类集合Collection:单列集合 List的特点是元素有序、元素可重复。 Set的特点是元素无序，而且不可重复。 List接口的主要实现类有java.util.ArrayList和java.util.LinkedList Set接口的主要实现类有java.uti">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images3.alphacoders.com/103/103237.jpg">
<meta property="article:published_time" content="2023-09-20T01:38:45.000Z">
<meta property="article:modified_time" content="2023-09-21T03:18:55.226Z">
<meta property="article:author" content="Xing Deng">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images3.alphacoders.com/103/103237.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://dengliantong.cn/2023/09/20/Java%E5%9F%BA%E7%A1%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-21 11:18:55'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://images3.alphacoders.com/103/103237.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="互联网新贵邓醒"><span class="site-name">互联网新贵邓醒</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-20T01:38:45.000Z" title="发表于 2023-09-20 09:38:45">2023-09-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-21T03:18:55.226Z" title="更新于 2023-09-21 11:18:55">2023-09-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>60分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a><strong>常量</strong></h3><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h3><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a><strong>类型</strong></h3><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a><strong>运算符</strong></h3><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h3><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a><strong>流程控制</strong></h3><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h3><h3 id="类"><a href="#类" class="headerlink" title="类"></a><strong>类</strong></h3><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a><strong>对象</strong></h3><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a><strong>封装</strong></h3><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h3><h3 id="静态"><a href="#静态" class="headerlink" title="静态"></a><strong>静态</strong></h3><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h3><h3 id="String"><a href="#String" class="headerlink" title="String"></a><strong>String</strong></h3><h3 id="super"><a href="#super" class="headerlink" title="super"></a><strong>super</strong></h3><h3 id="this"><a href="#this" class="headerlink" title="this"></a><strong>this</strong></h3><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a><strong>抽象类</strong></h3><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a><strong>接口</strong></h3><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a><strong>多态</strong></h3><h3 id="final"><a href="#final" class="headerlink" title="final"></a><strong>final</strong></h3><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a><strong>权限</strong></h3><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a><strong>内部类</strong></h3><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a><strong>集合</strong></h3><p>Collection:单列集合</p>
<p><code>List</code>的特点是元素有序、元素可重复。</p>
<p><code>Set</code>的特点是元素无序，而且不可重复。</p>
<p><code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code></p>
<p><code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code></p>
<ul>
<li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li>
<li><code>public void clear()</code> :清空集合中所有的元素。</li>
<li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li>
<li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li>
<li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li>
<li><code>public int size()</code>: 返回集合中元素的个数。</li>
<li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li>
</ul>
<h3 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a><strong>Iterator迭代器</strong></h3><p><strong>Iterator接口</strong></p>
<ul>
<li><code>public E next()</code>:返回迭代的下一个元素。</li>
<li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a><strong>增强for</strong></h3><p>底层是实现迭代器接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">	System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a><strong>泛型</strong></h3><p>好处：</p>
<ul>
<li>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</li>
<li>避免了类型强转的麻烦。</li>
</ul>
<p>自定义泛型类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyGenericClass&lt;MVP&gt; &#123;</span><br><span class="line">	//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型</span><br><span class="line">	private MVP mvp;</span><br><span class="line">	</span><br><span class="line">    public void setMVP(MVP mvp) &#123;</span><br><span class="line">        this.mvp = mvp;</span><br><span class="line">    &#125;</span><br><span class="line">    public MVP getMVP() &#123;</span><br><span class="line">        return mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义泛型方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyGenericMethod &#123;	  </span><br><span class="line">    public &lt;MVP&gt; void show1(MVP mvp) &#123;</span><br><span class="line">    	System.out.println(mvp.getClass());</span><br><span class="line">    &#125;    </span><br><span class="line">    public &lt;MVP&gt; MVP show2(MVP mvp) &#123;	</span><br><span class="line">    	return mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义泛型接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface MyGenericInterface&lt;E&gt;&#123;</span><br><span class="line">	public abstract void add(E e);</span><br><span class="line">	public abstract E getE();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型通配符:</p>
<p><strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p>
<p>此时只能接受数据,不能往该集合中存储数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement</span><span class="params">(Collection&lt;?&gt; coll)</span>&#123;&#125;</span><br><span class="line"><span class="comment">//？代表可以接收任意类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Collection&lt;Intger&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    getElement(list1);</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    getElement(list2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>泛型上限</strong></p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li>
</ul>
<p><strong>泛型下限</strong></p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span><br><span class="line">public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;</span><br><span class="line">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span><br><span class="line">public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li><p>堆栈</p>
<p><strong>栈</strong>：<strong>stack</strong>,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</p>
<p>采用该结构的集合，对元素的存取有如下的特点</p>
<ul>
<li><p>先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</p>
</li>
<li><p>栈的入口、出口的都是栈的顶端位置。</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309171804960.png" alt="image-20230917180447896"></p>
<ul>
<li><strong>压栈</strong>：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li>
<li><strong>弹栈</strong>：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li>
</ul>
</li>
</ul>
</li>
<li><p>队列</p>
<p><strong>队列</strong>：<strong>queue</strong>,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</p>
<p>采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li><p>先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。</p>
</li>
<li><p>队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309171807256.bmp" alt="队列图"></p>
</li>
</ul>
</li>
<li><p>数组</p>
<p><strong>数组</strong>:<strong>Array</strong>,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。</p>
<p>采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li><p>查找元素快：通过索引，可以快速访问指定位置的元素</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309171808875.png" alt="image-20230917180810843"></p>
</li>
<li><p>增删元素慢</p>
<ul>
<li><p><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309171809969.png" alt="image-20230917180906932"></p>
</li>
<li><p><strong>指定索引位置删除元素：</strong>需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309171809989.png" alt="image-20230917180945960"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>链表</p>
<p><strong>链表</strong>:<strong>linked list</strong>,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，这里只说<strong>单向链表</strong>。</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309171810652.png" alt="image-20230917181045622"></p>
<p>采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li><p>多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</p>
<p><img src="/img/loading.gif" data-original="https://gitee.com/dengxing1277/blogimage/raw/master/imgs/202309211114035.png" alt="image-20230921111426007"></p>
</li>
<li><p>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</p>
</li>
<li><p>增删元素快：</p>
<ul>
<li><p>增加元素：只需要修改连接下个元素的地址即可。</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309171811993.png" alt="image-20230917181131960"></p>
</li>
<li><p>删除元素：只需要修改连接下个元素的地址即可。</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309171812342.bmp" alt="删除结点"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>红黑树 </p>
<ul>
<li><p><strong>二叉树</strong>：<strong>binary tree</strong> ,是每个结点不超过2的有序<strong>树（tree）</strong> 。</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309171813241.bmp" alt="二叉树"></p>
<p>我们要说的是二叉树的一种比较有意思的叫做<strong>红黑树</strong>，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。</p>
<p>红黑树的约束:</p>
<ol>
<li>节点可以是红色的或者黑色的</li>
</ol>
</li>
</ul>
</li>
</ul>
<pre><code>2. 根节点是黑色的


3. 叶子节点(特指空节点)是黑色的
4. 每个红色节点的子节点都是黑色的
5. 任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同

红黑树的特点:

​    速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍
</code></pre>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>特点:</p>
<ul>
<li>它是一个元素存取有序的集合</li>
<li>它是一个带有索引的集合</li>
<li>集合中可以有重复的元素,通过元素的equals方法，来比较是否为重复的元素。</li>
</ul>
<p><strong>ArrayList</strong></p>
<p>数组结构,增删慢,查找快,多用于遍历和查找</p>
<p><strong>LinkedList</strong></p>
<p>链表结构,增删快</p>
<p>常用方法</p>
<ul>
<li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li>
<li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li>
<li><code>public E getFirst()</code>:返回此列表的第一个元素。</li>
<li><code>public E getLast()</code>:返回此列表的最后一个元素。</li>
<li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li>
<li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li>
<li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li>
<li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li>
<li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">list.isEmpty();</span><br><span class="line">list.pop();</span><br><span class="line">list.push(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">list.addFirst(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">list.addLast(<span class="string">&quot;last&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a><strong>Set</strong></h3><p><strong>特点:</strong></p>
<ul>
<li>元素无序</li>
<li>不允许重复</li>
</ul>
<p><strong>HashSet</strong></p>
<p>底层的实现是<code>java.util.HashMap</code>类支持</p>
<p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p>
<p>在<strong>JDK1.8</strong>之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p>
<p>简单的来说，哈希表是由<strong>数组+链表+红黑树</strong>（JDK1.8增加了红黑树部分）实现的，如下图所示。</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309171830107.png" alt="image-20230917183042052"></p>
<p><strong>HashSet存储自定义类型元素</strong></p>
<p>自定义的存储元素对象必须重写 hashCode() 和equals方法,保证元素的唯一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//idea 快捷键 Alt+Insert</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Peroson)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> <span class="type">Peroson</span> <span class="variable">peroson</span> <span class="operator">=</span> (Peroson) o;</span><br><span class="line"> <span class="keyword">return</span> id.equals(peroson.id) &amp;&amp; username.equals(peroson.username) &amp;&amp; password.equals(peroson.password);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Objects.hash(id, username, password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可变参数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型... 形参名)&#123;  &#125;</span><br><span class="line">//等价于</span><br><span class="line">修饰符 返回值类型 方法名(参数类型[] 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure>

<p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组,这就是简单之处，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。</p>
<blockquote>
<p>注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int add(int... arr) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i : arr) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections**"></a>Collections**</h3><ul>
<li><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。部分方法如下：</li>
</ul>
<ul>
<li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)  </code>:往集合中添加一些元素。</li>
<li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li>
</ul>
<p><strong>Comparator比较器</strong></p>
<p><code>java.lang.Comparable</code></p>
<p><code>java.util.Comparator</code></p>
<ul>
<li><code> public int compare(String o1, String o2)</code>：比较其两个参数的顺序。</li>
</ul>
<blockquote>
<p>两个对象比较的结果有三种：大于，等于，小于。</p>
<p>如果要按照升序排序，<br>则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）<br>如果要按照降序排序<br>则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）</p>
</blockquote>
<p><strong>Comparable和Comparator的区别</strong></p>
<p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。</p>
<p><strong>Comparator</strong>强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">20</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">22</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="number">18</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用Comparator比较器按学生年龄进行排序</span></span><br><span class="line">        Collections.sort(students, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student s1, Student s2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> s1.getAge() - s2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输出排序后的学生列表</span></span><br><span class="line">        <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">            System.out.println(student.getName() + <span class="string">&quot; - &quot;</span> + student.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map&lt;key,value&gt;</p>
<p>value可以重复,key不能重复</p>
<ul>
<li>**HashMap&lt;K,V&gt;**：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li>
<li>**LinkedHashMap&lt;K,V&gt;**：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li>
</ul>
<blockquote>
<p>tips：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。</p>
</blockquote>
<p><strong>常用方法</strong></p>
<ul>
<li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li>
<li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li>
<li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li>
<li><code>boolean containsKey(Object key)  </code> 判断集合中是否包含指定的键。</li>
<li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li>
</ul>
<blockquote>
<p>tips:</p>
<p>使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； </p>
<p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 </p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">put1</span> <span class="operator">=</span> stringStringMap.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;102&quot;</span>);</span><br><span class="line">System.out.println(put1);<span class="comment">//null</span></span><br><span class="line"><span class="type">String</span> <span class="variable">put2</span> <span class="operator">=</span> stringStringMap.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;103&quot;</span>);</span><br><span class="line">System.out.println(put2);<span class="comment">//返回102</span></span><br></pre></td></tr></table></figure>

<p><strong>Map遍历键找值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取所有的键  获取键集</span></span><br><span class="line">Set&lt;String&gt; keys = map.keySet();</span><br><span class="line"><span class="comment">// 遍历键集 得到 每一个键</span></span><br><span class="line"><span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">  	<span class="comment">//key就是键</span></span><br><span class="line">    <span class="comment">//获取对应值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    System.out.println(key+<span class="string">&quot;的CP是：&quot;</span>+value);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>Entry键值对对象</strong></p>
<p><code>Map</code>中存放的是两种对象，一种称为<strong>key</strong>(键)，一种称为<strong>value</strong>(值)，它们在在<code>Map</code>中是一一对应关系，这一对对象又称做<code>Map</code>中的一个<code>Entry(项)</code>。<code>Entry</code>将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历<code>Map</code>集合时，就可以从每一个键值对（<code>Entry</code>）对象中获取对应的键与对应的值。</p>
<p>方法</p>
<ul>
<li><code>public K getKey()</code>：获取Entry对象中的键。</li>
<li><code>public V getValue()</code>：获取Entry对象中的值。</li>
</ul>
<p>Map集合获取Entry对象</p>
<ul>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li>
</ul>
<p><strong>Map遍历键值对找值</strong></p>
<ol>
<li> 获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:<code>entrySet()</code>。</li>
<li> 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</li>
<li> 通过键值对(Entry)对象，获取Entry对象中的键与值。  方法提示:<code>getkey() getValue()</code>     </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = stringStringMap.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : entries) &#123;</span><br><span class="line">    System.out.println(entry.getKey()+<span class="string">&quot;:&quot;</span>+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p> <strong>HashMap存储自定义类型键值</strong></p>
<p>自定义类中重写hashCode()和equals()方法 确保元素不重复 确保Key值唯一</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1,创建Hashmap集合对象。</span><br><span class="line">Map&lt;Student,String&gt;map = new HashMap&lt;Student,String&gt;();</span><br></pre></td></tr></table></figure>

<ul>
<li>当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。</li>
<li>如果要保证map中存放的key和取出的顺序一致，可以使用<code>java.util.LinkedHashMap</code>集合来存放</li>
</ul>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要保证查询速度快,我们使用LinkedHashMap&lt;key,value&gt;</p>
<p>在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedHashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, String&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="集合工厂"><a href="#集合工厂" class="headerlink" title="集合工厂"></a>集合工厂</h3><p><strong>JDK9</strong>添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integers = List.of(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Set&lt;String&gt; strings = Set.of(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">Map.of(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">2</span>,<span class="string">&quot;李四&quot;</span>,<span class="number">3</span>,<span class="string">&quot;王五&quot;</span>); </span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:</p>
<p>1:of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如    HashSet，ArrayList等</p>
<p>2:返回的集合是不可变的；</p>
</blockquote>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><strong>异常</strong> ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</p>
<p>在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。</p>
<blockquote>
<p>异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.</p>
</blockquote>
<p>异常根类:</p>
<p><code>java.lang.Throwable</code></p>
<p>子类：</p>
<p><code>java.lang.Error</code></p>
<p><code>java.lang.Exception</code></p>
<p>平常所说的异常指<code>java.lang.Exception</code></p>
<p><strong>Throwable中的常用方法：</strong></p>
<ul>
<li><p><code>public void printStackTrace()</code>:打印异常的详细信息。</p>
<p><em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p>
</li>
<li><p><code>public String getMessage()</code>:获取发生异常的原因。</p>
<p><em>提示给用户的时候,就提示错误原因。</em></p>
</li>
<li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p>
</li>
</ul>
<p><strong>异常(Exception)的分类</strong>:</p>
<ul>
<li><strong>编译时期异常</strong>:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)</li>
<li><strong>运行时期异常</strong>:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)</li>
</ul>
<p><strong>异常的处理</strong></p>
<p>try、catch、finally、throw、throws</p>
<p><strong>throw</strong></p>
<p>throw<strong>用在方法内</strong>，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断索引是否越界</span></span><br><span class="line"><span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。</span></span><br><span class="line"><span class="comment">    这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(<span class="string">&quot;哥们，角标越界了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：产生了问题，就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。</p>
<p>那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。</p>
</blockquote>
<p><strong>throws</strong></p>
<p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。</p>
<p>关键字<strong>throws</strong>运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).</p>
<p><strong>声明异常格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123;   &#125;	</span><br></pre></td></tr></table></figure>

<p><strong>捕获异常</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  e)&#123;</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>finally 代码块</strong></p>
<p><strong>finally</strong>：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p><strong>异常类如何定义:</strong></p>
<ol>
<li>自定义一个编译期异常: 自定义类 并继承于<code>java.lang.Exception</code>。</li>
<li>自定义一个运行时期的异常类:自定义类 并继承于<code>java.lang.RuntimeException</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 业务逻辑异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegisterException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空参构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RegisterException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 表示异常提示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RegisterException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p><strong>并发与并行</strong></p>
<ul>
<li><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。</li>
<li><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。</li>
</ul>
<p><strong>线程与进程</strong></p>
<ul>
<li><p><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p>
</li>
<li><p><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 </p>
</li>
</ul>
<p><strong>线程调度:</strong></p>
<ul>
<li><p>分时调度</p>
<p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p>
</li>
<li><p>抢占式调度</p>
<p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p>
</li>
</ul>
<p><strong>线程类</strong></p>
<p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p>
<ol>
<li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象</li>
<li>调用线程对象的start()方法来启动该线程</li>
</ol>
<p><strong>自定义线程类:继承Thread类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">	//定义指定线程名称的构造方法</span><br><span class="line">	public MyThread(String name) &#123;</span><br><span class="line">		//调用父类的String参数的构造方法，指定线程的名称</span><br><span class="line">		super(name);</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 重写run方法，完成该线程执行的逻辑</span><br><span class="line">	 */</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">			System.out.println(getName()+&quot;：正在执行！&quot;+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用线程</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">NewThread</span>(<span class="string">&quot;线程1&quot;</span>).run();</span><br></pre></td></tr></table></figure>

<p>多线程执行时，在栈内存中，<strong>其实每一个执行线程都有一片自己所属的栈内存空间</strong>。进行方法的压栈和弹栈。</p>
<p><strong>构造函数</strong></p>
<ul>
<li>public Thread() :分配一个新的线程对象。</li>
<li>public Thread(String name) :分配一个指定名字的新的线程对象。</li>
<li>public Thread(Runnable target) :分配一个带有指定目标新的线程对象。</li>
<li>public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字</li>
</ul>
<p><strong>常用方法</strong></p>
<ul>
<li>public String getName() :获取当前线程名称。</li>
<li>public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。</li>
<li>public void run() :此线程要执行的任务在此处定义代码。</li>
<li>public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</li>
<li>public static Thread currentThread() :返回对当前正在执行的线程对象的引用。</li>
</ul>
<p><strong>自定义线程:实现Runnable</strong></p>
<p>步骤如下：</p>
<ol>
<li><p>定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</p>
</li>
<li><p>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正<br>的线程对象。</p>
</li>
<li><p>调用线程对象的start()方法来启动线程。<br>代码如下：</p>
</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;        </span><br><span class="line">    	System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);         </span><br><span class="line">    &#125;        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  使用</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyRunnable</span> <span class="variable">myrunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(myrunnable, <span class="string">&quot;线程名&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p><strong>Thread 和Runnable的区别</strong></p>
<p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。<br><strong>总结：</strong><br>实现Runnable接口比继承Thread类所具有的优势：</p>
<ol>
<li><p>适合多个相同的程序代码的线程去共享同一个资源。</p>
</li>
<li><p>可以避免java中的单继承的局限性。</p>
</li>
<li><p>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</p>
</li>
<li><p>线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。</p>
</li>
</ol>
<blockquote>
<p>扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。</p>
</blockquote>
<p><strong>使用匿名内部类实现线程创建</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(System.currentTimeMillis());</span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(runnable).start();</span><br></pre></td></tr></table></figure>

<p><strong>线程安全</strong></p>
<blockquote>
<p>线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p>
</blockquote>
<p><strong>线程同步</strong></p>
<p><code>synchronized</code></p>
<p>  1 . 同步代码块:关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">synchronized(同步锁)&#123;</span><br><span class="line">     需要同步操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>同步锁</strong>:对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁.</p>
<ul>
<li>锁对象 可以是任意类型。</li>
<li>多个线程对象 要使用同一把锁。<br>注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着<br>(BLOCKED)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">			<span class="comment">//代码块</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p>同步方法::使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public synchronized void methodDemo()&#123;</span><br><span class="line">   可能会产生线程安全问题的代码 </span><br><span class="line">&#125;</span><br><span class="line">//run方法调用锁住的方法</span><br><span class="line">@override</span><br><span class="line">public void run()&#123;</span><br><span class="line">	while(true)&#123;</span><br><span class="line">		methodDemo();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>同步锁是谁?<br>对于非static方法,同步锁就是this。<br>对于static方法,我们使用当前方法所在类的字节码对象(类名.class)</p>
</blockquote>
</li>
<li><p>锁机制:<code>java.util.concurrent.locks.Lock </code></p>
</li>
</ol>
<p>​    Lock锁也称同步锁，加锁与释放锁方法化了</p>
<ul>
<li>public void lock() :加同步锁。</li>
<li>public void unlock() :释放同步锁。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@override</span><br><span class="line">public void run()&#123;</span><br><span class="line">	while(true)&#123;</span><br><span class="line">		Lock.lock();</span><br><span class="line">		//中间放存在线程安全的代码</span><br><span class="line">		Lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a><strong>线程状态</strong></h3><p><strong>线程状态</strong></p>
<p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，在API中 <code>java.lang.Thread.State </code>这个枚举中给出了六种线程状态：</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309172224406.png" alt="image-20230917222411304"></p>
<p><strong>Timed Waiting （计时等待）</strong></p>
<p>调用sleep()方法之后,当前执行的线程进入到睡眠的状态,就是所谓的Timed Waiting （计时等待）状态</p>
<blockquote>
<p>tips:</p>
<ol>
<li>进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协作关系。</li>
<li>为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程中会睡眠</li>
<li>sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态</li>
<li>sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始立刻执行。</li>
</ol>
</blockquote>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309172231802.png" alt="image-20230917223102753"></p>
<p><strong>BLOCKED （锁阻塞）</strong></p>
<p>Runnable状态进入Blocked状态:</p>
<p>线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。</p>
<p>Waiting以及Time Waiting进入到Blocked状态</p>
<p><strong>Waiting （无限等待）</strong></p>
<p>一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> 		<span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      lock.wait();<span class="comment">//无限时睡眠 等待唤醒</span></span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">runnable1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                  lock.notify();<span class="comment">//唤醒当前睡眠锁对象</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure>

<p>一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的Object.notify()方法 或 Object.notifyAll()方法。</p>
<p>其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，多个线程会争取锁，同时相互之间又存在协作关系。<br>当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309172244933.png" alt="image-20230917224455853"></p>
<p><strong>等待唤醒机制</strong></p>
<ul>
<li>为什么要处理线程间通信：</li>
</ul>
<p>多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。</p>
<ul>
<li>如何保证线程间通信有效利用资源：</li>
</ul>
<p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— <strong>等待唤醒机制。</strong></p>
<p><strong>什么是等待唤醒机制</strong></p>
<p>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的<strong>竞争（race）</strong>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。</p>
<p>就是在一个线程进行了规定操作后，就进入等待状态（**wait()<strong>）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（</strong>notify()**）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。</p>
<p>wait/notify 就是线程间的一种协作机制。</p>
<p><strong>等待唤醒中的方法</strong></p>
<p>等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：</p>
<ol>
<li>wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个<strong>特别的动作</strong>，也即是“<strong>通知（notify）</strong>”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中</li>
<li>notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。</li>
<li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li>
</ol>
<blockquote>
<p>注意：</p>
<p>哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。</p>
<p>总结如下：</p>
<ul>
<li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；</li>
<li>否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态</li>
</ul>
</blockquote>
<p><strong>调用wait和notify方法需要注意的细节</strong></p>
<ol>
<li>wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li>
<li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li>
<li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。</li>
</ol>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><strong>使用线程池</strong></p>
<p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p>
<p>在<code>java.util.concurrent.Executors</code>线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。</p>
<p>Executors类中有个创建线程池的方法如下：</p>
<ul>
<li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)</li>
</ul>
<p>获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：</p>
<ul>
<li><p><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</p>
<blockquote>
<p>Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。</p>
</blockquote>
</li>
</ul>
<p>使用线程池中线程对象的步骤：</p>
<ol>
<li>创建线程池对象。</li>
<li>创建Runnable接口子类对象。(task)</li>
<li>提交Runnable接口子类对象。(take task)</li>
<li>关闭线程池(一般不关闭)。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程池对象,包含2个线程对象</span></span><br><span class="line">     <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">     <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">             System.out.println(Thread.currentThread().getName());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="comment">//从线程池中获取线程对象,然后调用runnable中的run()</span></span><br><span class="line">     service.submit(runnable);</span><br><span class="line">     <span class="comment">//多次调用</span></span><br><span class="line">     service.submit(runnable);</span><br><span class="line">     service.submit(runnable);</span><br><span class="line">     <span class="comment">//关闭线程池</span></span><br><span class="line">     service.shutdown();</span><br></pre></td></tr></table></figure>

<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a><strong>Lambda表达式</strong></h3><p><strong>强调做什么，而不是以什么形式做</strong></p>
<p>格式:</p>
<ul>
<li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li>
<li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li>
<li>大括号内的语法与传统方法体要求基本一致。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(参数类型 参数名称) -&gt; &#123; 代码语句 &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Lambda表达式的使用条件</strong></p>
<p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p>
<ol>
<li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。<br>无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</li>
<li>使用Lambda必须具有<strong>上下文推断</strong>。<br>也就是<strong>方法的参数或局部变量类型</strong>必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li>
</ol>
<blockquote>
<p>备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p>
</blockquote>
<p>匿名内部类-&gt;Lambda表达式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="comment">//Lambda表达式</span></span><br><span class="line">* 前面的一对小括号即`run`方法的参数（无），代表不需要任何条件；</span><br><span class="line">      * 中间的一个箭头代表将前面的参数传递给后面的代码；</span><br><span class="line">      * 后面的输出语句即业务逻辑代码。</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>)).start();</span><br></pre></td></tr></table></figure>

<p><strong>使用Lambda标准格式（无参无返回）</strong></p>
<p>定义一个接口,内含唯一一个抽象方法,无参无返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cook</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeFood</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个方法,方法使用接口作为形式参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeCook</span><span class="params">(Cook cook)</span> &#123;</span><br><span class="line">        cook.makeFood();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lambda实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">invokeCook(() -&gt; &#123;</span><br><span class="line">      	System.out.println(<span class="string">&quot;吃饭啦！&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>使用Lambda标准格式（有参有返回）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Calculator &#123;</span><br><span class="line">    int calc(int a, int b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeCalc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, Calculator calculator)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;结果是：&quot;</span> + calculator.calc(a, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lambda实现:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invokeCalc(1,2,(int a,int b)-&gt;&#123;return a+b&#125;);,</span><br></pre></td></tr></table></figure>

<p><strong>Lambda省略格式</strong></p>
<p><strong>可推导即可省略</strong></p>
<p>Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。</p>
<p><strong>省略规则</strong></p>
<p>在Lambda标准格式的基础上，使用省略写法的规则为：</p>
<ol>
<li>小括号内参数的类型可以省略；</li>
<li>如果小括号内<strong>有且仅有一个参</strong>，则小括号可以省略；</li>
<li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号 (;)。</li>
</ol>
<p><strong>Lambda的延迟执行</strong></p>
<p>解决资源浪费问题</p>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口在Java中是指：有且仅有一个抽象方法的接口。<br>函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。</p>
<blockquote>
<p>备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部类的“语法糖”，但是二者在原理上是不同的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 interface 接口名称 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名称(可选参数信息);</span><br><span class="line">    <span class="comment">// 其他非抽象方法内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口当中抽象方法的 public abstract 可省略</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyFunctionalInterface</span> &#123;   </span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@FunctionalInterface</strong></p>
<p>与 @Override 注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解： @FunctionalInterface 。该注解可用于一个接口的定义上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyFunctionalInterface</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>典型使用场景:作为方法的参数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用自定义的函数式接口作为方法参数    </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(MyFunctionalInterface inter)</span> &#123;    </span><br><span class="line">	inter.myMethod(); <span class="comment">// 调用自定义的函数式接口方法        </span></span><br><span class="line">&#125;    </span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    </span><br><span class="line">	<span class="comment">// 调用使用函数式接口的方法        </span></span><br><span class="line">	doSomething(() ‐&gt; System.out.println(<span class="string">&quot;Lambda执行啦！&quot;</span>));        </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a><strong>Stream流</strong></h3><p>专注于做什么而不是怎么做</p>
<p>解决集合的现有弊端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = List.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;姜子牙&quot;</span>, <span class="string">&quot;李元芳&quot;</span>, <span class="string">&quot;典韦&quot;</span>);</span><br><span class="line">strings.stream().filter(s-&gt;s.startsWith(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">strings.stream().filter(s-&gt;s.length() == <span class="number">3</span>);</span><br><span class="line">strings.stream().forEach(System.out::println); </span><br><span class="line"></span><br><span class="line"><span class="comment">//流式 语义: 获取流、过滤姓张、过滤长度为3、逐一打印</span></span><br><span class="line">strings.stream().filter(s-&gt;s.startsWith(<span class="string">&quot;张&quot;</span>)).filter(s-&gt;s.length() == <span class="number">3</span>).forEach(System.out::println); </span><br></pre></td></tr></table></figure>

<p><strong>流式思想</strong></p>
<p>流式思想类似于工厂车间的“<strong>生产流水线</strong>”。</p>
<p><code> filter</code> 、 <code>map</code> 、 <code>skip </code>都是在对函数模型进行操作，集合元素并没有真正被处理。只有当终结方法 <code>count</code>执行的时候，整个模型才会按照指定策略执行操作。而这得益于Lambda的延迟执行特性。</p>
<blockquote>
<p>“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。</p>
</blockquote>
<p><strong>Stream流</strong></p>
<ul>
<li><p>Stream（流）是一个来自数据源的元素队列</p>
<p>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</p>
</li>
<li><p>数据源 流的来源。 可以是集合，数组 等。</p>
<p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p>
<ul>
<li>Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluentstyle）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li>
<li>内部迭代： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。</li>
</ul>
<p>当使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道。</p>
</li>
</ul>
<p><strong>获取流</strong></p>
<p><code>java.util.stream.Stream&lt;T&gt;</code> 是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。）<br>获取一个流非常简单，有以下几种常用的方式：<br>所有的 Collection 集合都可以通过 stream 默认方法获取流；<br>Stream 接口的静态方法 of 可以获取数组对应的流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Collection获取流</span></span><br><span class="line">List&lt;String&gt; strings = List.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;姜子牙&quot;</span>, <span class="string">&quot;李元芳&quot;</span>, <span class="string">&quot;典韦&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stream = strings.stream();</span><br><span class="line"><span class="comment">//Map获取流</span></span><br><span class="line">Map&lt;Integer, String&gt; map = Map.of(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">2</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream1 = map.keySet().stream();</span><br><span class="line">Stream&lt;String&gt; stream2 = map.values().stream();</span><br><span class="line">Stream&lt;Map.Entry&lt;Integer, String&gt;&gt; stream3 = map.entrySet().stream();</span><br><span class="line"><span class="comment">//数组获取流  of 方法的参数是一个可变参数，所以支持数组。</span></span><br><span class="line">Integer[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Stream&lt;Integer&gt; stream4 = Stream.of(array);</span><br></pre></td></tr></table></figure>

<p><strong>方法</strong></p>
<ul>
<li><strong>延迟方法：</strong>返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为延迟方法。</li>
<li><strong>终结方法：</strong>返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调用。终结方法包括 count 和 forEach 方法等。</li>
</ul>
<p><strong>foreach:循环</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void forEach(Consumer&lt;? super T&gt; action);</span><br><span class="line">接收一个 Consumer 接口函数，会将每一个流元素交给该函数进行处理。</span><br><span class="line">java.util.function.Consumer&lt;T&gt;接口是一个消费型接口。</span><br><span class="line">Consumer接口中包含抽象方法void accept(T t)，意为消费一个指定泛型的数据。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">练习:</span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);</span><br><span class="line">stream.forEach(name‐&gt; System.out.println(name));</span><br></pre></td></tr></table></figure>

<p><strong>filter:过滤</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</span><br><span class="line">java.util.stream.Predicate 函数式接口包含抽象方法</span><br><span class="line">boolean test(T t);</span><br><span class="line">该方法将会产生一个boolean值结果，代表指定的条件是否满足。如果结果为true，那么Stream流的 filter 方法将会留用元素；如果结果为false，那么 filter 方法将会舍弃元素。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">练习:</span><br><span class="line"> Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);</span><br><span class="line"> Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(&quot;张&quot;));</span><br></pre></td></tr></table></figure>

<p><strong>map:映射</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</span><br><span class="line">java.util.stream.Function 函数式接口的抽象方法</span><br><span class="line">R apply(T t);可以将当前流中的T类型数据转换为另一种R类型的流。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用:</span><br><span class="line">Stream&lt;String&gt; original = Stream.of(&quot;10&quot;, &quot;12&quot;, &quot;18&quot;);</span><br><span class="line">Stream&lt;Integer&gt; result = original.map(str‐&gt;Integer.parseInt(str));</span><br></pre></td></tr></table></figure>

<p><strong>count:计数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; s = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);</span><br><span class="line">s.count();</span><br></pre></td></tr></table></figure>

<p><strong>limit:截取前几个</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; result = original.limit(<span class="number">2</span>);<span class="comment">//取前两个</span></span><br></pre></td></tr></table></figure>

<p><strong>skip:跳过前几个</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);</span><br><span class="line">Stream&lt;String&gt; result = original.skip(2);</span><br></pre></td></tr></table></figure>

<p><strong>concat:组合</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//静态方法</span><br><span class="line">Stream&lt;String&gt; streamA = Stream.of(&quot;张无忌&quot;);</span><br><span class="line">Stream&lt;String&gt; streamB = Stream.of(&quot;张翠山&quot;);</span><br><span class="line">Stream&lt;String&gt; result = Stream.concat(streamA, streamB);</span><br></pre></td></tr></table></figure>





<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码</span><br><span class="line">* 反射：将类的各个组成部分封装为其他对象，这就是反射机制</span><br><span class="line">	* 好处：</span><br><span class="line">		1. 可以在程序运行过程中，操作这些对象。</span><br><span class="line">		2. 可以解耦，提高程序的可扩展性。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 获取Class对象的方式：</span><br><span class="line">	1. Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象</span><br><span class="line">		* 多用于配置文件，将类名定义在配置文件中。读取文件，加载类</span><br><span class="line">	2. 类名.class：通过类名的属性class获取</span><br><span class="line">		* 多用于参数的传递</span><br><span class="line">	3. 对象.getClass()：getClass()方法在Object类中定义着。</span><br><span class="line">		* 多用于对象的获取字节码的方式</span><br><span class="line"></span><br><span class="line">	* 结论：</span><br><span class="line">	同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* Class对象功能：</span><br><span class="line">	* 获取功能：</span><br><span class="line">		1. 获取成员变量们</span><br><span class="line">			* Field[] getFields() ：获取所有public修饰的成员变量</span><br><span class="line">			* Field getField(String name)   获取指定名称的 public修饰的成员变量</span><br><span class="line"></span><br><span class="line">			* Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符</span><br><span class="line">			* Field getDeclaredField(String name)  </span><br><span class="line">		2. 获取构造方法们</span><br><span class="line">			* Constructor&lt;?&gt;[] getConstructors()  </span><br><span class="line">			* Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)  </span><br><span class="line"></span><br><span class="line">			* Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)  </span><br><span class="line">			* Constructor&lt;?&gt;[] getDeclaredConstructors()  </span><br><span class="line">		3. 获取成员方法们：</span><br><span class="line">			* Method[] getMethods()  </span><br><span class="line">			* Method getMethod(String name, 类&lt;?&gt;... parameterTypes)  </span><br><span class="line"></span><br><span class="line">			* Method[] getDeclaredMethods()  </span><br><span class="line">			* Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)  </span><br><span class="line"></span><br><span class="line">		4. 获取全类名	</span><br><span class="line">			* String getName()  </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* Field：成员变量</span><br><span class="line">	* 操作：</span><br><span class="line">		1. 设置值</span><br><span class="line">			* void set(Object obj, Object value)  </span><br><span class="line">		2. 获取值</span><br><span class="line">			* get(Object obj) </span><br><span class="line"></span><br><span class="line">		3. 忽略访问权限修饰符的安全检查</span><br><span class="line">			* setAccessible(true):暴力反射</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* Constructor:构造方法</span><br><span class="line">	* 创建对象：</span><br><span class="line">		* T newInstance(Object... initargs)  </span><br><span class="line"></span><br><span class="line">		* 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* Method：方法对象</span><br><span class="line">	* 执行方法：</span><br><span class="line">		* Object invoke(Object obj, Object... args)  </span><br><span class="line"></span><br><span class="line">	* 获取方法名称：</span><br><span class="line">		* String getName:获取方法名</span><br></pre></td></tr></table></figure>



<h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p>Java中的File类可以用于描述和操作文件或目录。File类提供了一些方法来创建、删除、重命名、判断文件是否存在等操作。在处理文件流时，可以使用FileInputStream和FileOutputStream来读写文件。</p>
<p>创建File对象： 可以使用File类的构造函数来创建File对象，可以传入文件路径或目录路径作为参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;path/to/file.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>判断文件是否存在： 可以使用File对象的exists()方法来判断文件是否存在。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> file.exists();</span><br></pre></td></tr></table></figure>

<p>创建文件或目录： 可以使用File对象的createNewFile()方法创建新的文件，使用mkdir()方法创建新的目录。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> file.createNewFile();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> file.mkdir();</span><br></pre></td></tr></table></figure>

<p>删除文件或目录： 可以使用File对象的delete()方法来删除文件或目录。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> file.delete();</span><br></pre></td></tr></table></figure>

<p>重命名文件或目录： 可以使用File对象的renameTo()方法来重命名文件或目录。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">newFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;path/to/newname.txt&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> file.renameTo(newFile);</span><br></pre></td></tr></table></figure>

<p>读取文件： 可以使用FileInputStream类来读取文件的内容。首先创建FileInputStream对象，然后使用其read()方法读取文件中的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="keyword">while</span> ((data = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理读取到的数据</span></span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure>

<p>写入文件： 可以使用FileOutputStream类来写入数据到文件中。首先创建FileOutputStream对象，然后使用其write()方法将数据写入文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line"><span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">fos.write(data.getBytes());</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>

<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul>
<li><p><strong>递归</strong>：指在当前方法内调用自己的这种现象。</p>
</li>
<li><p><strong>递归的分类:</strong></p>
<ul>
<li>递归分为两种，直接递归和间接递归。</li>
<li>直接递归称为方法自身调用自己。</li>
<li>间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。</li>
</ul>
</li>
<li><p><strong>注意事项</strong>：</p>
<ul>
<li>递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。</li>
<li>在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</li>
<li>构造方法,禁止递归</li>
</ul>
</li>
</ul>
<h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><p><strong>分类</strong></p>
<ul>
<li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 </li>
<li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。</li>
</ul>
<p><strong>类型</strong></p>
<p>Java中提供了两种不同类型的流用于处理输入和输出：字节流和字符流。字节流主要用于读写二进制数据，而字符流主要用于读写文本文件。</p>
<p><strong>字节流：</strong></p>
<ol>
<li>字节输入流-InputStream：<ul>
<li>InputStream是所有字节输入流的基类，可以使用它来从源读取字节数据。常用的子类有FileInputStream、ByteArrayInputStream等。</li>
<li>使用字节输入流读取数据可以通过read()、read(byte[] buffer)等方法，读取单个字节或者一次读取多个字节。可以使用循环结构一次读取多个字节，并处理读取到的字节数据。</li>
</ul>
</li>
<li>字节输出流-OutputStream：<ul>
<li>OutputStream是所有字节输出流的基类，可以使用它来向目标写入字节数据。常用的子类有FileOutputStream、ByteArrayOutputStream等。</li>
<li>使用字节输出流写入数据可以通过write(int b)、write(byte[] buffer)等方法，写入单个字节或者一次写入多个字节。可以使用循环结构一次写入多个字节。</li>
</ul>
</li>
</ol>
<p><strong>字符流：</strong></p>
<ol>
<li>字符输入流-Reader：<ul>
<li>Reader是所有字符输入流的基类，可以使用它来从源读取字符数据。常用的子类有FileReader、CharArrayReader等。</li>
<li>使用字符输入流读取数据可以通过read()、read(char[] buffer)等方法，读取单个字符或者一次读取多个字符。可以使用循环结构一次读取多个字符，并处理读取到的字符数据。</li>
</ul>
</li>
<li>字符输出流-Writer：<ul>
<li>Writer是所有字符输出流的基类，可以使用它来向目标写入字符数据。常用的子类有FileWriter、CharArrayWriter等。</li>
<li>使用字符输出流写入数据可以通过write(int c)、write(String str)等方法，写入单个字符或者一次写入多个字符。可以使用循环结构一次写入多个字符。</li>
</ul>
</li>
</ol>
<p>注意事项：</p>
<ul>
<li>字节流适用于处理二进制文件和任意文件的输入输出。</li>
<li>字符流适用于处理文本文件和文本数据的输入输出。</li>
<li>在处理文本文件时，使用字符流更为方便，可直接按行读取和写入文本数据。</li>
</ul>
<p><strong>父类</strong></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><strong>输入流</strong></th>
<th align="center">输出流</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>字节流</strong></td>
<td align="center">字节输入流 <strong>InputStream</strong></td>
<td align="center">字节输出流 <strong>OutputStream</strong></td>
</tr>
<tr>
<td align="center"><strong>字符流</strong></td>
<td align="center">字符输入流 <strong>Reader</strong></td>
<td align="center">字符输出流 <strong>Writer</strong></td>
</tr>
</tbody></table>
<p><strong>字节流</strong></p>
<p><strong>字节输出流:OutputStream</strong></p>
<p>共性方法:</p>
<ul>
<li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。  </li>
<li><code>public void flush() </code> ：刷新此输出流并强制任何缓冲的输出字节被写出。  </li>
<li><code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。  </li>
<li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  </li>
<li><code>public abstract void write(int b)</code> ：将指定的字节输出流。</li>
</ul>
<p><strong>FileOutputStream</strong></p>
<p><code>java.io.FileOutputStream</code></p>
<p>构造方法</p>
<ul>
<li><code>public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的 File对象表示的文件。 </li>
<li><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称写入文件。 </li>
</ul>
<p><strong>字节输入流:InputStream</strong></p>
<p><code>java.io.InputStream </code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p>
<ul>
<li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。    </li>
<li><code>public abstract int read()</code>： 从输入流读取数据的下一个字节。 </li>
<li><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中</li>
</ul>
<p><strong>FileInputStream</strong></p>
<p>构造方法</p>
<ul>
<li><code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 </li>
<li><code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。  </li>
</ul>
<p><strong>字符流</strong></p>
<p> <strong>字符输入流:Reader</strong></p>
<p><code>java.io.Reader</code>抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p>
<ul>
<li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。    </li>
<li><code>public int read()</code>： 从输入流读取一个字符。 </li>
<li><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。</li>
</ul>
<p><strong>FileReader</strong></p>
<p>构造方法</p>
<ul>
<li><code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的File对象。   </li>
<li><code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的名称。 </li>
</ul>
<p><strong>字符输出流:Writer</strong></p>
<p><code>java.io.Writer </code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<ul>
<li><code>void write(int c)</code> 写入单个字符。</li>
<li><code>void write(char[] cbuf) </code>写入字符数组。 </li>
<li><code>abstract  void write(char[] cbuf, int off, int len) </code>写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 </li>
<li><code>void write(String str) </code>写入字符串。 </li>
<li><code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</li>
<li><code>void flush() </code>刷新该流的缓冲。  </li>
<li><code>void close()</code> 关闭此流，但要先刷新它。 </li>
</ul>
<p><strong>FileWriter</strong></p>
<p>构造方法</p>
<ul>
<li><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。   </li>
<li><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。  </li>
</ul>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p><code>java.util.Properties </code> 继承于<code> Hashtable</code> ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，<code>System.getProperties</code> 方法就是返回一个<code>Properties</code>对象。</p>
<p>构造方法</p>
<p><code>public Properties()</code> :创建一个空的属性列表。</p>
<p>存储方法</p>
<ul>
<li><code>public Object setProperty(String key, String value)</code> ： 保存一对属性。  </li>
<li><code>public String getProperty(String key) </code> ：使用此属性列表中指定的键搜索属性值。</li>
<li><code>public Set&lt;String&gt; stringPropertyNames() </code> ：所有键的名称的集合。</li>
</ul>
<h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p>缓冲流,也叫高效流，是对4个基本的<code>FileXxx</code> 流的增强，所以也是4个流，按照数据类型分类：</p>
<ul>
<li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li>
<li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li>
</ul>
<p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p>
<p><strong>字节缓冲流</strong></p>
<p>构造方法</p>
<ul>
<li><code>public BufferedInputStream(InputStream in)</code> ：创建一个 新的缓冲输入流。 </li>
<li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字节缓冲输入流</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;bis.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 创建字节缓冲输出流</span></span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;bos.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>字符缓冲流</strong></p>
<p>构造方法</p>
<ul>
<li><code>public BufferedReader(Reader in)</code> ：创建一个 新的缓冲输入流。 </li>
<li><code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字符缓冲输入流</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;br.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 创建字符缓冲输出流</span></span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;bw.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a><strong>转换流</strong></h3><p><strong>InputStreamReader</strong></p>
<p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<p><strong>构造方法</strong></p>
<ul>
<li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 </li>
<li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;in.txt&quot;</span>));</span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;in.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>OutputStreamWriter</strong></p>
<p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<p><strong>构造方法</strong></p>
<ul>
<li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 </li>
<li><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>));</span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">isr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="序列流"><a href="#序列流" class="headerlink" title="序列流"></a>序列流</h3><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。 </p>
<p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。看图理解序列化： </p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309181509834.png" alt="image-20230918150948635"></p>
<p><code>java.io.ObjectOutputStream </code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p>
<p><strong>构造方法</strong></p>
<ul>
<li><code>public ObjectOutputStream(OutputStream out) </code>： 创建一个指定OutputStream的ObjectOutputStream。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;employee.txt&quot;</span>);</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOut);</span><br></pre></td></tr></table></figure>

<p><strong>序列化满足条件</strong></p>
<ul>
<li>该类必须实现<code>java.io.Serializable </code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</li>
<li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Employee implements java.io.Serializable &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public String address;</span><br><span class="line">    public transient int age; // transient瞬态修饰成员,不会被序列化</span><br><span class="line">    public void addressCheck() &#123;</span><br><span class="line">      	System.out.println(&quot;Address  check : &quot; + name + &quot; - &quot; + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法</strong></p>
<p><code>public final void writeObject (Object obj)</code> : 将指定的对象写出</p>
<p><strong>反序列化</strong></p>
<p><code>ObjectInputStream</code></p>
<p>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </p>
<p>构造方法</p>
<p><code>public ObjectInputStream(InputStream in) </code>： 创建一个指定InputStream的ObjectInputStream。</p>
<p>方法</p>
<p><strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong>  </p>
<p><strong>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。</strong></p>
<p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Employee implements java.io.Serializable &#123;</span><br><span class="line">     // 加入序列版本号</span><br><span class="line">     private static final long serialVersionUID = 1L;</span><br><span class="line">     public String name;</span><br><span class="line">     </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>



<h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p><code>print</code>方法和<code>println</code>这两个方法都来自于<code>java.io.PrintStream</code>类</p>
<p><strong>PrintStream</strong></p>
<p>构造方法</p>
<p><code>public PrintStream(String fileName)  </code>： 使用指定的文件名创建一个新的打印流。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PrintStream ps = new PrintStream(&quot;ps.txt&quot;)；</span><br></pre></td></tr></table></figure>

<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><p><strong>软件结构</strong></p>
<p><strong>C/S结构</strong> ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件</p>
<p><strong>B/S结构</strong> ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。</p>
<p><strong>协议</strong></p>
<ul>
<li><strong>TCP/IP协议：</strong> 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</li>
</ul>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309181857749.png" alt="image-20230918185708648"></p>
<p><strong>协议分类</strong></p>
<ul>
<li><p>UDP</p>
<p>UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。</p>
<p>使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输</p>
</li>
<li><p>TCP/IP</p>
<p>传输控制协议 (Transmission Control Protocol)。TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</p>
<p>在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</p>
<ul>
<li>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。<ul>
<li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。</li>
<li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。</li>
<li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>网络编程三要素:协议,IP地址,端口号</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a><strong>TCP</strong></h3><p><strong>在Java中，提供了两个类用于实现TCP通信程序：</strong></p>
<ol>
<li>客户端：<code>java.net.Socket</code> 类表示。创建<code>Socket</code>对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li>
<li>服务端：<code>java.net.ServerSocket</code> 类表示。创建<code>ServerSocket</code>对象，相当于开启一个服务，并等待客户端的连接。</li>
</ol>
<p><strong>Socket类</strong>  </p>
<p><code>Socket</code> 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。</p>
<p><strong>构造方法</strong></p>
<ul>
<li><p><code>public Socket(String host, int port)</code> :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。  </p>
<blockquote>
<p>小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br></pre></td></tr></table></figure>

<p><strong>成员方法</strong></p>
<ul>
<li><code>public InputStream getInputStream()</code> ： 返回此套接字的输入流。<ul>
<li>如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。</li>
<li>关闭生成的InputStream也将关闭相关的Socket。</li>
</ul>
</li>
<li><code>public OutputStream getOutputStream()</code> ： 返回此套接字的输出流。<ul>
<li>如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。</li>
<li>关闭生成的OutputStream也将关闭相关的Socket。</li>
</ul>
</li>
<li><code>public void close()</code> ：关闭此套接字。<ul>
<li>一旦一个socket被关闭，它不可再使用。</li>
<li>关闭此socket也将关闭相关的InputStream和OutputStream 。 </li>
</ul>
</li>
<li><code>public void shutdownOutput()</code> ： 禁用此套接字的输出流。   <ul>
<li>任何先前写出的数据将被发送，随后终止输出流。 </li>
</ul>
</li>
</ul>
<p><strong>ServerSocket类</strong></p>
<p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p>
<p><strong>构造方法</strong></p>
<ul>
<li><code>public ServerSocket(int port)</code> ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure>

<p><strong>成员方法</strong></p>
<ul>
<li><code>public Socket accept()</code> ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 </li>
</ul>
<p><strong>TCP通信分析图解</strong></p>
<ol>
<li>【服务端】启动,创建ServerSocket对象，等待连接。</li>
<li>【客户端】启动,创建Socket对象，请求连接。</li>
<li>【服务端】接收连接,调用accept方法，并返回一个Socket对象。</li>
<li>【客户端】Socket对象，获取OutputStream，向服务端写出数据。</li>
<li>【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。</li>
</ol>
<blockquote>
<p>到此，客户端向服务端发送数据成功。</p>
</blockquote>
<p><img src="/img/loading.gif" data-original="https://gitee.com/dengxing1277/blogimage/raw/master/imgs/202309211115393.jpeg"></p>
<blockquote>
<p>自此，服务端向客户端回写数据。</p>
</blockquote>
<ol start="6">
<li>【服务端】Socket对象，获取OutputStream，向客户端回写数据。</li>
<li>【客户端】Scoket对象，获取InputStream，解析回写数据。</li>
<li>【客户端】释放资源，断开连接。</li>
</ol>
<p><strong>客户端向服务器发送数据</strong></p>
<p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerTCP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端启动 , 等待连接 .... &quot;</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">server</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">      	<span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      	<span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        <span class="comment">//5.关闭资源.</span></span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTCP</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;客户端 发送数据&quot;</span>);</span><br><span class="line">		<span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">		<span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">		<span class="comment">// 2.获取流对象 . 输出流</span></span><br><span class="line">		<span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line">		<span class="comment">// 3.写出数据.</span></span><br><span class="line">		os.write(<span class="string">&quot;你好么? tcp ,我来了&quot;</span>.getBytes());</span><br><span class="line">		<span class="comment">// 4. 关闭资源 .</span></span><br><span class="line">		os.close();</span><br><span class="line">		client.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>服务器向客户端回写数据</strong></p>
<p><strong>服务端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerTCP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端启动 , 等待连接 .... &quot;</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">server</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">      	<span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      	<span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">      	<span class="comment">// =================回写数据=======================</span></span><br><span class="line">      	<span class="comment">// 5. 通过 socket 获取输出流</span></span><br><span class="line">      	 <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> server.getOutputStream();</span><br><span class="line">      	<span class="comment">// 6. 回写数据</span></span><br><span class="line">      	 out.write(<span class="string">&quot;我很好,谢谢你&quot;</span>.getBytes());</span><br><span class="line">      	<span class="comment">// 7.关闭资源.</span></span><br><span class="line">      	out.close();</span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>客户端实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTCP</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;客户端 发送数据&quot;</span>);</span><br><span class="line">		<span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line">		<span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">		<span class="comment">// 2.通过Scoket,获取输出流对象 </span></span><br><span class="line">		<span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line">		<span class="comment">// 3.写出数据.</span></span><br><span class="line">		os.write(<span class="string">&quot;你好么? tcp ,我来了&quot;</span>.getBytes());</span><br><span class="line">      	<span class="comment">// ==============解析回写=========================</span></span><br><span class="line">      	<span class="comment">// 4. 通过Scoket,获取 输入流对象</span></span><br><span class="line">      	<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> client.getInputStream();</span><br><span class="line">      	<span class="comment">// 5. 读取数据数据</span></span><br><span class="line">      	<span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span>];</span><br><span class="line">      	<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> in.read(b);</span><br><span class="line">      	System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len));</span><br><span class="line">		<span class="comment">// 6. 关闭资源 .</span></span><br><span class="line">      	in.close();</span><br><span class="line">		os.close();</span><br><span class="line">		client.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://dengliantong.cn">Xing Deng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://dengliantong.cn/2023/09/20/Java%E5%9F%BA%E7%A1%80/">http://dengliantong.cn/2023/09/20/Java%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://dengliantong.cn" target="_blank">互联网新贵邓醒</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://images3.alphacoders.com/103/103237.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/20/JavaWeb/" title="JavaWeb"><img class="cover" src="/img/loading.gif" data-original="https://images.alphacoders.com/484/484614.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JavaWeb</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/19/SSM%E6%A1%86%E6%9E%B6/" title="SSM框架"><img class="cover" src="/img/loading.gif" data-original="https://images.alphacoders.com/484/484614.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SSM框架</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xing Deng</div><div class="author-info__description">起风了,唯有努力生存!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/waFroppy"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome To My Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-text">常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-text">类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-text">方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">流程控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-text">类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-text">对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81"><span class="toc-text">静态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-text">String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super"><span class="toc-text">super</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this"><span class="toc-text">this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final"><span class="toc-text">final</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90"><span class="toc-text">权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-text">集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">Iterator迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BAfor"><span class="toc-text">增强for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-text">List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set"><span class="toc-text">Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collections"><span class="toc-text">Collections**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-text">Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashMap"><span class="toc-text">LinkedHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%B7%A5%E5%8E%82"><span class="toc-text">集合工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-text">异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-text">自定义异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-text">线程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">Lambda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">函数式接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream%E6%B5%81"><span class="toc-text">Stream流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-text">反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File"><span class="toc-text">File</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-text">递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-text">IO流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Properties"><span class="toc-text">Properties</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-text">缓冲流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-text">转换流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E6%B5%81"><span class="toc-text">序列流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-text">打印流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">网络编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP"><span class="toc-text">TCP</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/09/20/JavaWeb/" title="JavaWeb"><img src="/img/loading.gif" data-original="https://images.alphacoders.com/484/484614.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaWeb"/></a><div class="content"><a class="title" href="/2023/09/20/JavaWeb/" title="JavaWeb">JavaWeb</a><time datetime="2023-09-20T01:39:10.000Z" title="发表于 2023-09-20 09:39:10">2023-09-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/20/Java%E5%9F%BA%E7%A1%80/" title="Java基础"><img src="/img/loading.gif" data-original="https://images3.alphacoders.com/103/103237.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础"/></a><div class="content"><a class="title" href="/2023/09/20/Java%E5%9F%BA%E7%A1%80/" title="Java基础">Java基础</a><time datetime="2023-09-20T01:38:45.000Z" title="发表于 2023-09-20 09:38:45">2023-09-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/19/SSM%E6%A1%86%E6%9E%B6/" title="SSM框架"><img src="/img/loading.gif" data-original="https://images.alphacoders.com/484/484614.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SSM框架"/></a><div class="content"><a class="title" href="/2023/09/19/SSM%E6%A1%86%E6%9E%B6/" title="SSM框架">SSM框架</a><time datetime="2023-09-19T07:55:40.000Z" title="发表于 2023-09-19 15:55:40">2023-09-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/12/Oracle-EBS-R12-%E9%87%87%E8%B4%AD%E5%88%B0%E5%BA%94%E4%BB%98%E4%BA%A7%E7%94%9F%E7%9A%84%E4%BC%9A%E8%AE%A1%E5%88%86%E5%BD%95/" title="Oracle EBS R12 采购到应付产生的会计分录"><img src="/img/loading.gif" data-original="https://images6.alphacoders.com/337/337255.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Oracle EBS R12 采购到应付产生的会计分录"/></a><div class="content"><a class="title" href="/2023/06/12/Oracle-EBS-R12-%E9%87%87%E8%B4%AD%E5%88%B0%E5%BA%94%E4%BB%98%E4%BA%A7%E7%94%9F%E7%9A%84%E4%BC%9A%E8%AE%A1%E5%88%86%E5%BD%95/" title="Oracle EBS R12 采购到应付产生的会计分录">Oracle EBS R12 采购到应付产生的会计分录</a><time datetime="2023-06-12T00:58:47.000Z" title="发表于 2023-06-12 08:58:47">2023-06-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/10/Oracle-EBS-R12-%E6%8E%A5%E5%8F%A3%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/" title="Oracle EBS R12 接口参考文档"><img src="/img/loading.gif" data-original="https://images.alphacoders.com/484/484614.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Oracle EBS R12 接口参考文档"/></a><div class="content"><a class="title" href="/2023/06/10/Oracle-EBS-R12-%E6%8E%A5%E5%8F%A3%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/" title="Oracle EBS R12 接口参考文档">Oracle EBS R12 接口参考文档</a><time datetime="2023-06-10T02:53:52.000Z" title="发表于 2023-06-10 10:53:52">2023-06-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://images3.alphacoders.com/103/103237.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Xing Deng</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>