<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>SSM框架 | 互联网新贵邓醒</title><meta name="author" content="Xing Deng"><meta name="copyright" content="Xing Deng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SSM框架SSM框架是指Spring+SpringMVC+MyBatis的组合，它是Java Web开发中常用的一套开发框架。  Spring是一个应用开发框架，它提供了一系列的模块和类库，用于简化Java应用的开发。它提供了控制反转（IoC）和面向切面编程（AOP）等功能。   SpringMVC是基于Spring框架的一个MVC（Model-View-Controller）框架，它通过将请求分">
<meta property="og:type" content="article">
<meta property="og:title" content="SSM框架">
<meta property="og:url" content="http://dengliantong.cn/2023/09/19/SSM%E6%A1%86%E6%9E%B6/index.html">
<meta property="og:site_name" content="互联网新贵邓醒">
<meta property="og:description" content="SSM框架SSM框架是指Spring+SpringMVC+MyBatis的组合，它是Java Web开发中常用的一套开发框架。  Spring是一个应用开发框架，它提供了一系列的模块和类库，用于简化Java应用的开发。它提供了控制反转（IoC）和面向切面编程（AOP）等功能。   SpringMVC是基于Spring框架的一个MVC（Model-View-Controller）框架，它通过将请求分">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images3.alphacoders.com/103/103237.jpg">
<meta property="article:published_time" content="2023-09-19T07:55:40.000Z">
<meta property="article:modified_time" content="2023-10-17T11:50:22.254Z">
<meta property="article:author" content="Xing Deng">
<meta property="article:tag" content="SSM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images3.alphacoders.com/103/103237.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://dengliantong.cn/2023/09/19/SSM%E6%A1%86%E6%9E%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SSM框架',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-17 19:50:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://images3.alphacoders.com/103/103237.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="互联网新贵邓醒"><span class="site-name">互联网新贵邓醒</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SSM框架</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-19T07:55:40.000Z" title="发表于 2023-09-19 15:55:40">2023-09-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-17T11:50:22.254Z" title="更新于 2023-10-17 19:50:22">2023-10-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">19.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>71分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="SSM框架"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="SSM框架"><a href="#SSM框架" class="headerlink" title="SSM框架"></a>SSM框架</h3><p>SSM框架是指Spring+SpringMVC+MyBatis的组合，它是Java Web开发中常用的一套开发框架。</p>
<ul>
<li>Spring是一个应用开发框架，它提供了一系列的模块和类库，用于简化Java应用的开发。它提供了控制反转（IoC）和面向切面编程（AOP）等功能。</li>
</ul>
<ul>
<li>SpringMVC是基于Spring框架的一个MVC（Model-View-Controller）框架，它通过将请求分发给对应的控制器，然后生成相应的视图来实现Web应用的开发。</li>
</ul>
<ul>
<li>MyBatis是一个持久层框架，它提供了数据库操作的SQL映射关系管理，并且能够将结果映射为Java对象。</li>
</ul>
<p>SSM框架的优点在于：</p>
<ol>
<li>简化开发：使用SSM框架可以减少很多传统Java Web开发中的繁琐工作，提高开发效率。</li>
<li>轻量级：SSM框架相较于其他框架来说，比较精简，占用资源较少。</li>
<li>统一标准：SSM框架提供了一套统一的开发标准，能够帮助开发团队协作开发。</li>
<li>易于扩展：SSM框架的各个组件都可以自由扩展，方便根据实际需求进行定制开发。</li>
</ol>
<p>总结来说，SSM框架结合了Spring的依赖注入、控制反转等优点，SpringMVC的Web开发模式以及MyBatis的持久化操作，使得Java Web开发更加简便、高效。</p>
<ul>
<li><p>Spring框架</p>
<p>指 <code>Spring Framework</code>，是整个Spring生态的核心，提供了一个IoC容器，用于管理对象的生命周期和依赖关系。</p>
</li>
<li><p>Spring MVC框架</p>
<p>SpringMVC是基于Spring框架的MVC（Model-View-Controller，模型-视图-控制器）架构的Web框架，用于快速开发Web应用程序。</p>
</li>
<li><p>MyBatis框架</p>
<p>MyBatis是一个开源的持久层框架，它提供了一种将Java对象与关系型数据库之间进行映射的方式，MyBatis通过配置文件或注解来定义SQL映射。    </p>
</li>
</ul>
<p>仓库地址:<a target="_blank" rel="noopener" href="https://gitee.com/teduwang/jsd2306-ssm-teacher.git">https://gitee.com/teduwang/jsd2306-ssm-teacher.git</a></p>
<p><strong>SSM框架注解</strong></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309191556549.png" alt="SSM"></p>
<ul>
<li><p>三大框架注解</p>
<p>Spring + Spring MVC + MyBatis</p>
</li>
<li><p>其他框架注解</p>
<ul>
<li>Spring Boot</li>
<li>Lombok</li>
<li>Knife4j</li>
<li>Spring Validation</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>注解</th>
<th>所属框架</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td><code>@Component</code></td>
<td>Spring</td>
<td>添加在类上，标记当前类是组件类，可以通过参数配置Spring Bean名称</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><code>@Controller</code></td>
<td>Spring</td>
<td>添加在类上，标记当前类是控制器组件类，用法同<code>@Component</code></td>
</tr>
<tr>
<td><strong>3</strong></td>
<td><code>@Service</code></td>
<td>Spring</td>
<td>添加在类上，标记当前类是业务逻辑组件类，用法同<code>@Component</code></td>
</tr>
<tr>
<td><strong>4</strong></td>
<td><code>@Repository</code></td>
<td>Spring</td>
<td>添加在类上，标记当前类是数据访问组件类，用法同<code>@Component</code></td>
</tr>
<tr>
<td><strong>5</strong></td>
<td><code>@Configuration</code></td>
<td>Spring</td>
<td>添加在类上，仅添加此注解的类才被视为配置类，通常不配置注解参数</td>
</tr>
<tr>
<td><strong>6</strong></td>
<td><code>@ComponentScan</code></td>
<td>Spring</td>
<td>添加在配置类上，开启组件扫描。<br />如果没有配置包名，则扫描当前配置类所在的包，<br />如果配置了包名，则扫描所配置的包及其子孙包</td>
</tr>
<tr>
<td><strong>7</strong></td>
<td><code>@Value</code></td>
<td>Spring</td>
<td>添加在属性上，或添加在被Spring调用的方法的参数上，用于读取<code>Environment</code>中的属性值，为对象的属性或方法的参数注入值</td>
</tr>
<tr>
<td><strong>8</strong></td>
<td><code>@Autowired</code></td>
<td>Spring</td>
<td>添加在属性上，使得Spring自动装配此属性的值<br />添加在构造方法上，使得Spring自动调用此构造方法<br />添加在Setter方法上，使得Spring自动调用此方法</td>
</tr>
<tr>
<td><strong>9</strong></td>
<td><code>@Qualifier</code></td>
<td>Spring</td>
<td>添加在属性上，或添加在方法的参数上，<br />配合自动装配机制，用于指定需要装配的Spring Bean的名称</td>
</tr>
<tr>
<td><strong>10</strong></td>
<td><code>@Resource</code></td>
<td>Spring</td>
<td>此注解是<code>javax</code>包中的注解，<br />添加在属性上，使得Spring自动装配此属性的值，<br />通常不推荐使用此注解</td>
</tr>
<tr>
<td><strong>11</strong></td>
<td><code>@Scope</code></td>
<td>Spring</td>
<td>添加在组件类上，或添加在已经添加了<code>@Bean</code>注解的方法上，<br />用于指定作用域，注解参数为<code>singleton</code>（默认）时为“单例”，注解参数为<code>prototype</code>时为“非单例”</td>
</tr>
<tr>
<td><strong>12</strong></td>
<td><code>@Mapper</code></td>
<td>Mybatis</td>
<td>添加在Mapper接口上，用于标记此接口是Mybatis的Mapper接口</td>
</tr>
<tr>
<td><strong>13</strong></td>
<td><code>@MapperScan</code></td>
<td>Mybatis</td>
<td>添加在配置类上，用于指定Mapper接口的根包，Mybatis将根据此根包执行扫描，以找到各Mapper接口</td>
</tr>
<tr>
<td><strong>14</strong></td>
<td><code>@Select</code></td>
<td>Mybatis</td>
<td>添加在Mapper接口的抽象方法上，可以通过此注解直接配置此抽象方法对应的SQL语句（不必将SQL语句配置在XML文件中），用于配置<code>SELECT</code>类的SQL语句，但是，非常不推荐这种做法</td>
</tr>
<tr>
<td><strong>15</strong></td>
<td><code>@Insert</code></td>
<td>Mybatis</td>
<td>同上，用于配置<code>INSERT</code>类的SQL语句</td>
</tr>
<tr>
<td><strong>16</strong></td>
<td><code>@Update</code></td>
<td>Mybatis</td>
<td>同上，用于配置<code>UPDATE</code>类的SQL语句</td>
</tr>
<tr>
<td><strong>17</strong></td>
<td><code>@Delete</code></td>
<td>Mybatis</td>
<td>同上，用于配置<code>DELETE</code>类的SQL语句</td>
</tr>
<tr>
<td><strong>18</strong></td>
<td><code>@SpringBootApplication</code></td>
<td>Spring Boot</td>
<td>添加在类上，用于标记此类是Spring Boot的启动类，每个Spring Boot项目应该只有1个类添加了此注解</td>
</tr>
<tr>
<td><strong>19</strong></td>
<td><code>@SpringBootTest</code></td>
<td>Spring Boot</td>
<td>添加在类上，用于标记此类是加载Spring环境的测试类</td>
</tr>
<tr>
<td><strong>20</strong></td>
<td>@Test</td>
<td>Spring Boot</td>
<td>添加在方法上，用于标记此方法是Spring环境的测试方法</td>
</tr>
<tr>
<td><strong>21</strong></td>
<td><code>@RequestMapping</code></td>
<td>Spring MVC</td>
<td>添加在类上，也可以添加在处理请求的方法上，<br />通常用于配置请求路径</td>
</tr>
<tr>
<td><strong>22</strong></td>
<td><code>@ResponseBody</code></td>
<td>Spring MVC</td>
<td>添加在方法上，标记此方法是“响应正文”的，<br />添加在类上，标记此类中所有方法都是“响应正文”的</td>
</tr>
<tr>
<td><strong>23</strong></td>
<td><code>@RestController</code></td>
<td>Spring MVC</td>
<td>添加在类上，标记此类是一个“响应正文”的控制器类</td>
</tr>
<tr>
<td><strong>24</strong></td>
<td><code>@GetMapping</code></td>
<td>Spring MVC</td>
<td>添加在方法上，是将请求方式限制为<code>GET</code>的<code>@RequestMapping</code></td>
</tr>
<tr>
<td><strong>25</strong></td>
<td><code>@PostMapping</code></td>
<td>Spring MVC</td>
<td>添加在方法上，是将请求方式限制为<code>POST</code>的<code>@RequestMapping</code></td>
</tr>
<tr>
<td><strong>26</strong></td>
<td><code>@DeleteMapping</code></td>
<td>Spring MVC</td>
<td>添加在方法上，是将请求方式限制为<code>DELETE</code>的<code>@RequestMapping</code></td>
</tr>
<tr>
<td><strong>27</strong></td>
<td><code>@PutMapping</code></td>
<td>Spring MVC</td>
<td>添加在方法上，是将请求方式限制为<code>PUT</code>的<code>@RequestMapping</code></td>
</tr>
<tr>
<td><strong>28</strong></td>
<td><code>@PathVariable</code></td>
<td>Spring MVC</td>
<td>添加在请求参数上，用于标记此参数的值来自URL中的占位符，如果URL中的占位符名称与方法的参数名称不同，需要配置此注解参数来指定URL中的占位符名称</td>
</tr>
<tr>
<td><strong>29</strong></td>
<td><code>@RequestBody</code></td>
<td>Spring MVC</td>
<td>添加在请求参数上，用于标记此参数必须是对象格式的参数，如果未添加此注解，参数必须是FormData格式的</td>
</tr>
<tr>
<td><strong>30</strong></td>
<td><code>@ExceptionHandler</code></td>
<td>Spring MVC</td>
<td>添加在方法上，标记此方法是处理异常的方法，可以通过配置注解参数来指定需要处理的异常类型，如果没有配置注解参数，所处理的异常类型取决于方法的参数列表中的异常类型</td>
</tr>
<tr>
<td><strong>31</strong></td>
<td><code>@ControllerAdvice</code></td>
<td>Spring MVC</td>
<td>添加在类上，标记此类中特定的方法将作用于每次处理请求的过程中</td>
</tr>
<tr>
<td><strong>32</strong></td>
<td><code>@RestControllerAdvice</code></td>
<td>Spring MVC</td>
<td>添加在类上，是<code>@ControllerAdvice</code>和<code>@ResponseBody</code>的组合注解</td>
</tr>
<tr>
<td><strong>33</strong></td>
<td><code>@Data</code></td>
<td>Lombok</td>
<td>添加在类上，将在编译期生成此类中所有属性的Setter、Getter方法，及<code>hashCode()</code>、<code>equals()</code>、<code>toString()</code>方法</td>
</tr>
<tr>
<td><strong>34</strong></td>
<td><code>@Setter</code></td>
<td>Lombok</td>
<td>添加在类上，将在编译期生成此类中所有属性的Setter方法，也可以添加在类的属性上，将在编译期生成此属性的Setter方法</td>
</tr>
<tr>
<td><strong>35</strong></td>
<td><code>@Getter</code></td>
<td>Lombok</td>
<td>添加在类上，将在编译期生成此类中所有属性的Getter方法，也可以添加在类的属性上，将在编译期生成此属性的Getter方法</td>
</tr>
<tr>
<td><strong>36</strong></td>
<td><code>@ToString</code></td>
<td>Lombok</td>
<td>添加在类上，将在编译期生成基于此类中所有属性的<code>toString()</code>方法</td>
</tr>
<tr>
<td><strong>37</strong></td>
<td><code>@NoArgConstructor</code></td>
<td>Lombok</td>
<td>添加在类上，将在编译期生成此类的无参数构造方法</td>
</tr>
<tr>
<td><strong>38</strong></td>
<td><code>@AllArgsConstructor</code></td>
<td>Lombok</td>
<td>添加在类上，将在编译期生成基于此类中所有属性的全参构造方法</td>
</tr>
<tr>
<td><strong>39</strong></td>
<td><code>@Api</code></td>
<td>Knife4j</td>
<td>添加在控制器类上，通过此注解的<code>tags</code>属性配置API文档中的模块名称</td>
</tr>
<tr>
<td><strong>40</strong></td>
<td><code>@ApiOperation</code></td>
<td>Knife4j</td>
<td>添加在控制器类中处理请求的方法上，用于配置业务名称</td>
</tr>
<tr>
<td><strong>41</strong></td>
<td><code>@ApiModelProperty</code></td>
<td>Knife4j</td>
<td>添加在封装的请求参数类型中的属性上，用于配置请求参数的详细说明，包括：名称、数据类型、是否必须等</td>
</tr>
<tr>
<td><strong>42</strong></td>
<td><code>@ApiImplicitParam</code></td>
<td>Knife4j</td>
<td>添加在控制器类中处理请求的方法上，用于配置请求参数的详细说明，包括：名称、数据类型、是否必须等</td>
</tr>
<tr>
<td><strong>43</strong></td>
<td><code>@ApiImplicitParams</code></td>
<td>Knife4j</td>
<td>添加在控制器类中处理请求的方法上，如果需要通过<code>@ApiImplicitParam</code>注解配置的参数超过1个，则必须将多个<code>@ApiImplicitParam</code>注解作为此注解的参数</td>
</tr>
<tr>
<td><strong>44</strong></td>
<td><code>@ApiIgnore</code></td>
<td>Knife4j</td>
<td>添加在请求参数上，用于标记API文档中将不关心此参数</td>
</tr>
<tr>
<td><strong>45</strong></td>
<td><code>@Valid</code></td>
<td>Spring Validation</td>
<td>添加在方法的参数上，标记此参数需要经过Validation框架的检查</td>
</tr>
<tr>
<td><strong>46</strong></td>
<td><code>@Validated</code></td>
<td>Spring Validation</td>
<td>添加在方法的参数上，标记此参数需要经过Validation框架的检查；添加在类上，并结合方法上的检查注解（例如<code>@NotNull</code>等）实现对未封装的参数的检查</td>
</tr>
<tr>
<td><strong>47</strong></td>
<td><code>@NotNull</code></td>
<td>Spring Validation</td>
<td>添加在需要被检查的参数上，或添加在需要被检查的封装类型的属性上，用于配置“不允许为<code>null</code>”的检查规则</td>
</tr>
<tr>
<td><strong>48</strong></td>
<td><code>@NotEmpty</code></td>
<td>Spring Validation</td>
<td>使用位置同<code>@NotNull</code>，用于配置“不允许为空字符串”的检查规则</td>
</tr>
<tr>
<td><strong>49</strong></td>
<td><code>@NotBlank</code></td>
<td>Spring Validation</td>
<td>使用位置同<code>@NotNull</code>，用于配置“不允许为空白”的检查规则</td>
</tr>
<tr>
<td><strong>50</strong></td>
<td><code>@Pattern</code></td>
<td>Spring Validation</td>
<td>使用位置同<code>@NotNull</code>，用于配置正则表达式的检查规则</td>
</tr>
<tr>
<td><strong>51</strong></td>
<td><code>@Range</code></td>
<td>Spring Validation</td>
<td>使用位置同<code>@NotNull</code>，用于配置“数值必须在某个取值区间”的检查规则</td>
</tr>
</tbody></table>
<p><strong>基于SpringBoot的SSM框架依赖</strong></p>
<p><strong>勾选依赖项</strong></p>
<p><strong>1 Spring MVC依赖</strong></p>
<p><font color=red><strong>SpringBoot构建工程时：勾选 Spring Web 项</strong></font></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Spring MVC依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2 MyBatis依赖</strong></p>
<p><font color=red><strong>SpringBoot构建工程时：勾选 MyBatis Framework 项</strong></font></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--MyBatis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>3 MySQL依赖</strong></p>
<p><font color=red><strong>SpringBoot构建工程时，勾选 MySQL Driver 项</strong></font></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--MySQL依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>4 Lombok依赖</strong></p>
<p><font color=red><strong>SpringBoot构建工程时，勾选 Lombok 项</strong></font></p>
<p><font color=blue><strong>需要注意：确认是否安装了Lombok的插件，在 File - Settings - Plugins 中确认</strong></font></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Lombok依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>5 Spring Validation依赖</strong></p>
<p><font color=red><strong>SpringBoot构建工程时，勾选 Validation 项</strong></font></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Validation依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>手动添加依赖项</strong></p>
<p><strong>1 Knife4j依赖</strong></p>
<p><font color=blue><strong>SpringBoot构建工程时，无法勾选，需要手动添加该项依赖</strong></font></p>
<p><font color=blue><strong>注意：添加完依赖之后，需要先创建Knife4j的配置文件后再使用</strong></font></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加Knife4j依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-openapi2-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>默认添加依赖项</strong></p>
<p><strong>1 SpringBoot测试依赖</strong></p>
<p><font color=red><strong>SpringBoot构建工程时，无须勾选，默认会自动添加</strong></font></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringBoot测试组件依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><p>Spring Boot是一个Java软件开发框架（Spring 脚手架） 简化项目的初始搭建以及开发过程</p>
<p>SpringBoot核心特性<br>起步依赖<br>创建项目时，会默认添加基础依赖，简化我们自己查找依赖的过程。<br>嵌入式服务(Tomcat)<br>SpringBoot工程支持内嵌的web服务，可以将tomcat这样的服务直接嵌套到web依赖中。</p>
<p>创建SpringBoot工程</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309111909099.png" alt="image-20230911190936021"></p>
<p>添加相关依赖</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309191556165.png" alt="image-20230911191013223"></p>
<p>Spring Boot  指定版本为 <strong>2.7.15</strong></p>
<p>SpringBoot项目目录结构</p>
<p>Application  为引导类 </p>
<p> <img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309191556960.png" alt="image-20230911192935436"></p>
<p>@SpringBootApplication 组合注解包含了以下三个重要注解</p>
<ul>
<li>@EnableAutoConfiguration：开启自动配置</li>
<li>@ComponentScan：开启注解扫描</li>
<li>@SpringBootConfiguration</li>
</ul>
<p>使用SpringBoot构建一个项目，只需要引入所需依赖，配置就可以交给SpringBoot处理了</p>
<p>创建包需要在引导类的同级目录下或者子目录下 否则会报错 </p>
<p>Application.properties  为配置文件</p>
<p>SpringBoot为我们提供了默认配置，而默认配置生效的条件一般有两个：</p>
<ul>
<li>你引入了相关依赖</li>
<li>你自己没有配置</li>
</ul>
<p>1）启动器</p>
<p>我们如果不想配置，只需要引入依赖即可，而依赖版本我们也不用操心，因为只要引入了SpringBoot提供的stater（启动器），就会自动管理依赖及版本了。</p>
<p>因此SpringBoot的第一件事情，就是找启动器，SpringBoot提供了大量的默认启动器</p>
<p>2）全局配置</p>
<p>另外，SpringBoot的默认配置，都会读取默认属性，而这些属性可以通过自定义<code>application.properties</code>文件来进行覆盖。这样虽然使用的还是默认配置，但是配置中的值改成了我们自定义的。</p>
<p>因此，玩SpringBoot的第二件事情，就是通过<code>application.properties</code>来覆盖默认属性值，形成自定义配置。我们需要知道SpringBoot的默认属性key</p>
<p><strong>Spring Boot 常见配置:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改端口:# 映射端口 </span><br><span class="line">server.port=80</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/blog?serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line"></span><br><span class="line">#jdbc自带的hikari连接池</span><br><span class="line">spring.datasource.hikari.idle-timeout=60000</span><br><span class="line">spring.datasource.hikari.maximum-pool-size=30</span><br><span class="line">spring.datasource.hikari.minimum-idle=10</span><br><span class="line"></span><br><span class="line">#druid连接池</span><br><span class="line">#初始化连接数</span><br><span class="line">spring.datasource.druid.initial-size=1</span><br><span class="line">#最小空闲连接</span><br><span class="line">spring.datasource.druid.min-idle=1</span><br><span class="line">#最大活动连接</span><br><span class="line">spring.datasource.druid.max-active=20</span><br><span class="line">#获取连接时测试是否可用</span><br><span class="line">spring.datasource.druid.test-on-borrow=true</span><br><span class="line">#监控页面启动</span><br><span class="line">spring.datasource.druid.stat-view-servlet.allow=true</span><br><span class="line"></span><br><span class="line"># mybatis 别名扫描  批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以）</span><br><span class="line">mybatis.type-aliases-package=cn.deng.mapper</span><br><span class="line"># 设置MyBatis框架的映射（Mapper）配置文件的位置</span><br><span class="line">mybatis.mapper-locations=classpath:mappers/*.xml</span><br><span class="line"></span><br><span class="line"># 设置org.springframework包的日志级别为debug  </span><br><span class="line">logging.level.org.springframework=debug</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>SpringBoot整合SpringMVC添加拦截器</strong>  </p>
<p>通过实现<code>WebMvcConfigurer</code>并添加<code>@Configuration</code>注解来实现自定义部分SpringMvc配置。</p>
<p>定义拦截器:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;preHandle method is running!&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;postHandle method is running!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;afterCompletion method is running!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>定义配置类,注册拦截器:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MvcConfiguration implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private HandlerInterceptor myInterceptor;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重写接口中的addInterceptors方法，添加自定义拦截器</span><br><span class="line">     * @param registry</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        registry.addInterceptor(myInterceptor).addPathPatterns(&quot;/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SpringBoot 整合连接池:</strong></p>
<p>引入JDBC启动器</p>
<!--jdbc的启动器，默认使用HikariCP连接池-->

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>

<p>引入Druid连接池启动器</p>
<!-- Druid连接池 -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
    <version>1.1.6</version>
</dependency>

<p><strong>Spring Boot 控制数据库事务</strong></p>
<p>@Transactional</p>
<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>IOC  控制反转 </p>
<p>方便解耦，简化开发<br>通过 Spring提供的 IoC容器，可以将对象间的依赖关系交由 Spring进行控制，避免硬编码所造<br>成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可<br>以更专注于上层的应用。</p>
<p>DI    依赖注入 它是 spring 框架核心 ioc 的具体实现</p>
<p>比如框架把持久层对象传入业务层，而不用我们自己去获取</p>
<p>Spring bean 对象</p>
<p> AOP面向切面编程</p>
<p>  Aspect Oriented Programming 的简写，为 面向切面编程。AOP用来封装多个类的公共行为，将那些与业务无关，却为业务模块共同调用的逻辑封装起来，减少系统的重复代码。</p>
<p>xml配置文件:</p>
<?xml version="1.0" encoding="UTF-8"?>
<p><beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd"><br></beans></p>
<!-- bean 标签：用于配置让 spring 创建对象，并且存入 ioc 容器之中
id 属性：对象的唯一标识。
class 属性：指定要创建对象的全限定类名
-->

<!-- 配置 dao -->
<p><bean id="accountDao" class="com.deng.dao.impl.AccountDaoImpl"></bean></p>
<p><strong>包路径快捷键</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows:  Ctrl + Shift + Alt + c</span><br></pre></td></tr></table></figure>

<p><strong>Bean 的 生命周期</strong></p>
<ul>
<li><p>实例化</p>
<p>给当前Bean对象去分配资源，通过无参构造方法实现；</p>
</li>
<li><p>属性赋值</p>
<p>依赖注入，通过set方法；</p>
</li>
<li><p>初始化</p>
<p>通过 <code>@PostConstruct</code> 注解进行一些初始化的操作，比如连接数据库，打开文件……</p>
</li>
<li><p>使用阶段</p>
</li>
<li><p>销毁</p>
<p>通过 <code>@PreDestroy</code> 注解进行一些资源的释放的操作，比如断开数据库连接，关闭文件……</p>
</li>
</ul>
<p><strong>SpringBean对象属性值的三种注入方法:</strong></p>
<p><strong>构造函数注入</strong></p>
<!-- 使用构造函数的方式，给 service 中的属性传值
要求：
类中需要提供一个对应参数列表的构造函数。
涉及的标签：
constructor-arg
属性：
index:指定参数在构造函数参数列表的索引位置
type:指定参数在构造函数中的数据类型

name:指定参数在构造函数中的名称 用这个找给谁赋值
=======上面三个都是找给谁赋值，下面两个指的是赋什么值的==============
value:它能赋的值是基本数据类型和 String 类型
ref:它能赋的值是其他 bean 类型，也就是说，必须得是在配置文件中配置过的 bean
-->

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;accountService&quot; class=&quot;com.deng.service.impl.AccountServiceImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;name&quot; value=&quot; 张三 &quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p><strong>set 方法注入</strong></p>
<!-- 通过配置文件给 bean 中的属性传值：使用 set 方法的方式
涉及的标签：
property属性：
name：找的是类中 set 方法后面的部分
ref：给属性赋值是其他 bean 类型的
value：给属性赋值是基本数据类型和 string 类型的
实际开发中，此种方式用的较多。
-->

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;accountService&quot; class=&quot;com.deng.service.impl.AccountServiceImpl&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;test&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p><strong>p 名称空间注入数据（本质还是调用 set 方法）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line"></span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">&lt;bean id=&quot;accountService&quot;</span><br><span class="line">class=&quot;com.deng.service.impl.AccountServiceImpl4&quot;</span><br><span class="line">p:name=&quot;test&quot; p:age=&quot;21&quot; p:birthday-ref=&quot;now&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p><strong>集合注入</strong></p>
<p>顾名思义，就是给类中的集合成员传值，它用的也是set方法注入的方式，只不过变量的数据类型都是集合。<br>我们这里介绍注入数组，List,Set,Map,Properties。</p>
<!-- 注入集合数据
List 结构的：
array,list,set
Map 结构的
map,entry,props,prop
-->

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;</span><br><span class="line">&lt;!-- 在注入集合数据时，只要结构相同，标签可以互换 --&gt;</span><br><span class="line">&lt;!-- 给数组注入数据 --&gt;</span><br><span class="line">&lt;property name=&quot;myStrs&quot;&gt;</span><br><span class="line">&lt;set&gt;</span><br><span class="line">&lt;value&gt;AAA&lt;/value&gt;</span><br><span class="line">&lt;value&gt;BBB&lt;/value&gt;</span><br><span class="line">&lt;value&gt;CCC&lt;/value&gt;</span><br><span class="line">&lt;/set&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!-- 注入 list 集合数据 --&gt;</span><br><span class="line">&lt;property name=&quot;myList&quot;&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">&lt;value&gt;AAA&lt;/value&gt;</span><br><span class="line">&lt;value&gt;BBB&lt;/value&gt;</span><br><span class="line">&lt;value&gt;CCC&lt;/value&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!-- 注入 set 集合数据 --&gt;</span><br><span class="line">&lt;property name=&quot;mySet&quot;&gt;</span><br><span class="line">&lt;list&gt;</span><br><span class="line">&lt;value&gt;AAA&lt;/value&gt;</span><br><span class="line">&lt;value&gt;BBB&lt;/value&gt;</span><br><span class="line">&lt;value&gt;CCC&lt;/value&gt;</span><br><span class="line">&lt;/list&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!-- 注入 Map 数据 --&gt;</span><br><span class="line">&lt;property name=&quot;myMap&quot;&gt;</span><br><span class="line">&lt;props&gt;</span><br><span class="line">&lt;prop key=&quot;testA&quot;&gt;aaa&lt;/prop&gt;</span><br><span class="line">&lt;prop key=&quot;testB&quot;&gt;bbb&lt;/prop&gt;</span><br><span class="line">&lt;/props&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!-- 注入 properties 数据 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;property name=&quot;myProps&quot;&gt;&lt;map&gt;</span><br><span class="line">&lt;entry key=&quot;testA&quot; value=&quot;aaa&quot;&gt;&lt;/entry&gt;</span><br><span class="line">&lt;entry key=&quot;testB&quot;&gt;</span><br><span class="line">&lt;value&gt;bbb&lt;/value&gt;</span><br><span class="line">&lt;/entry&gt;</span><br><span class="line">&lt;/map&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>



<p><strong>基于XML配置获取Springbean 对象</strong></p>
<p>//1.使用 ApplicationContext 接口，就是在获取 spring 容器<br>ApplicationContext ac = new ClassPathXmlApplicationContext(“bean.xml”);<br>//2.根据 bean 的 id 获取对象<br>IAccountService aService = (IAccountDao) ac.getBean(“accountDao”);</p>
<p><strong>基于注解方式获取Spring bean  对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(<span class="string">&quot;cn.deng.spring&quot;</span>);<span class="comment">//获取IOC容器</span></span><br><span class="line"><span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> context.getBean(UserDao.class);<span class="comment">//获取Bean对象</span></span><br></pre></td></tr></table></figure>

<p><strong>基于注解的 IOC 配置</strong></p>
<p>xml配置文件中告知spring 创建容器时要扫描的包</p>
<p>&lt;context:component-scan base-package=”cn.deng”&gt;</context:component-scan></p>
<p><strong>注解方式:</strong></p>
<p>@Component(value=””)   相当于：<bean id="" class=""></p>
<p> value：指定 bean 的 id。如果不指定 value 属性，默认 bean 的 id 是当前类的类名。首字母小写。<br>    @Repository   Dao层 数据访问层<br>    @Service        Service层   业务层</p>
<p>​    @Controller    Controller层  控制层</p>
<p>@Value          将属性值(基本类型和String 类型值)直接注入到bean中       </p>
<p>@Autowired   将对象 接口注入到bean 中<br>当接口只有唯一一个实现类的时候 spring会通过接口找到该实现类 并创建bean对象以及DI注入操作<br>当接口有多个实现类的时候 spring无法确定注入哪个实现类对象  可以使用@Qualifier 来解决</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired   </span><br><span class="line">@Qualifier()</span><br></pre></td></tr></table></figure>

<p>@Qualifier      通过 value 来确定使用哪个实现类对象</p>
<p>​    搭配@Component组件一起使用</p>
<p>@Resource    直接按照 Bean 的 id 注入。它只能注入其他 bean 类型。</p>
<p>@Scope    bean的作用域<br>    Singleton (数据库连接) Prototype(多任务)</p>
<p>@PostConstruct  Bean对象创建之后初始化 作用在方法上</p>
<p>@PreDestroy  Bean对象销毁之前关闭资源 作用在方法上</p>
<p>@PropertySource(“classpath:”) Bean对象注入外部文件</p>
<p>@ComponentScan 注解用于指定要扫描的包或类 生成SpringBean 对象</p>
<p>@Configuration    Spring配置类</p>
<p>@Bean  将方法声明为一个注册Bean的方法，Spring会自动调用该方法，将方法的返回值加入Spring容器中。相当于以前的bean标签</p>
<p>@Import  作用：<br>        用于导入其他配置类，在引入其他配置类时，可以不用再写@Configuration 注解。当然，写上也没问题。<br>        属性：<br>        value[]：用于指定其他配置类的字节码。</p>
<p><strong>Spring纯注解配置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &quot;com.deng.spring&quot;)</span><br><span class="line">@Import(&#123; JdbcConfig.class&#125;)</span><br><span class="line">public class SpringConfiguration &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br><span class="line">public class JdbcConfig&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><p>Mybatis<br>DAO 层 数据层</p>
<p>pojo   映射实体类<br>dto      客户端传给服务端数据<br>vo类   服务端返回给数据端的数据类</p>
<p><strong>@Mapper   映射数据层接口</strong><br>描述数据层的接口 为此接口创建实现类<br>@Insert  插入数据<br>根据接口方法参数类型自动的插入数据</p>
<p><strong>Mybatis 使用 XML 方式</strong></p>
<p>第1步：创建工程  springboot 工程配置mybatis相关的依赖<br>第2步：配置文件中配置数据库连接信息（application.properties）<br>spring.datasource.url=jdbc:mysql://localhost:3306/mybatisdb<br>spring.datasource.username=root<br>spring.datasource.password=root<br>第3步：配置文件中配置xml文件映射位置（application.properties）<br>mybatis.mapper-locations=classpath:mappers/*.xml<br>第4步：创建xml文件存放目录，并拷贝xml模板文件<br>mappers/<em><strong>Mapper.xml<br>第5步：创建映射接口，</strong>并添加 @Mapper 注解</em>*</p>
<p>第6步：定义接口方法，指定返回值类型[如有必要则创建VO类]<br>第7步：xml文件配置SQL</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;cn.deng.egmybatis2.mapper.CustomersMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第8步：定义测试方法进行测试（首先要进行自动装配）<br>@Autowired 自动装配<br>装配需要测试的 Mpaper 接口 </p>
<p><strong>Mybatis  XML  常用语法</strong></p>
<p>select<br>用于查询操作，包括多表查询、条件查询等。可以使用 resultType 来指定返回结果的类型。</p>
<p>查询数据库对象和POJO对象不一致情况 需要给查询的数据起别名</p>
<p>insert<br>用于插入操作，并将其自动注入实体类中。</p>
<p>update<br>用于更新操作，包括更新一条记录或者批量更新。</p>
<p>delete<br>用于删除操作，包括删除一条记录或者批量删除。</p>
<p>if、foreach、set<br>用于条件控制，可以根据不同的条件进行查询、插入、更新和删除操作。if 标签用于指定可以为空的查询条件，foreach 标签用于循环查询，set 标签用于指定更新操作的字段值。</p>
<p>sql：用于定义可重用的 SQL 片段，通常是一些较为复杂的 SQL 片段。可以在其它 SQL 语句中使用 include 标签来引用 SQL 片段。</p>
<p>include：用于引入外部的 SQL 片段。可以在 include 标签的 refid 属性中指定外部 SQL 片段的名字，然后在当前 SQL 中使用它。</p>
<p>resultType   返回类型</p>
<p><strong>动态 SQL</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;if test=&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;where&gt;&lt;where/&gt; </span><br></pre></td></tr></table></figure>

<p>搭配 include 标签使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;include refid=&quot;deleteSql&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;where&gt;&lt;if test=&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;where/&gt; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--重复SQL抽取--&gt;</span><br><span class="line">&lt;sql id=&quot;deleteSql&quot;&gt;</span><br><span class="line">    DELETE FROM blog.comment WHERE id IN</span><br><span class="line">&lt;/sql&gt;</span><br></pre></td></tr></table></figure>

<p>搭配 include 标签使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;include refid=&quot;deleteSql&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p><strong>动态删除-数组</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">    根据评论id,动态删除评论表中数据,要求参数为数组</span><br><span class="line">    DELETE FROM blog.comment WHERE id IN (2,3,5)</span><br><span class="line">    1.foreache标签: xml中的遍历标签</span><br><span class="line">    2.collection属性: 用于指定需要遍历的数据类型,array为数组,list为集合</span><br><span class="line">    3.item属性: 变量名,用于接收遍历出来的每个数据</span><br><span class="line">    4.separator属性: 用于指定多个元素之间的分隔符</span><br><span class="line">--&gt;</span><br><span class="line">&lt;delete id=&quot;deleteByIds1&quot;&gt;</span><br><span class="line">    &lt;include refid=&quot;deleteSql&quot;/&gt; (</span><br><span class="line">        &lt;foreach collection=&quot;array&quot; item=&quot;abc&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">            #&#123;abc&#125;</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    )</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure>

<p><strong>动态删除-集合</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;foreach collection=&quot;ids&quot; open=&quot;id in ( &quot; close=&quot;)&quot; item=&quot;uid&quot;</span><br><span class="line">separator=&quot;,&quot;&gt;</span><br><span class="line">			#&#123;uid&#125;</span><br><span class="line">&lt;/foreach&gt;</span><br><span class="line"></span><br><span class="line">&lt;foreach&gt;标签用于遍历集合，它的属性：</span><br><span class="line">collection:代表要遍历的集合元素，注意编写时不要写#&#123;&#125;</span><br><span class="line">open:代表语句的开始部分</span><br><span class="line">close:代表结束部分</span><br><span class="line"></span><br><span class="line">item:代表遍历集合的每个元素，生成的变量名</span><br><span class="line">sperator:代表分隔符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line"></span><br><span class="line">动态删除,集合方式,collection属性值指定为:list</span><br><span class="line"></span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;delete id=&quot;deleteByIds2&quot;&gt;</span><br><span class="line">    &lt;include refid=&quot;deleteSql&quot;/&gt; (</span><br><span class="line">    &lt;foreach collection=&quot;list&quot; item=&quot;abc&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">        #&#123;abc&#125;</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">    )</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure>

<p><strong>动态修改</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt; !--</span><br><span class="line"></span><br><span class="line">动态修改:根据评论ID修改评论的相关内容</span><br><span class="line"></span><br><span class="line">--&gt;</span><br><span class="line">&lt;update id=&quot;dynamicUpdate&quot;&gt;</span><br><span class="line">    UPDATE blog.comment</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">        &lt;if test=&quot;content!=null&quot;&gt;content=#&#123;content&#125;,&lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;created!=null&quot;&gt;created=#&#123;created&#125;,&lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;userId!=null&quot;&gt;user_id=#&#123;userId&#125;,&lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;weiboId!=null&quot;&gt;weibo_id=#&#123;weiboId&#125;&lt;/if&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">    WHERE id=#&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure>

<p><strong>多表联查一对一</strong></p>
<p>建立一个VO类 用来装两个或者多张表的参数 用啥返回啥</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectById&quot;</span> resultType=<span class="string">&quot;cn.deng._03mybatisdemo.pojo.vo.WeiboDetailVO&quot;</span>&gt;</span><br><span class="line">    SELECT w.id, w.content, w.created, u.nickname</span><br><span class="line">    FROM weibo w JOIN user u ON w.user_id=u.id</span><br><span class="line">    WHERE w.id=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p><strong>ResultMap单表</strong></p>
<p>resultMap属性是用来定义查询结果和Java对象属性之间的映射关系；</p>
<p>通过resultMap属性可以<strong>自定义</strong>查询结果与Java对象属性的映射关系。</p>
<ul>
<li><code>&lt;resultMap&gt;标签</code><ul>
<li><code>id</code> 属性：唯一标识</li>
<li><code>type</code> 属性：指定映射的JAVA类型</li>
</ul>
</li>
<li><code>&lt;id&gt;标签</code> ：指定映射的主键字段，包含 <code>column属性</code> 和 <code>property属性</code><ul>
<li><code>column属性</code> ：查询语句中的列名（或别名）</li>
<li><code>property属性</code> ：JAVA对象中的属性名</li>
</ul>
</li>
<li><code>&lt;result&gt;标签</code> ：指定映射的非主键字段，包含 <code>column属性</code> 和 <code>property属性</code><ul>
<li><code>column属性</code> ：查询语句中的列名（或别名）</li>
<li><code>property属性</code> ：JAVA对象中的属性名</li>
</ul>
</li>
<li><code>&lt;collection&gt;标签</code> ：映射一对多或多对多关系<ul>
<li><code>property属性</code> ：JAVA对象中的属性名</li>
<li><code>ofType属性</code> ：集合中元素的类型</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    resultMap示例</span></span><br><span class="line"><span class="comment">    1.id属性：唯一标识</span></span><br><span class="line"><span class="comment">    2.type属性：指定映射的JAVA类型</span></span><br><span class="line"><span class="comment">    3.&lt;id&gt;标签：映射主键字段</span></span><br><span class="line"><span class="comment">    4.&lt;result&gt;标签：映射非主键字段</span></span><br><span class="line"><span class="comment">    5.column属性：查询语句中的列名(别名)</span></span><br><span class="line"><span class="comment">    6.property属性：java中的属性名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;aaa&quot;</span> <span class="attr">type</span>=<span class="string">&quot;cn.tedu._03MYBATIS.pojo.WeiboMapVO1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;content&quot;</span> <span class="attr">property</span>=<span class="string">&quot;content&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMapById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;aaa&quot;</span>&gt;</span></span><br><span class="line">    SELECT id,</span><br><span class="line">    content,</span><br><span class="line">    user_id</span><br><span class="line">    FROM weibo</span><br><span class="line">    WHERE id = #&#123;wid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 建立对应关系 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;account&quot;</span> <span class="attr">id</span>=<span class="string">&quot;accountMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;aid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;uid&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;money&quot;</span> <span class="attr">property</span>=<span class="string">&quot;money&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 它是用于指定从表方的引用实体属性的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;user&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;accountMap&quot;</span>&gt;</span></span><br><span class="line">    select u.*,a.id as aid,a.uid,a.money from account a,user u where a.uid =u.id;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>ResultMap多表一对多</strong> </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    查询指定的用户发布的所有的 **微博信息** ，要求将 **微博信息** 放到一个集合中</span></span><br><span class="line"><span class="comment">    要求显示：用户的id、用户昵称、`List&lt;Weibo&gt;集合`</span></span><br><span class="line"><span class="comment">    resultMap示例</span></span><br><span class="line"><span class="comment">    1.id属性：唯一标识</span></span><br><span class="line"><span class="comment">    2.type属性：指定映射的JAVA类型</span></span><br><span class="line"><span class="comment">    3.&lt;id&gt;标签：映射主键字段</span></span><br><span class="line"><span class="comment">    4.&lt;result&gt;标签：映射非主键字段</span></span><br><span class="line"><span class="comment">    5.column属性：查询语句中的列名(别名)</span></span><br><span class="line"><span class="comment">    6.property属性：java中的属性名</span></span><br><span class="line"><span class="comment">    7.&lt;collection&gt;标签：映射一对多或多对多关系</span></span><br><span class="line"><span class="comment">    8.ofType属性：集合中元素的类型</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;ccc&quot;</span> <span class="attr">type</span>=<span class="string">&quot;cn.tedu._03MYBATIS.pojo.WeiboMapVO2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;nickname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;nickname&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;weibos&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;cn.tedu._03MYBATIS.pojo.Weibo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;wid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;content&quot;</span> <span class="attr">property</span>=<span class="string">&quot;content&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;created&quot;</span> <span class="attr">property</span>=<span class="string">&quot;created&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMapByUserId&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;ccc&quot;</span>&gt;</span></span><br><span class="line">    SELECT u.id,</span><br><span class="line">    u.nickname,</span><br><span class="line">    w.id wid,</span><br><span class="line">    w.content,</span><br><span class="line">    w.created,</span><br><span class="line">    w.user_id</span><br><span class="line">    FROM user u</span><br><span class="line">    JOIN weibo w ON w.user_id = u.id</span><br><span class="line">    WHERE u.id = #&#123;uid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>多表对多</strong></p>
<p>相当于两个 一对多</p>
<p><strong>常见问题:</strong></p>
<ul>
<li><p>数据库驱动异常</p>
<p><strong>检查配置文件中数据库连接的URL地址</strong></p>
<p>Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name <strong>‘dataSource’</strong> defined in class path resource</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309191556063.png" alt="image-20230910092029653"></p>
</li>
<li><p>数据库连接异常</p>
<p><strong>检查配置文件中数据库连接配置信息</strong></p>
<p>Error updating database. Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain <strong>JDBC Connection</strong>; nested exception is java.sql.SQLException: !AuthenticationProvider.BadAuthenticationPlugin!</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309100920871.png" alt="image-20230910092057831"></p>
</li>
<li><p>xml文件语法错误</p>
<p><strong>根据文件提示检查xml文件具体语法</strong></p>
<p>Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name <strong>‘sqlSessionFactory’</strong> defined in class path resource [org/mybatis/spring/boot/autoconfigure/MybatisAutoConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309191556910.png" alt="image-20230910092112018"></p>
</li>
<li><p>绑定异常</p>
<ol>
<li><strong>配置文件中xml文件映射位置指定错误:<code>mybatis.mapper-locations=</code></strong></li>
<li><strong>xml文件中名称空间 namespace 属性值错误</strong></li>
<li><strong>检查标签中的 id 属性值 是否和 接口方法名一致</strong></li>
</ol>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309191556886.png" alt="image-20230910092121785"></p>
</li>
<li><p>SQL语法错误</p>
<p><strong>出现此异常请仔细检查SQL语句,可以放到 console 中执行SQL语句测试</strong></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309191556308.png" alt="image-20230910092212766"></p>
</li>
<li><p>查询结果封装异常</p>
<p><strong>比如指定 VO 对象接收返回值,但是查询时查到多条结果</strong></p>
</li>
</ul>
<p><strong>Mybatis XML配置问题</strong></p>
<ul>
<li>获取新增用户 id (自增长)的返回值</li>
</ul>
<p>新增用户后，同时还要返回当前新增用户的 id 值，因为 id 是由数据库的自动增长来实现的，所以就相<br>当于我们要在新增后将自动增长 auto_increment 的值返回。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;saveUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;USER&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置保存时获取插入的 id --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyColumn</span>=<span class="string">&quot;id&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">select last_insert_id();</span><br><span class="line"><span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">insert into user(username,birthday,sex,address)</span><br><span class="line">values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>模糊查询的两种方式:防止SQL注入攻击</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">语句1:select * from user where username like ?  参数: %邓%</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.deng.domain.User&quot;</span>&gt;</span></span><br><span class="line">select * from user where username like #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">语句2:select * from user where username like %邓%  参数: 邓</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.deng.domain.User&quot;</span>&gt;</span></span><br><span class="line">select * from user where username like &#x27;%$&#123;value&#125;%&#x27;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#&#123;&#125; 表示一个占位符号</span><br><span class="line">通过#&#123;&#125;可以实现 preparedStatement 向占位符中设置值，自动进行 java 类型和 jdbc 类型转换，</span><br><span class="line">#&#123;&#125;可以有效防止 sql 注入。 #&#123;&#125;可以接收简单类型值或 pojo 属性值。 如果 parameterType 传输单个简单类</span><br><span class="line">型值，#&#123;&#125;括号中可以是 value 或其它名称。</span><br><span class="line">$&#123;&#125; 表示拼接 sql 串</span><br><span class="line">通过$&#123;&#125;可以将 parameterType 传入的内容拼接在 sql中且不进行 jdbc 类型转换， $&#123;&#125;可以接收简</span><br><span class="line">单类型值或 pojo 属性值，如果 parameterType 传输单个简单类型值，$&#123;&#125;括号中只能是 value。</span><br></pre></td></tr></table></figure>

<p><strong>Mybatis 使用注解配置(不能处理复杂的业务逻辑)</strong></p>
<p>@Mapper</p>
<p>​    MyBatis框架的注解，用于描述数据层接口，告诉系统底层为此接口创建其实现类，在实现类中定<br>​    义数据访问逻辑，执行与数据库的会话(交互)。</p>
<p>@Insert</p>
<p>​    MyBatis框架注解，使 MyBatis 框架根据接口方法的参数类型自动生成插入数据的JDBC代码。</p>
<p>@Update</p>
<p>@Delete</p>
<p>@Select</p>
<p><strong>Mybatis延迟加载：</strong><br>就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载.<br>好处：先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。</p>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p>MVC</p>
<ul>
<li><p>降低各个模块之间的耦合度, 使工程可扩展性和可维护性更强.</p>
</li>
<li><p>M: Model 模型, 业务逻辑处理和数据库交互.</p>
</li>
<li><p>V: View 视图, 负责数据展示(html css js images)</p>
</li>
<li><p>C: Controler 控制器, 负责接收请求,调用模型层进行业务处理,并将结果返回给视图层.</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309101436908.png" alt="image-20230910143630853"></p>
</li>
</ul>
<p>SpringMVC是一种基于MVC（模型-视图-控制器）模式的Web框架，它是基于Spring框架的一个子项目。</p>
<p>它通过将请求分派给相应的控制器来处理Web请求，然后将处理结果发送回客户端。</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309191556679.png" alt="image-20230910140027395"></p>
<ol>
<li>客户端发送请求至前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求后，调用处理器映射器HandlerMapping</li>
<li>HandlerMapping根据请求URL找到具体的Controller。</li>
<li>Controller处理请求，并返回ModelAndView，其中的View只是视图名，并不指向具体的视图组件</li>
<li>DispatcherServlet通过ViewReslover（视图解析器）确定负责显示数据的具体View</li>
<li>DispatcherServlet对View进行渲染视图（即将Model填充至视图组件中），并将完整的视图响应到客户端</li>
</ol>
<ul>
<li><p>客户端: 更改了客户端的html代码或者添加了图片,一定要 <strong>Rebuild Static</strong></p>
</li>
<li><p>服务端: 如果服务端代码有更新必须要重启工程</p>
</li>
</ul>
<p>SpringMVC处理请求</p>
<p>静态请求:html CSS JS 数据</p>
<p>默认页面:inde.html </p>
<p>静态资源默认位置:</p>
<p>ResourceProperties的类，里面就定义了静态资源的默认查找路径： </p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309191556130.png" alt="image-20230911195747544"></p>
<p>默认的静态资源路径为：</p>
<ul>
<li>classpath:/META-INF/resources/</li>
<li>classpath:/resources/</li>
<li>classpath:/static/</li>
<li>classpath:/public/</li>
</ul>
<p>只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。</p>
<p>我们一般放在static 下面</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309111958004.png" alt="image-20230911195834969"></p>
<p>动态请求: 数据库数据</p>
<ul>
<li><p><code>@Controller</code> 注解</p>
<p>标注一个类；</p>
<p>表示该类是一个<strong>控制器</strong>，负责处理用户的请求，并将处理结果生成响应返回给客户端。</p>
</li>
<li><p><code>@RequestMapping</code> 注解</p>
<p>请求注解；</p>
<p>添加在控制器类或控制器方法上；</p>
<p>将HTTP请求映射到控制器中的方法，指定处理请求的路径</p>
<ul>
<li>控制器类上：为整个控制器指定一个基础路径</li>
<li>控制器方法上：指定相对于基础路径的具体路径</li>
</ul>
</li>
<li><p><code>@ResponseBody</code> 注解</p>
<p>响应注解；</p>
<p>添加在控制器方法上；</p>
<p>可以使控制器方法通过返回值的方式将响应返回给客户端。</p>
</li>
</ul>
<p>Http请求方法:</p>
<p>GET  </p>
<p>POST </p>
<p><strong>客户端发送数据-&gt; controller</strong></p>
<p>GET</p>
<p>POST</p>
<ul>
<li>html中：Form表单完成POST请求方式的发送</li>
<li>IDEA中：<code>.http</code> 后缀文件完成POST请求的发送</li>
</ul>
<p>服务端返回数据 -&gt;modelandview</p>
<p><strong>.http文件测试接口</strong></p>
<p>使用SpringMVC中提供的 <code>.http</code> 后缀的文件来测试 Controller 层接口。</p>
<p><font color=red>使用三个 # 号 作为不同测试方法的分隔符，也可以作为注释说明。</font></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309121329610.png" alt="image-20230912132921545"></p>
<p>第1步：在test目录下创建 Directory ：http</p>
<p>第2步：创建 <code>.http</code> 后缀的文件进行测试：testUserController.http</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### GET请求测试</span><br><span class="line">GET http://localhost:8080/v1/users/login?username=liying&amp;password=123456</span><br><span class="line">Accept: application/json</span><br><span class="line"></span><br><span class="line">### POST请求测试</span><br><span class="line">POST http://localhost:8080/v1/users/login</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">username=liying&amp;password=123456</span><br></pre></td></tr></table></figure>

<p>第3步：执行对应的请求方法测试</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309191556770.png" alt="image-20230910170442100"></p>
<p><strong>服务端接收参数</strong></p>
<p><strong>HttpServletRequest接收</strong></p>
<p>客户端把用户名和密码信息传递给服务端，服务端接收传递过来的用户名和密码信息。</p>
<p>controller.UserController 处理请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**方式1：使用HttpServletRequest接收数据*/</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/v1/users/login&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> username + <span class="string">&quot;:&quot;</span> + password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>声明参数接收</strong></p>
<p>以在处理请求的方法中通过 <strong>声明参数的方式</strong> 来接收客户端传递过来的数据。</p>
<p>第1步：controller.UserController处理登录请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**方式2：通过声明参数的方式接收*/</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/v1/users/login&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">// 好处：代码简洁，并且可以自动根据声明的类型进行转换</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String username, String password)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;username = &quot;</span> + username + <span class="string">&quot;, password = &quot;</span> + password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第2步：重启工程，执行测试脚本测试</p>
<p><strong>声明POJO类接收</strong></p>
<p>如果客户端传递数据过多，</p>
<p>通过 <code>HttpServletRequest</code> 方式接收复用性较差，通过 <code>声明参数接收</code> 很繁琐；</p>
<p>所以可以将数据封装到 <code>POJO类</code> 中来接收。</p>
<p><strong>POJO</strong></p>
<p>Plain Ordinary Java Object：简单的Java对象；</p>
<p>是没有继承任何类或实现任何接口的简单 Java 对象，也不依赖于其他复杂的框架或技术；</p>
<p>POJO 对象通常包含了纯粹的数据和简单的业务逻辑，是一种用于简化 Java 应用程序开发的编程模型；</p>
<p><strong>是entity实体类、VO（Value Object或View Object）视图对象、DTO（Data Transfer Object）数据传输对象 这3个对象的总称。</strong></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309121331639.png" alt="image-20230912133145568"></p>
<p> entity实体类|DTO|VO</p>
<ul>
<li><p>entity实体类作用</p>
<p>用来和数据库中的表字段一一对应的，比如UserEntity(id,username,password,nickname)；</p>
</li>
<li><p>DTO作用</p>
<p>用来接收客户端传递给服务器的数据的，比如：UserLoginDTO(username,password)    实现登录功能，客户端向服务器端传递数据；</p>
<p><strong>参数数量为1-2个时,使用声明参数方式接收, 如果参数数量为3个以上, 使用声明DTO类方式接收</strong></p>
</li>
<li><p>VO作用</p>
<p>用来处理服务器响应给客户端的数据的，比如：UserListVO(id,username,nickname)  登录成功后的列表页显示当前用户信息。</p>
</li>
</ul>
<p><strong>SpringMVC 项目流程:</strong></p>
<ol>
<li>搭建整体环境<ul>
<li>配置文件中配置xml文件映射位置及数据库连接信息(mybatis)</li>
<li><strong>创建controller包(添加@Controller)</strong></li>
<li>创建接口(DAO层接口)</li>
<li>创建pojo(entity,DTO,VO)</li>
<li>创建mappers目录,存放xml文件, 并指定名称空间namespace</li>
</ul>
</li>
<li>创建实体类</li>
<li>创建DTO </li>
<li>梳理Controller中功能实现的逻辑</li>
<li>定义接口方法 配置xml 测试接口</li>
<li>完成Controller中的最终逻辑[<strong>自动装配</strong>]</li>
<li>重启工程,测试功能</li>
</ol>
<p><strong>注解</strong></p>
<ul>
<li><p><code>@RequestMapping</code> 注解</p>
<p>请求注解；</p>
<p>添加在控制器类或控制器方法上；</p>
<p>将HTTP请求映射到控制器中的方法，指定处理请求的路径</p>
<ul>
<li>控制器类上：为整个控制器指定一个基础路径</li>
<li>控制器方法上：指定相对于基础路径的具体路径</li>
</ul>
</li>
<li><p><code>@Controller</code> 注解</p>
<p>标注一个类；</p>
<p>表示该类是一个控制器，负责处理用户的请求，并将处理结果生成响应返回给客户端。</p>
<p>声明该类为SpringMVC的控制器组件，可以接收HTTP请求并返回响应给客户端。</p>
</li>
<li><p><code>@ResponseBody</code> 注解</p>
<p>响应注解；</p>
<p>添加在控制器方法上；</p>
<p>可以使控制器方法通过返回值的方式将响应返回给客户端。</p>
<p>将控制器方法返回的对象直接作为HTTP响应的内容返回客户端</p>
<p>将控制器方法返回的JAVA对象转为JSON格式的字符串返回给客户端</p>
</li>
<li><p><strong><code>@RestController</code> 注解(重要)</strong></p>
<p>作用于类上；组合注解, 相当于 @Controller注解 + @ResponseBody注解 ；</p>
<p>作用是将类中的方法返回值直接作为HTTP响应的内容；</p>
<p>在控制器类中加入该注解后，无需在每个方法上添加<code>@ResponseBody</code>注解；</p>
<p>可以让Spring框架自动将方法的返回值序列化并填充到HTTP响应中，实现Web服务端点的快速开发。</p>
</li>
<li><p><code>@MapperScan</code> 注解说明</p>
<p>添加在 <strong>Spring配置类</strong> 上；</p>
<p><strong>用于告诉 Spring 扫描 MyBatis Mapper 接口并创建对应的 Mapper 实现；</strong></p>
<p>可以指定扫描 MyBatis 映射器接口的包名。</p>
<p>该注解指定扫描路径后，当Spring Boot启动时，它会自动扫描指定<br>包及其子包下的Mapper接口，并将其注册为Spring容器中的Bean；<br>添加此注解后,接口上无需再添加 @Mapper 注解。</p>
</li>
</ul>
<p><strong>SpringMVC 三层架构:</strong>        </p>
<p>三层架构: Controller Service  Dao </p>
<h3 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h3><ul>
<li><p>请求的URL地址</p>
<p>协议: http/https  域名中体现 <code>api</code> 字样，版本:路径中要有版本控制 <code>v1</code> ，路径:资源用名词表示；</p>
</li>
<li><p>请求的方法</p>
<ul>
<li>GET : （SELECT） 查看资源</li>
<li>POST：（CREATE）新增资源</li>
<li>PUT ：（UPDATE） 修改资源</li>
<li>DELETE ：（DELETE）删除资源</li>
</ul>
</li>
<li><p>响应状态码</p>
<ul>
<li><p>200</p>
</li>
<li><p>405</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309121322544.png" alt="image-20230912132207485"></p>
</li>
<li><p>400</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309121321951.png" alt="image-20230912132104859"></p>
</li>
<li><p>404</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309121321128.png" alt="image-20230912132126064"></p>
</li>
<li><p>500</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309191556100.png" alt="image-20230912132145197"></p>
</li>
</ul>
</li>
<li><p>RestFul限定请求方式的注解</p>
<p>@RequestMapping 注解 指定method</p>
<p>@RequestMapping 用于指定处理请求的 URL，它可以标注在类和方法上；<br>可以通过 method 参数限定处理 GET、POST、PUT、DELETE 等HTTP的请求方法，比如：<br>处理 GET 请求<br>@RequestMapping(value = “/v1/users”, method = RequestMethod.GET)<br>处理 POST 请求<br>@RequestMapping(value = “/v1/users”, method = RequestMethod.POST)<br>处理 PUT DELETE 方式的HTTP请求同理。</p>
<p><strong>@GetMapping 注解</strong><br>@GetMapping 只会处理 HTTP GET 请求；<br>是 @RequestMapping(method = RequestMethod.GET) 的缩写。<br>如果限定为处理GET请求，则发送其他方式请求时HTTP状态码为 405@GetMapping 只会处理 HTTP GET 请求；<br>是 @RequestMapping(method = RequestMethod.GET) 的缩写。<br>如果限定为处理GET请求，则发送其他方式请求时HTTP状态码为 405</p>
</li>
</ul>
<p>​        <strong>@PostMapping 注解</strong></p>
<p>​        <strong>@PutMapping 注解</strong>    </p>
<p>​        <strong>@DeleteMapping 注解</strong></p>
<p> <strong>@PathVariable 注解</strong></p>
<p>@PathVariable 注解用于接受 RESTful API 中的 URL 中的变量；</p>
<p>通常与请求注解一起使用，可以将 URL 中的变量映射到 Controller 中的方法参数上。<br>用法<br>假如有一个 RESTful API： /v1/users/{id} ，<br>其中 {id} 是一个变量，表示用户 ID。<br>可以这样定义一个处理该请求的控制器方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/v1/users/&#123;id&#125;&quot;)</span><br><span class="line">public String getUserById(@PathVariable Integer id) &#123;</span><br><span class="line">  // 根据 ID 查询用户，并返回用户信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用示例<br>根据 id 查询用户，并返回该用户信息<br>地址： /v1/users/{id} id为用户id<br>请求方法： GET<br>查询参数：无<br>响应类型：用户对象user<br>实现</p>
<p>根据 id 查询用户，并返回该用户信息（ GET请求：/v1/users/{id} ）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/v1/users/&#123;id&#125;&quot;)</span><br><span class="line">public String getUserById(@PathVariable Integer id) &#123;</span><br><span class="line">  // 根据 ID 查询用户，并返回用户信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>JSON（JavaScript Object Notation）是一种数据交换格式，常用于不同系统间的数据传输。<br>在使用SpringMVC框架时，常常需要将Java对象转换成JSON格式，然后返回给前端。<br>JSON格式的数据通常由一对花括号 {} 括起来，在花括号中包含键值对，键值对之间使用逗号分隔。<br>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Tom&quot;,</span><br><span class="line">  &quot;age&quot;: 18,</span><br><span class="line">  &quot;interests&quot;: [&quot;reading&quot;, &quot;music&quot;],</span><br><span class="line">  &quot;address&quot;: &#123;</span><br><span class="line">    &quot;city&quot;: &quot;Beijing&quot;,</span><br><span class="line">    &quot;street&quot;: &quot;xxx road&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><p> <strong>Lombok简介</strong></p>
<p>Lombok 是一个 Java 库，可以通过在代码中添加注解来消除模板代码，以简化 Java 代码的编写过程；</p>
<p>Lombok 支持自动生成 getter、setter、toString等方法，减少了重复性的开发工作。</p>
<p><strong>安装和配置 Lombok</strong></p>
<ul>
<li><p>pom.xml中引入 Lombok 的依赖并刷新Maven</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入Lombok依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在Idea中确认是否安装Lombok 插件</p>
<ul>
<li><p>引入 Lombok 的依赖是让编译器能够找到 Lombok 提供的注解并对其进行处理，但是这不足以让 IDE 可以正常地识别和支持 Lombok 的注解。       </p>
</li>
<li><p>为了在 IDE 中正常地使用 Lombok，需要安装 IDE 插件来支持 Lombok 的注解。插件会将 Lombok 的注解转换为相应的代码，以便能够在 IDE 中正确地显示代码提示等功能。      </p>
</li>
<li><p>所以，为了使 Lombok 的注解在 IDE 中正常运行，需要同时引入 Lombok 的依赖并安装对应的 IDE 插件。</p>
</li>
</ul>
<p><font color=red><strong>如果没有安装请安装此插件</strong></font></p>
<ol>
<li><p>打开 IntelliJ IDEA，点击 File -&gt; Settings -&gt; Plugins。</p>
</li>
<li><p>在搜索框中输入 lombok，并点击搜索按钮。</p>
</li>
<li><p>选择 Lombok 插件，点击 Install 按钮进行安装。</p>
</li>
<li><p>安装完成后，弹出提示框，一般会提示重启 IntelliJ IDEA 以激活 Lombok 插件。点击 Restart IntelliJ IDEA 按钮进行重启。</p>
</li>
<li><p>重启后，即可使用 Lombok 注解。</p>
</li>
</ol>
</li>
</ul>
<p><strong>Lombok常用注解</strong></p>
<p>Lombok 提供了许多注解，每个注解用来生成特定的代码块。下面是一些常用的注解：</p>
<p><strong><code>@Getter</code> 和 <code>@Setter</code></strong></p>
<p>用来生成 getter 和 setter 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将自动生成 <code>getName()</code>, <code>setName()</code>, <code>getAge()</code>, <code>setAge()</code> 方法。</p>
<p><strong><code>@ToString</code></strong></p>
<p>用来生成 toString 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将自动生成 <code>toString()</code> 方法。</p>
<p><strong><code>@AllArgsConstructor</code> 和 <code>@NoArgsConstructor</code></strong></p>
<p>用来生成带参数的和无参的构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将自动生成一个有参构造函数和一个无参构造函数。</p>
<p><strong><code>@Data</code></strong></p>
<p>是一个组合的注解，它等价于同时使用了 <code>@Getter</code>、<code>@Setter</code>、<code>@ToString</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将自动生成 <code>getName()</code>, <code>setName()</code>, <code>getAge()</code>, <code>setAge()</code>以及 <code>toString()</code> 方法。</p>
<p><strong>@Slf4j 日志注解</strong></p>
<p><code>@Slf4j</code> 是 lombok 中的注解；</p>
<p>此注解描述类时会在类中创建一个日志对象，基于日志对象可以输出一些日志。</p>
<p><strong>使用方法</strong></p>
<p>在需要使用日志的类上加上 <code>@Slf4j</code> 注解即可。</p>
<ul>
<li><code>log.debug(&quot;日志信息&quot;)</code></li>
<li><code>log.info(&quot;日志信息&quot;)</code></li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;myMethod方法被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中， <code>@Slf4j</code> 注解被加在了 <code>MyClass</code> 类上。这样就可以在 <code>MyClass</code> 中直接使用 <code>log</code> 对象输出日志了。</p>
<p><strong>日志级别</strong></p>
<p><font color=red>**日志级别：TRACE&lt;DEBUG&lt;INFO&lt;WARN&lt;ERROR**</font></p>
<ul>
<li><p>TRACE</p>
<p>追踪级别；</p>
<p>用于跟踪代码执行的详细信息。通常用于调试阶段，用于输出一些详细的调试信息，对性能影响较大；</p>
</li>
<li><p>DEBUG</p>
<p>调试级别；</p>
<p>用于输出调试信息，帮助开发人员诊断问题。通常用于开发和测试阶段，例如输出方法的输入参数和返回值；</p>
</li>
<li><p>INFO（<strong>默认的级别</strong>）</p>
<p>普通信息级别；</p>
<p>用于输出程序的一般运行信息。通常用于生产环境，记录程序运行的关键信息，如系统启动、关键操作完成等；</p>
</li>
<li><p>WARN</p>
<p>警告级别；</p>
<p>用于输出警告信息。通常用于发现一些可能的问题或不正常的情况，但不会影响程序的正常运行；</p>
</li>
<li><p>ERROR</p>
<p>错误级别；</p>
<p>用于输出错误信息。通常用于记录程序的错误信息、异常信息，表示程序出现了严重的问题，无法正常运行</p>
</li>
</ul>
<p>注意：在 <code>@Slf4j</code> 注解中，应根据不同的应用场景和需求，可以选择适当的日志级别。</p>
<p>在开发和测试阶段，可以将日志级别设置为<code>DEBUG</code>，以便获取详细的调试信息。</p>
<p>而在生产环境中，一般将日志级别设置为<code>INFO</code>或更高级别。</p>
<p><strong>设置日志级别</strong></p>
<p><code>@Slf4j</code> 注解默认的日志级别为 INFO，即只会输出 INFO级别 以及 比INFO日志级别更高级别的日志信息，如需配置则需要在配置文件 <code>application.properties</code> 配置文件中进行配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置日志级别为WARN</span></span><br><span class="line"><span class="attr">logging.level.root</span>=<span class="string">WARN</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 将cn.tedu包及其包中的所有类的日志级别设置为DEBUG级别</span></span><br><span class="line"><span class="attr">logging.level.cn.tedu</span>=<span class="string">DEBUG</span></span><br></pre></td></tr></table></figure>

<p><strong><code>@Slf4j</code> 注解优点</strong></p>
<p>使用 <code>@Slf4j</code> 注解相比 <code>System.out.println(&quot;xxx&quot;)</code> 的好处</p>
<ul>
<li><p>更加高效</p>
<p>使用 <code>@Slf4j</code> 注解输出日志，可以避免产生大量的无用日志信息，减少对内存和磁盘等资源的消耗。</p>
<p>而使用 <code>System.out.println()</code> 会产生大量冗余的输出信息，不仅对调试造成困扰，而且会对应用程序的性能产生影响。</p>
</li>
<li><p>日志级别更加明确</p>
<p>使用 <code>@Slf4j</code> 注解，可以根据需要输出不同级别的日志，例如，警告、错误等。通过灵活控制日志输出的级别，可以及时发现并解决问题。</p>
<p>而使用 <code>System.out.println()</code> 输出的日志级别是不可控的，并且无法选择性地过滤日志。</p>
</li>
</ul>
<h3 id="Knife4j"><a href="#Knife4j" class="headerlink" title="Knife4j"></a>Knife4j</h3><p><strong>Knife4j是基于SpringBoot构建的一个文档生成工具，它可以让开发者为我们的应用生成API文档；</strong></p>
<p><strong>目的是可以更加方便的基于API文档进行测试。</strong></p>
<p>生成的文档还可以导出，然后给到前端开发团队，前端开发团队可以基于API接口写具体的调用。</p>
<p><strong>Knife4j的优点</strong></p>
<ul>
<li>Knife4j 功能强大，易于操作。</li>
<li>Knife4j 的UI界面非常美观，使用流畅。</li>
<li>Knife4j 可以高度定制化，让其符合你的项目需求。</li>
</ul>
<p><strong>Knife4j的使用</strong></p>
<p>pom.xml添加依赖</p>
<p>在你的SpringBoot项目的pom.xml文件中，添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加Knife4j依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-openapi2-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>配置Swagger的相关信息</strong></p>
<p><font color=red><strong>工程目录下创建config.Knife4jConfig</strong></font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.PathSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2WebMvc;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2WebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Knife4jConfig</span> &#123;</span><br><span class="line">    <span class="comment">//配置Swagger2的Docket的Bean实例</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                <span class="comment">// apiInfo()：配置 API 的一些基本信息，比如：文档标题title，文档描述description，文档版本号version</span></span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                <span class="comment">// select()：生成 API 文档的选择器，用于指定要生成哪些 API 文档</span></span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">// apis()：指定要生成哪个包下的 API 文档</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;cn.tedu._04weibo.controller&quot;</span>))</span><br><span class="line">                <span class="comment">// paths()：指定要生成哪个 URL 匹配模式下的 API 文档。这里使用 PathSelectors.any()，表示生成所有的 API 文档。</span></span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文档信息配置</span></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                <span class="comment">// 文档标题</span></span><br><span class="line">                .title(<span class="string">&quot;微博项目&quot;</span>)</span><br><span class="line">                <span class="comment">// 文档描述信息</span></span><br><span class="line">                .description(<span class="string">&quot;微博项目在线API文档&quot;</span>)</span><br><span class="line">                <span class="comment">// 文档版本号</span></span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查看生成的接口文档</strong></p>
<p>在 SpringBoot 项目启动后，访问 <code>http://localhost:8080/doc.html</code> 地址即可查看生成的Knife4j接口文档。</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309111112057.png" alt="image-20230911111221011"></p>
<p><strong>常用注解应用分析</strong></p>
<ul>
<li><p><strong>@Api注解</strong></p>
<p>添加在控制器类上的注解；</p>
<p>通过此注解的tags属性可以修改原本显示控制器类名称的位置的文本；</p>
<p>通常建议在配置的tags属性值上添加序号，例如：“01. 用户模块”、“02. 微博模块”，则框架会根据值进行排序。</p>
<ul>
<li><p>参数说明</p>
<ul>
<li>tags：配置模块名称</li>
</ul>
</li>
<li><p>代码示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. UserController</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;01.用户管理模块&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. WeiboController</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;02.微博管理模块&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeiboController</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. CommentController</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;03.评论管理模块&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommentController</span> &#123;...&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>文档效果（<strong>重启工程并刷新页面：<a target="_blank" rel="noopener" href="http://localhost:8080/doc.html#/home">http://localhost:8080/doc.html#/home</a></strong>）</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309111119803.png" alt="image-20230911111943757"></p>
</li>
</ul>
</li>
<li><p><strong>@ApiOperation注解</strong></p>
</li>
<li><p><strong>@ApiOperationSupport注解</strong></p>
<p>添加在控制器类中处理请求的方法上的注解；</p>
<p>用于配置此方法处理的请求在API文档中显示的文本。</p>
<ul>
<li><p>参数说明</p>
<ul>
<li>value：配置业务名称</li>
</ul>
</li>
<li><p>代码示例</p>
<p><strong>此处以注册功能为例，其他所有方法请添加说明</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**注册功能*/</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;reg&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;注册功能&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperationSupport(order = 100)</span><span class="comment">//排序 order = 100/200/300/400 设计</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reg</span><span class="params">(<span class="meta">@RequestBody</span> UserRegDTO userRegDTO)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>文档效果（<strong>重启工程并刷新页面：<a target="_blank" rel="noopener" href="http://localhost:8080/doc.html#/home">http://localhost:8080/doc.html#/home</a></strong>）</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309111119091.png" alt="image-20230911111951036"></p>
</li>
</ul>
</li>
<li><p><strong>@ApiModelProperty注解</strong></p>
<p>是添加在POJO类的属性上的注解；</p>
<p>用于对请求参数或响应结果中的某个属性进行说明；</p>
<p>主要通过其value属性配置描述文本，并可通过example属性配置示例值。</p>
<ul>
<li><p>参数说明</p>
<ul>
<li>value属性：配置参数名称</li>
<li>required属性：配置是否必须提交此请求参数</li>
<li>example属性：配置示例值</li>
</ul>
<p><font color=red>注意：如果配置了 required=true,只是一种显示效果，Knife4j框架并不具备检查功能</font></p>
</li>
<li><p>代码示例</p>
<p><strong>以注册功能UserRegDTO为例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegDTO</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;用户名&quot;, required = true, example = &quot;赵丽颖&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;密码&quot;, required = true)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;昵称&quot;, required = true)</span></span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>文档效果（<strong>重启工程并刷新页面：<a target="_blank" rel="noopener" href="http://localhost:8080/doc.html#/home">http://localhost:8080/doc.html#/home</a></strong>）</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309111124979.png" alt="image-20230911112427914"></p>
</li>
</ul>
</li>
<li><p><strong>@ApiImplicitParam注解</strong></p>
<p><strong>添加在控制器类中处理请求的方法上的注解；</strong></p>
<p>主要用于配置非封装的参数</p>
<ul>
<li><p>参数说明</p>
<ul>
<li>name：指定参数名称（<strong>参数变量名</strong>）</li>
<li>value：配置参数名称</li>
<li>dataType：配置数据类型</li>
<li>required：配置是否必须提交此请求参数</li>
<li>example：配置参数的示例值</li>
</ul>
<p><font color=red>注意：一旦使用此注解，各个参数的数据类型默认都会显示String，可以通过dataType指定数据类型</font></p>
</li>
<li><p>代码示例</p>
<p><strong>此处以微博详情功能为例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiImplicitParam(name = &quot;id&quot;, value = &quot;微博&quot;, required=true, dataType = &quot;int&quot;)</span></span><br><span class="line"><span class="keyword">public</span> WeiboDetailVO <span class="title function_">selectById</span><span class="params">(<span class="type">int</span> id)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>文档效果（<strong>重启工程并刷新页面：<a target="_blank" rel="noopener" href="http://localhost:8080/doc.html#/home">http://localhost:8080/doc.html#/home</a></strong>）</p>
<p><img src="/img/loading.gif" data-original="C:\Users\foo\Desktop\JavaProject\jsd2306-ssm-teacher\笔记\07Knife4j笔记\images\image-20230513234756279.png" alt="image-20230513234756279"></p>
</li>
</ul>
</li>
<li><p><strong>@ApiImplicitParams注解</strong></p>
<p>添加在控制器类中处理请求的方法上的注解；</p>
<p>当方法有多个非封装的参数时，在方法上添加此注解，并在注解内部通过@ApiImplicitParam数组配置多个参数。</p>
<ul>
<li><p>代码示例</p>
<p><strong>此处以微博详情功能为例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**微博详情页功能*/</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;selectById&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;微博详情功能&quot;)</span></span><br><span class="line"><span class="meta">@ApiImplicitParams(value = &#123;</span></span><br><span class="line"><span class="meta">    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;微博&quot;, required=true, dataType = &quot;int&quot;),</span></span><br><span class="line"><span class="meta">    @ApiImplicitParam(name = &quot;username&quot;, value = &quot;用户名&quot;, required=true)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="comment">// 额外增加username参数，仅仅用于测试</span></span><br><span class="line"><span class="keyword">public</span> WeiboDetailVO <span class="title function_">selectById</span><span class="params">(<span class="type">int</span> id, String username)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> weiboMapper.selectById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>文档效果（<strong>重启工程并刷新页面：<a target="_blank" rel="noopener" href="http://localhost:8080/doc.html#/home">http://localhost:8080/doc.html#/home</a></strong>）</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309111126670.png" alt="image-20230911112600614"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>@ApiIgnore注解</strong></p>
<p>添加在处理请求的方法的参数上；</p>
<p>用于表示API文档框架应该忽略此参数。</p>
<p><strong>以发布微博功能的HttpSession参数为例</strong></p>
<ul>
<li><p>代码示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数中添加@ApiIgnore注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insert</span><span class="params">(<span class="meta">@RequestBody</span> WeiboDTO weiboDTO, <span class="meta">@ApiIgnore</span> HttpSession session)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>文档效果（<strong>重启工程并刷新页面：<a target="_blank" rel="noopener" href="http://localhost:8080/doc.html#/home">http://localhost:8080/doc.html#/home</a></strong>）</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309111126586.png" alt="image-20230911112619523"></p>
</li>
</ul>
</li>
</ul>
<p><strong>限制请求方式</strong></p>
<p>API文档中默认每个功能会展示7种请求方式，遵循RESTful规则将 <code>@RequestMapping</code> 注解修改为对应请求方法的注解，比如：<code>@GetMapping  @PostMapping  @PutMapping  @DeleteMapping</code> 注解，重启工程后刷新测试。</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309111128751.png" alt="image-20230911112803693"></p>
<p><strong>导出离线</strong>API文档</p>
<ol>
<li><p>文档管理 - 离线文档 中存在多种格式的导出格式</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309111127017.png" alt="image-20230911112748941"></p>
</li>
<li><p>选择合适的文档格式，导出即可到本地磁盘</p>
</li>
</ol>
<h3 id="JsonResult"><a href="#JsonResult" class="headerlink" title="JsonResult"></a>JsonResult</h3><p><strong>统一响应结果的处理</strong></p>
<p><strong>为什么需要统一响应结果处理</strong></p>
<p>在实际开发中，我们往往需要在多个控制器方法中返回相同的响应结构；</p>
<p>例如，统一返回接口调用成功的状态码、提示信息、以及请求结果数据。但是，如果对于每个接口都单独进行处理的话，不仅逻辑复杂，而且容易出现疏漏，进而增加前端调用的难度。</p>
<p>所以为了更好定义服务端返回值的格式，统一客户端对服务端响应结果的处理，我们需要将服务端返回到客户端的数据再次进行封装。</p>
<ul>
<li>响应状态码 <code>code</code></li>
<li>提示信息 <code>msg</code></li>
<li>响应数据 <code>data</code></li>
</ul>
<p><strong>统一状态码设计</strong></p>
<p>当项目中的状态码越来越多时，对状态码的定义如果没有统一规划，后续对状态的理解就会相当的困难，而且容易导致操作上的失败。</p>
<p><strong>状态码设计</strong></p>
<table>
<thead>
<tr>
<th align="center">自定义状态码</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1000</td>
<td align="center">未登录</td>
</tr>
<tr>
<td align="center">1001</td>
<td align="center">登录成功</td>
</tr>
<tr>
<td align="center">1002</td>
<td align="center">密码错误</td>
</tr>
<tr>
<td align="center">1003</td>
<td align="center">用户名错误</td>
</tr>
<tr>
<td align="center">1004</td>
<td align="center">用户名被占用</td>
</tr>
<tr>
<td align="center">2001</td>
<td align="center">操作成功</td>
</tr>
<tr>
<td align="center">2002</td>
<td align="center">操作失败</td>
</tr>
</tbody></table>
<p><strong>自定义状态吗</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.Getter;</span><br><span class="line">import lombok.NoArgsConstructor;</span><br><span class="line">@Getter</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public enum StatusCode &#123;</span><br><span class="line">  SUCCESS(1, &quot;OK&quot;),</span><br><span class="line">  NOT_LOGIN(1000, &quot;未登录&quot;),</span><br><span class="line">  LOGIN_SUCCESS(1001, &quot;登录成功&quot;),</span><br><span class="line">  PASSWORD_ERROR(1002, &quot;密码错误&quot;),</span><br><span class="line">  USERNAME_ERROR(1003, &quot;用户名错误&quot;),</span><br><span class="line">  USERNAME_ALREADY_EXISTS(1004, &quot;用户名被占用&quot;),</span><br><span class="line">  OPERATION_SUCCESS(2001, &quot;操作成功&quot;),</span><br><span class="line">  OPERATION_FAILED(2002, &quot;操作失败&quot;);</span><br><span class="line">  //状态码、状态码描述</span><br><span class="line">  private Integer code;</span><br><span class="line">  private String msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>统一响应结果处理的代码实现</strong></p>
<p><code>JsonResult</code>类的创建</p>
<p>首先，在工程目录中创建一个新的类<code>common.response.JsonResult</code>；该类作为统一的响应结果类；</p>
<p>其包含了响应结果的状态码（code）、提示信息（msg）和请求结果数据（data）三个属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonResult</span> &#123;</span><br><span class="line">    <span class="comment">/**响应状态码(业务状态码)*/</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="comment">/**状态码的含义(比如:用户名被占用...)*/</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="comment">/**服务端返回给客户端的具体数据(可能是VO对象,也可能是List集合...)*/</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**构造方法1:适用于不需要返回具体数据的Controller方法*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JsonResult</span><span class="params">(Integer code, String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**构造方法2:适用于不需要返回具体数据的Controller方法,使用自定义枚举类StatusCode*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JsonResult</span><span class="params">(StatusCode statusCode)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.code = statusCode.getCode();</span><br><span class="line">        <span class="built_in">this</span>.msg = statusCode.getMsg();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**构造方法3:适用于需要返回具体数据的Controller方法,使用自定义枚举类StatusCode*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JsonResult</span><span class="params">(StatusCode statusCode, Object data)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.code = statusCode.getCode();</span><br><span class="line">        <span class="built_in">this</span>.msg = statusCode.getMsg();</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**构造方法4:用于快速构建JsonResult对象,初始化3个属性:code msg data*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JsonResult</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.code = StatusCode.SUCCESS.getCode();</span><br><span class="line">        <span class="built_in">this</span>.msg = StatusCode.SUCCESS.getMsg();</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**2个静态方法,用于快速创建JsonResult对象</span></span><br><span class="line"><span class="comment">     * 一种是有返回数据data的;</span></span><br><span class="line"><span class="comment">     * 一种是无返回数据data的;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JsonResult <span class="title function_">ok</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JsonResult <span class="title function_">ok</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ok(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>controller</code>代码重构</strong></p>
<p>以 <code>UserController</code> 中的 <strong>注册功能</strong> 为例</p>
<p>对 <code>Controller</code>中的代码进行重构，将结果封装成 <code>JsonResult</code> 类型的结果，并返回给客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;注册功能&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;reg&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JsonResult <span class="title function_">reg</span><span class="params">(<span class="meta">@RequestBody</span> UserRegDTO userRegDTO)</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.确认用户名是否被占用</span></span><br><span class="line"><span class="comment">     * 2.注册用户</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    log.debug(<span class="string">&quot;userRegDTO = &quot;</span> + userRegDTO);</span><br><span class="line">    <span class="type">UserVO</span> <span class="variable">userVO</span> <span class="operator">=</span> userMapper.selectByUsername(userRegDTO.getUsername());</span><br><span class="line">    <span class="keyword">if</span> (userVO != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(<span class="number">1004</span>, <span class="string">&quot;用户名被占用&quot;</span>); <span class="comment">// 用户名被占用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    BeanUtils.copyProperties(userRegDTO, user);</span><br><span class="line">    user.setCreated(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    userMapper.insert(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(<span class="number">1001</span>, <span class="string">&quot;操作成功&quot;</span>); <span class="comment">// 注册成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 <code>Knife4j</code> 进行测试</strong></p>
<p>重启工程后，使用 <code>Knife4j</code> 进行测试</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309111130751.png" alt="image-20230530152603608"></p>
<p><strong>自定义枚举状态码</strong>(StatusCode)</p>
<p>1 简介</p>
<p>在Spring MVC中，一般通过HTTP响应状态码来表示请求是否成功。但是HTTP状态码的语义有时候比较笼统，不能够很好地表达业务逻辑。</p>
<p>为了解决这一问题，我们可以定义自己的状态码，将它们作为HTTP响应状态码的补充，以更加精准地表示请求的处理结果。</p>
<p>通常我们使用枚举类来定义自定义状态码，并且将它们应用到Spring MVC的实践中。</p>
<p>2 自定义枚举状态码</p>
<p>工程目录下创建 <code>common.response.StatusCode</code> 来自定义枚举状态码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">StatusCode</span> &#123;</span><br><span class="line">    <span class="comment">/**所有的实例都在最上面*/</span></span><br><span class="line">    SUCCESS(<span class="number">1</span>, <span class="string">&quot;OK&quot;</span>),</span><br><span class="line">    NOT_LOGIN(<span class="number">1000</span>,<span class="string">&quot;未登录&quot;</span>),</span><br><span class="line">    LOGIN_SUCCESS(<span class="number">1001</span>,<span class="string">&quot;登录成功&quot;</span>),</span><br><span class="line">    PASSWORD_ERROR(<span class="number">1002</span>, <span class="string">&quot;密码错误&quot;</span>),</span><br><span class="line">    USERNAME_ERROR(<span class="number">1003</span>, <span class="string">&quot;用户名错误&quot;</span>),</span><br><span class="line">    USERNAME_ALREADY_EXISTS(<span class="number">1004</span>, <span class="string">&quot;用户名已存在&quot;</span>),</span><br><span class="line">    OPERATION_SUCCESS(<span class="number">2001</span>, <span class="string">&quot;操作成功&quot;</span>),</span><br><span class="line">    OPERATION_FAILED(<span class="number">2002</span>, <span class="string">&quot;操作失败&quot;</span>),</span><br><span class="line">    VALIDATE_ERROR(<span class="number">3002</span>, <span class="string">&quot;参数校验失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3 使用自定义枚举状态码</p>
<p>3.1 <code>JsonResult</code> 构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">JsonResult</span><span class="params">(StatusCode statusCode)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.code = statusCode.getCode();</span><br><span class="line">    <span class="built_in">this</span>.msg = statusCode.getmsg();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">JsonResult</span><span class="params">(StatusCode statusCode, Object data)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.code = statusCode.getCode();</span><br><span class="line">    <span class="built_in">this</span>.msg = statusCode.getmsg();</span><br><span class="line">    <span class="built_in">this</span>.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.2 <code>controller</code> 代码重构</p>
<p><strong>注册功能</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用户名被占用</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(StatusCode.USERNAME_ALREADY_EXISTS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册成功</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(StatusCode.OPERATION_SUCCESS);</span><br></pre></td></tr></table></figure>

<p><strong>登录功能</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用户名错误</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(StatusCode.USERNAME_ERROR);</span><br><span class="line"></span><br><span class="line"><span class="comment">//登录成功</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(StatusCode.LOGIN_SUCCESS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//密码错误</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(StatusCode.PASSWORD_ERROR);</span><br></pre></td></tr></table></figure>

<h3 id="BeanUtils"><a href="#BeanUtils" class="headerlink" title="BeanUtils"></a><strong>BeanUtils</strong></h3><p><strong>简化数据封,用于封装JavaBean的</strong></p>
<p> <strong>JavaBean</strong>：标准的Java类</p>
<p><strong>要求</strong>：</p>
<blockquote>
<ol>
<li><p>类必须被public修饰</p>
</li>
<li><p>必须提供空参的构造器</p>
</li>
<li><p>成员变量必须使用private修饰</p>
</li>
<li><p>提供公共setter和getter方法</p>
</li>
</ol>
</blockquote>
<p><strong>功能</strong>：封装数据</p>
<ol>
<li><p>概念：</p>
<p>成员变量：</p>
<p>属性：setter和getter方法截取后的产物</p>
<p>例如：getUsername() –&gt; Username–&gt; username</p>
</li>
<li><p>方法：</p>
<ol>
<li><p>setProperty()(了解)(操作的是属性值,不是成员变量)</p>
</li>
<li><p>getProperty()(了解)</p>
</li>
<li><p>populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中(掌握)</p>
<p>属性值和成员变量的区别:</p>
<p>getter和setter去掉get和set后面的为属性,一般属性和成员变量设置为一样.</p>
</li>
</ol>
</li>
</ol>
<h3 id="全局Exception"><a href="#全局Exception" class="headerlink" title="全局Exception"></a>全局Exception</h3><p>Spring MVC中异常处理</p>
<p><strong>全局异常处理</strong></p>
<p>什么是全局异常处理器</p>
<p>全局异常处理器是Spring MVC框架中的一种异常处理机制，用于统一 <strong>处理由控制器抛出的异常</strong>。</p>
<p>全局异常处理器可以帮助我们捕获和处理控制器中的异常，并且可以根据不同的异常类型进行不同的处理操作，从而保障应用的健壮性和稳定性。</p>
<p>当然，Spring MVC中有内置的异常处理对象，但是呈现的结果对于用户端不友好，所以实际项目我们一般会使用全局异常处理器处理异常。</p>
<p><strong>全局异常处理器的配置</strong></p>
<p>Spring MVC中的全局异常处理器可以通过以下方式进行配置：</p>
<ol>
<li><p>创建 <code>exception.GlobalExceptionHandler</code>类，并添加异常处理方法；</p>
<p>使用 <code>@ControllerAdvice</code> 注解 或者 <code>@RestControllerAdvice</code> 注解标注该类；</p>
</li>
<li><p>在异常处理方法上添加 <code>@ExceptionHandler</code> 注解，用于指定控制器中需要处理的异常类型。</p>
</li>
</ol>
<p> <strong>使用流程</strong></p>
<p><strong>创建全局异常处理器类</strong></p>
<p>工程目录下创建 <code>exception.GlobalExceptionHandler</code></p>
<ul>
<li><p><code>@ControllerAdvice</code> 注解</p>
<p>定义全局异常处理器，处理Controller中抛出的异常。</p>
</li>
<li><p><code>@RestControllerAdvice</code> 注解</p>
<p>复合注解，是<code>@ControllerAdvice</code>注解和<code>@ResponseBody</code>注解的组合；</p>
<p>用于捕获Controller中抛出的异常并对异常进行统一的处理，还可以对返回的数据进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import cn.tedu.baking.commons.response.JsonResult;</span><br><span class="line">import cn.tedu.baking.commons.response.StatusCode;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.web.bind.MethodArgumentNotValidException;</span><br><span class="line">import org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line">import org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * ControllerAdvice注解: 标识当前的类为全局异常处理器类型;可以处理由控制器抛出的异常</span><br><span class="line"> *   1.如果Controller中抛出了异常,首先看是否定义了全局异常处理器;</span><br><span class="line"> *   2.如果定义了会在全局异常处理器中找对应的异常处理方法;</span><br><span class="line"> *   3.如果找到了对应的异常处理方法,则执行异常处理方法中的代码逻辑.</span><br><span class="line"> *</span><br><span class="line"> * RestControllerAdvice注解: 复合注解,相当于 @ResponseBody + @ControllerAdvise注解</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">//@ControllerAdvice</span><br><span class="line">@RestControllerAdvice</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    //捕获业务层异常</span><br><span class="line">    @ExceptionHandler</span><br><span class="line">    public JsonResult doHandleServiceException(ServiceException ex)&#123;</span><br><span class="line">        log.error(ex.getStatusCode().getMsg());</span><br><span class="line">        return new JsonResult(ex.getStatusCode());</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">      ExceptionHandler注解:表示方法为具体的异常处理方法;需要一个异常处理类型的形式参数;</span><br><span class="line">      1.优先查找该控制器异常对应的异常处理方法;</span><br><span class="line">      2.如果没有对应的异常处理方法,则会找父类的异常处理方法;(IllegalArgumentException  =&gt; RuntimeException)</span><br><span class="line">      3.如果没有父类的异常处理方法,则会走SpringMVC自己的异常处理机制;</span><br><span class="line">     */</span><br><span class="line">    @ExceptionHandler</span><br><span class="line">    public JsonResult doHandleRuntimeException(RuntimeException ex)&#123;</span><br><span class="line">        /*</span><br><span class="line">            &#123;&quot;code&quot;: 3001, &quot;msg&quot;: &quot;请求参数异常&quot;, &quot;data&quot;: &quot;微博ID值无效&quot;&#125;</span><br><span class="line">         */</span><br><span class="line">        log.error(&quot;RuntimeException is: &quot; + ex.getMessage());</span><br><span class="line">        return new JsonResult(StatusCode.VALIDATE_ERROR, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler</span><br><span class="line">    public JsonResult doHandleIllegalArgumentException(IllegalArgumentException ex)&#123;</span><br><span class="line">        log.error(&quot;IllegalArgumentException is: &quot; + ex.getMessage());</span><br><span class="line">        return new JsonResult(StatusCode.VALIDATE_ERROR, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 处理由 Spring Validation 框架抛出的异常</span><br><span class="line">     * @param ex 异常处理对象</span><br><span class="line">     * @return JsonResult</span><br><span class="line">     */</span><br><span class="line">    @ExceptionHandler</span><br><span class="line">    public JsonResult doHandleMethodArgumentNotValidException(MethodArgumentNotValidException ex)&#123;</span><br><span class="line">        /**</span><br><span class="line">         * Validation框架获取提示消息:ex.getFieldError().getDefaultMessage()</span><br><span class="line">         */</span><br><span class="line">        String message = ex.getFieldError().getDefaultMessage();</span><br><span class="line">        return new JsonResult(StatusCode.VALIDATE_ERROR, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Throwable:处理所有的异常;</span><br><span class="line">     *           其他异常处理方法无法处理的异常,都会交由此方法进行处理</span><br><span class="line">     *           一般会在最后,加上此异常处理方法;</span><br><span class="line">     *           一旦加完此方法,控制器中再也没有500状态码.</span><br><span class="line">     * @param ex 异常处理对象</span><br><span class="line">     * @return JsonResult</span><br><span class="line">     */</span><br><span class="line">    /*@ExceptionHandler</span><br><span class="line">    public JsonResult doHandleThrowableException(Throwable ex)&#123;</span><br><span class="line">        return new JsonResult(8888, &quot;Throwable异常!&quot;);</span><br><span class="line">    &#125;*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>service层异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import cn.tedu.baking.commons.response.StatusCode;</span><br><span class="line">import lombok.Getter;</span><br><span class="line"></span><br><span class="line">public class ServiceException extends RuntimeException&#123;</span><br><span class="line">    @Getter</span><br><span class="line">    private StatusCode statusCode;</span><br><span class="line"></span><br><span class="line">    public ServiceException(StatusCode statusCode) &#123;</span><br><span class="line">        this.statusCode = statusCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>创建异常处理方法</strong></p>
<p>在异常处理方法上添加 <code>@ExceptionHandler</code> 注解</p>
<ul>
<li><p><code>@ExceptionHandler</code> 注解</p>
<p>用于捕获Controller处理请求时抛出的异常，并进行统一的处理。</p>
</li>
<li><p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ex.getMessage()方法：用于捕获异常信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span></span><br><span class="line"><span class="keyword">public</span> JsonResult <span class="title function_">doHandleRuntimeException</span><span class="params">(RuntimeException ex)</span>&#123;</span><br><span class="line">    log.error(<span class="string">&quot;error is &quot;</span> + ex.getMessage());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(StatusCode.OPERATION_FAILED,ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>全局异常处理器示例</strong></p>
<p>微博详情页异常抛出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> JsonResult <span class="title function_">selectById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;id值无效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>全局异常处理</strong></p>
<p><code>exception.GlobalExceptionHandler</code> 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.weibo.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.tedu.weibo.common.response.JsonResult;</span><br><span class="line"><span class="keyword">import</span> cn.tedu.weibo.common.response.StatusCode;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RestControllerAdvice 是复合注解，描述的类型为一个全局异常处理对象类型,</span></span><br><span class="line"><span class="comment"> * 等价于：<span class="doctag">@ControllerAdvice</span>+<span class="doctag">@ResponseBody</span></span></span><br><span class="line"><span class="comment"> * 当某个Controller方法中出现了异常，系统底层就会查找有没有定义全局异常处理对象。</span></span><br><span class="line"><span class="comment"> * 这个全局异常处理对象中有没有定义对应的异常处理方法，假如有就调用此方法处理异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@ExceptionHandler</span> 描述的方法为一个异常处理方法，在此注解内部可以定义具体的异常处理</span></span><br><span class="line"><span class="comment">     *  类型(例如RuntimeException),此注解描述的方法需要定义一个异常类型的形式参数，</span></span><br><span class="line"><span class="comment">     *  通过这个参数接收具体的异常对象(也可以接收其异常类型对应的子类类型的异常)。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> JsonResult <span class="title function_">doHandleRuntimeException</span><span class="params">(RuntimeException ex)</span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;error is &quot;</span> + ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(StatusCode.OPERATION_FAILED,ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 假如用全局异常处理对象处理Controller类中出现的异常，全局异常处理对象会优先查找与Controller</span></span><br><span class="line"><span class="comment">     * 中相匹配的异常处理方法，假如没有，会查找对应异常的父类异常处理方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> JsonResult <span class="title function_">doHandleRuntimeException</span><span class="params">(IllegalArgumentException ex)</span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;IllegalArgumentException is &quot;</span> + ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(StatusCode.OPERATION_FAILED,ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关于Throwable</strong> </p>
<p>在开发实践中，通常会添加一个处理<code>Throwable</code>的方法，它将可以处理所有类型的异常，则不会再出现<code>500</code>错误！</p>
<p><code>GlobalExceptionHandler</code>中添加处理 Throwable 的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span></span><br><span class="line"><span class="keyword">public</span> JsonResult <span class="title function_">handleThrowable</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(<span class="number">8888</span>, <span class="string">&quot;程序运行过程中出现了Throwable&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Spring-Validation"><a href="#Spring-Validation" class="headerlink" title="Spring Validation"></a>Spring Validation</h3><p><strong>关于Spring Validation</strong></p>
<p>在实际项目我们需要对客户端传递到服务端的参数进行校验，用于判定请求参数的合法性，假如请求参数不合法则不可以再去执行后续的业务了。那如何校验呢？</p>
<p>一种方式是我们在控制层方法中每次都自己进行参数有效值的判断，不合法可以抛出异常，但是工作量和代码复杂度会比较高；</p>
<p>第二种方式就是采用市场上主流的 <code>Spring Validation</code> 框架去实现校验，所以 <code>Spring Validation</code> 框架的主要作用是  检查参数的基本有效性。</p>
<p><strong>使用流程</strong></p>
<p>在Spring Boot工程中，使用此框架需要添加依赖，并刷新maven</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Boot支持Spring Validation的依赖项，用于检查参数的基本有效性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>快速入门</strong></p>
<ol>
<li><p>在处理请求的方法的参数列表中，在POJO类型的参数上添加<code>@Validated</code>注解，表示需要通过Spring Validation框架检查此参数，例如UserController中注册功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;注册功能&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;reg&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JsonResult <span class="title function_">reg</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated</span> UserRegDTO userRegDTO)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在此POJO类中的属性上，添加对应的检查注解，以配置检查规则，</p>
<p>例如，添加<code>@NotNull</code>注解，就表示“不允许为<code>null</code>”的规则！</p>
<p>在<code>UserRegDTO</code>类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegDTO</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;用户名&quot;, required = true, example = &quot;赵丽颖&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;密码&quot;, required = true, example = &quot;123456&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;昵称&quot;, required = true, example = &quot;萤火虫&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>重启工程，在Knife4j中测试，当提交请求时，如果username参数为 <code>null</code>，服务器端将响应<code>400</code>错误。</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309151711453.png" alt="image-20230915171114351"></p>
<p><strong>同时在终端也会出现异常</strong></p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309151711575.png" alt="image-20230915171130474"></p>
</li>
</ol>
<p><strong>运行异常处理</strong></p>
<p><strong>说明</strong></p>
<p>在使用Spring Validation框架执行参数的检查时，如果检查不通过，除了响应<code>400</code>错误以外，在控制台还会抛出错误：<font color=red><code>MethodArgumentNotValidException</code> 使用全局异常处理器解决。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[org.springframework.web.bind.MethodArgumentNotValidException: Validation failed <span class="keyword">for</span> argument [<span class="number">0</span>] in <span class="keyword">public</span> cn.tedu._043mvcweibo.common.response.JsonResult cn.tedu._043mvcweibo.controller.UserController.reg(cn.tedu._043mvcweibo.pojo.dto.UserRegDTO): [Field error in object <span class="string">&#x27;userRegDTO&#x27;</span> on field <span class="string">&#x27;username&#x27;</span>: rejected value [<span class="literal">null</span>]; codes [NotNull.userRegDTO.username,NotNull.username,NotNull.java.lang.String,NotNull]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [userRegDTO.username,username]; arguments []; <span class="keyword">default</span> message [username]]; <span class="keyword">default</span> message [不能为<span class="literal">null</span>]] ]</span><br></pre></td></tr></table></figure>



<p><strong>处理异常</strong></p>
<p><strong>使用全局异常处理器来处理 <code>MethodArgumentNotValidException</code> 异常</strong></p>
<p>第1步：全局异常处理器 <code>GlobalExceptionHandler</code> 中定义处理异常方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span></span><br><span class="line"><span class="keyword">public</span> JsonResult <span class="title function_">doHandleMethodArgumentNotValidException</span><span class="params">(MethodArgumentNotValidException ex)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(<span class="number">3002</span>, <span class="string">&quot;请求参数错误&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>第2步：重启工程，在Knife4j中测试</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309151713381.png" alt="image-20230915171339310"></p>
<p><strong>明确提示消息</strong></p>
<p>当提交的<code>username</code>的值为 null 时，可以发现异常已被处理！</p>
<p>但是，处理结果并不合适，因为，客户端得到此结果后，仍无法明确出现了什么错误！</p>
<p>所有的检查注解都可以配置<code>message</code>参数，用于对错误进行描述。</p>
<p>第1步：<code>@NotNull</code> 注解中添加 <code>message</code> 参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotNull(message = &quot;必须提交用户名&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br></pre></td></tr></table></figure>



<p>第2步：自定义枚举状态码 <code>StatusCode</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">VALIDATE_ERROR(<span class="number">3002</span>, <span class="string">&quot;参数校验失败&quot;</span>)</span><br></pre></td></tr></table></figure>



<p>第3步：异常方法中获取提示信息 <code>message</code></p>
<p>在处理异常时，需要调用<code>MethodArgumentNotValidException</code>对象的<code>getFieldError().getDefaultMessage()</code>获取以上配置的描述文本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span></span><br><span class="line"><span class="keyword">public</span> JsonResult <span class="title function_">handleBindException</span><span class="params">(MethodArgumentNotValidException ex)</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       ex.getFieldError().getDefaultMessage():获取 @NotNull(message=&quot;xxx&quot;) 中message的消息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> ex.getFieldError().getDefaultMessage();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(StatusCode.VALIDATE_ERROR, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>第3步：重启工程，在Knife4j中测试</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309151714054.png" alt="image-20230915171453978"></p>
<p><strong>常用注解</strong></p>
<p><strong><code>@NotNull</code>注解</strong></p>
<ul>
<li><p>作用：用于验证对象是否为 null</p>
</li>
<li><p>用法：<code>@NotNull</code> 注解用于对象类型上</p>
</li>
<li><p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotNull(message = &quot;用户名不能为null&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br></pre></td></tr></table></figure></li>
<li><p><em><code>@NotEmpty</code> 注解</em>*</p>
</li>
<li><p>作用：用于验证字符串是否为空，并且会检查是否为 null 值（为null值时报错）</p>
</li>
<li><p>用法：用于字符串类型上</p>
</li>
<li><p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotEmpty(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>@NotBlank</code> 注解</strong></p>
<ul>
<li><p>作用：不允许为空白，即不允许是“仅由空格、TAB等空白值组成的字符串”，也不允许为空字符串，也不允许为空值null</p>
</li>
<li><p>用法：用于字符串类型上</p>
</li>
<li><p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotBlank(message = &quot;用户名不能为空白串&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>@Size</code> 注解</strong></p>
<ul>
<li><p>作用：可以指定最小值和最大值限制字符串的长度</p>
</li>
<li><p>用法：用于字符串类型参数</p>
</li>
<li><p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Size(min = 6, max = 20, message = &quot;用户名长度必须在6到20之间&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong><code>@Range</code> 注解</strong></p>
<ul>
<li><p>作用：用于验证数字类型字段的取值范围，通过配置min和max属性来限制数值类型参数的值区间包括最小值和最大值</p>
</li>
<li><p>用法：用于数值类型参数</p>
</li>
<li><p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Range(min = 1, max = 10, message = &quot;年龄必须在1-10岁之间&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Range(min = 0.1, max = 1.0, message = &quot;成绩必须在0.1到1.0之间&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> score;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>非POJO参数校验</strong></p>
<p>在 Spring Validation 中，除了对 POJO（Plain Old Java Object）进行校验的功能外，还支持对非 POJO 进行校验，比如 String、Integer、Double 等类型的参数。</p>
<p><strong>使用流程</strong></p>
<ul>
<li><font color=red><strong>在当前方法所在的类上添加 <code>@Validated</code> 注解</strong></font></li>
<li>在参数上添加对应的检查注解</li>
</ul>
<p><strong>使用示例</strong></p>
<p>对于微博详情页的 id 参数进行范围校验，范围只能在1-10之间</p>
<p>第1步：在类 <code>WeiboController</code> 中添加 <code>@Validated</code> 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeiboController</span> &#123;&#125;</span><br></pre></td></tr></table></figure>



<p>第2步：在控制器方法参数 <code>id</code> 上添加对应的检查注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> JsonResult <span class="title function_">selectById</span><span class="params">(<span class="meta">@Range(min = 1, max=10, message = &quot;请提交合法的ID值！&quot;)</span> <span class="meta">@RequestParam</span> <span class="type">int</span> id, String username)</span></span><br></pre></td></tr></table></figure>



<p>第3步：重启工程，在Knife4j或者浏览器中测试</p>
<h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><p>继承和聚合</p>
<p>父工程包含多个子工程  父工程打包方式为pom 子工程为jar</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309161441058.png" alt="image-20230916144155959"></p>
<p>项目开发通常是分组分模块开发,最终打包成一个独立的Jar包运行</p>
<p><strong>Maven私服:nexus</strong></p>
<p>公司在自己的局域网内搭建自己的远程仓库服务器，称为私服，私服服务器即是公司内<br>部的 maven 远程仓库，每个员工的电脑上安装 maven 软件并且连接私服服务器，员工将自<br>己开发的项目打成 jar 并发布到私服服务器，其它项目组从私服服务器下载所依赖的构件<br>（jar）。<br>私服还充当一个代理服务器，当私服上没有 jar 包会从互联网中央仓库自动下载，如下<br>图：</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309161511274.png" alt="image-20230916151150229"></p>
<p><strong>搭建私服:</strong></p>
<p>访问地址:<a target="_blank" rel="noopener" href="http://localhost:8081/nexus/">http://localhost:8081/nexus/</a></p>
<p>使用 Nexus 内置账户admin/admin123 登陆：</p>
<p><img src="/img/loading.gif" data-original="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309161540342.png" alt="image-20230916154001253"></p>
<p>把项目发布到私服</p>
<p>从私服下载jar包</p>
<h3 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a><strong>SpringCloud</strong></h3><p>Spring Cloud是一个用于构建分布式系统的开源框架，它基于Spring框架，提供了一系列的工具和组件，以简化分布式系统开发的复杂性。它提供了诸如服务注册与发现、客户端负载均衡、声明式服务调用、容错处理、API网关、配置管理等功能</p>
<p>2.1 Eureka</p>
<ul>
<li>服务注册与发现组件，用于实现微服务架构中的服务发现。</li>
<li>可以将所有微服务的实例注册到Eureka Server上，从而实现服务的自动发现。</li>
<li>通过Eureka可以轻松实现服务的高可用性，当服务实例发生故障时，能够自动剔除不可用实例。</li>
</ul>
<p>2.2 Ribbon</p>
<ul>
<li>客户端负载均衡组件，用于实现微服务架构中的客户端负载均衡。</li>
<li>可以实现根据一定的策略从一组实例中选择一个可用的服务进行调用。</li>
</ul>
<p>2.3 Feign</p>
<ul>
<li>声明式服务调用组件，用于实现微服务架构中的服务间通讯。</li>
<li>可以通过简单的注解方式来定义服务接口，Feign会自动处理服务的调用细节，开发者只需要关注业务逻辑。</li>
</ul>
<p>2.4 Hystrix</p>
<ul>
<li>容错管理组件，用于实现微服务架构中的容错处理。</li>
<li>可以实现服务降级、熔断、限流等功能，提高系统的可靠性和稳定性。</li>
</ul>
<p>2.5 Zuul</p>
<ul>
<li>API网关组件，用于实现微服务架构中的统一访问入口。</li>
<li>可以实现路由转发、请求过滤、服务聚合等功能，简化了客户端和服务端的通讯。</li>
</ul>
<p>2.6 Config</p>
<ul>
<li>配置管理组件，用于实现微服务架构中的配置中心。</li>
<li>可以集中管理配置文件，并可以实现配置的动态刷新。</li>
</ul>
<p><strong>Spring Cloud示例项目</strong></p>
<p>3.1 创建一个新的Spring Boot项目</p>
<ul>
<li>使用Spring Initializr创建一个新的Spring Boot项目，选择所需的组件和依赖。</li>
</ul>
<p>3.2 引入Spring Cloud相关依赖</p>
<ul>
<li>在项目的pom.xml文件中引入所需的Spring Cloud相关依赖，例如Eureka、Ribbon、Feign、Hystrix、Zuul和Config等。</li>
</ul>
<p>3.3 编写一个简单的服务</p>
<ul>
<li>创建一个示例的微服务，并实现一个简单的功能接口。</li>
</ul>
<p>3.4 配置Eureka服务注册与发现</p>
<ul>
<li>在项目的配置文件中配置Eureka的相关信息，包括注册中心的地址和服务的名称。</li>
</ul>
<p>3.5 配置Ribbon负载均衡</p>
<ul>
<li>在服务调用的代码中使用Ribbon来调用其他服务，并配置负载均衡的策略。</li>
</ul>
<p>3.6 使用Feign进行服务调用</p>
<ul>
<li>在服务调用的代码中使用Feign来声明式地调用其他服务。</li>
</ul>
<p>3.7 实现容错处理</p>
<ul>
<li>使用Hystrix来处理服务调用失败、超时等异常情况，实现服务的容错处理。</li>
</ul>
<p>3.8 配置API网关</p>
<ul>
<li>使用Zuul来配置API网关，实现统一的访问入口、路由转发和请求过滤等功能。</li>
</ul>
<p>3.9 配置配置管理</p>
<ul>
<li>使用Config来配置配置中心，将配置文件集中管理，并实现配置的动态刷新。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://dengliantong.cn">Xing Deng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://dengliantong.cn/2023/09/19/SSM%E6%A1%86%E6%9E%B6/">http://dengliantong.cn/2023/09/19/SSM%E6%A1%86%E6%9E%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://dengliantong.cn" target="_blank">互联网新贵邓醒</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SSM/">SSM</a></div><div class="post_share"><div class="social-share" data-image="https://images3.alphacoders.com/103/103237.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/20/Java%E5%9F%BA%E7%A1%80/" title="Java基础"><img class="cover" src="/img/loading.gif" data-original="https://images6.alphacoders.com/337/337255.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java基础</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/12/Oracle-EBS-R12-%E9%87%87%E8%B4%AD%E5%88%B0%E5%BA%94%E4%BB%98%E4%BA%A7%E7%94%9F%E7%9A%84%E4%BC%9A%E8%AE%A1%E5%88%86%E5%BD%95/" title="Oracle EBS R12 采购到应付产生的会计分录"><img class="cover" src="/img/loading.gif" data-original="https://images6.alphacoders.com/337/337255.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Oracle EBS R12 采购到应付产生的会计分录</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xing Deng</div><div class="author-info__description">起风了,唯有努力生存!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/waFroppy"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome To My Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#SSM%E6%A1%86%E6%9E%B6"><span class="toc-text">SSM框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot"><span class="toc-text">SpringBoot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring"><span class="toc-text">Spring</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mybatis"><span class="toc-text">Mybatis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC"><span class="toc-text">SpringMVC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RESTful"><span class="toc-text">RESTful</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON"><span class="toc-text">JSON</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lombok"><span class="toc-text">Lombok</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Knife4j"><span class="toc-text">Knife4j</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JsonResult"><span class="toc-text">JsonResult</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanUtils"><span class="toc-text">BeanUtils</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80Exception"><span class="toc-text">全局Exception</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Validation"><span class="toc-text">Spring Validation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maven"><span class="toc-text">Maven</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringCloud"><span class="toc-text">SpringCloud</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/09/20/JavaWeb/" title="JavaWeb"><img src="/img/loading.gif" data-original="https://images.alphacoders.com/484/484614.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaWeb"/></a><div class="content"><a class="title" href="/2023/09/20/JavaWeb/" title="JavaWeb">JavaWeb</a><time datetime="2023-09-20T01:39:10.000Z" title="发表于 2023-09-20 09:39:10">2023-09-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/20/Java%E5%9F%BA%E7%A1%80/" title="Java基础"><img src="/img/loading.gif" data-original="https://images6.alphacoders.com/337/337255.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础"/></a><div class="content"><a class="title" href="/2023/09/20/Java%E5%9F%BA%E7%A1%80/" title="Java基础">Java基础</a><time datetime="2023-09-20T01:38:45.000Z" title="发表于 2023-09-20 09:38:45">2023-09-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/19/SSM%E6%A1%86%E6%9E%B6/" title="SSM框架"><img src="/img/loading.gif" data-original="https://images3.alphacoders.com/103/103237.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SSM框架"/></a><div class="content"><a class="title" href="/2023/09/19/SSM%E6%A1%86%E6%9E%B6/" title="SSM框架">SSM框架</a><time datetime="2023-09-19T07:55:40.000Z" title="发表于 2023-09-19 15:55:40">2023-09-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/12/Oracle-EBS-R12-%E9%87%87%E8%B4%AD%E5%88%B0%E5%BA%94%E4%BB%98%E4%BA%A7%E7%94%9F%E7%9A%84%E4%BC%9A%E8%AE%A1%E5%88%86%E5%BD%95/" title="Oracle EBS R12 采购到应付产生的会计分录"><img src="/img/loading.gif" data-original="https://images6.alphacoders.com/337/337255.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Oracle EBS R12 采购到应付产生的会计分录"/></a><div class="content"><a class="title" href="/2023/06/12/Oracle-EBS-R12-%E9%87%87%E8%B4%AD%E5%88%B0%E5%BA%94%E4%BB%98%E4%BA%A7%E7%94%9F%E7%9A%84%E4%BC%9A%E8%AE%A1%E5%88%86%E5%BD%95/" title="Oracle EBS R12 采购到应付产生的会计分录">Oracle EBS R12 采购到应付产生的会计分录</a><time datetime="2023-06-12T00:58:47.000Z" title="发表于 2023-06-12 08:58:47">2023-06-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/10/Oracle-EBS-R12-%E6%8E%A5%E5%8F%A3%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/" title="Oracle EBS R12 接口参考文档"><img src="/img/loading.gif" data-original="https://images.alphacoders.com/484/484614.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Oracle EBS R12 接口参考文档"/></a><div class="content"><a class="title" href="/2023/06/10/Oracle-EBS-R12-%E6%8E%A5%E5%8F%A3%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/" title="Oracle EBS R12 接口参考文档">Oracle EBS R12 接口参考文档</a><time datetime="2023-06-10T02:53:52.000Z" title="发表于 2023-06-10 10:53:52">2023-06-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://images3.alphacoders.com/103/103237.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Xing Deng</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>