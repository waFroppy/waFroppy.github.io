<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Oracle EBS R12 DBA | 互联网新贵邓醒</title><meta name="author" content="Xing Deng"><meta name="copyright" content="Xing Deng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Oracle 索引的作用以及失效的情况表索引是Oracle数据库中的一种面向查询的数据结构，用于加速查询操作，提高查询性能。索引可以理解为一个指向表中记录的指针列表，通过在查询时查找这些指针，可以快速定位符合条件的记录，避免全表扫描，从而提高查询效率。 索引的作用：  提高查询速度：索引通过快速地查找和访问表中符合特定条件的数据来加快 SQL 查询的速度。 优化查询计划：索引可以帮助数据库优化器确">
<meta property="og:type" content="article">
<meta property="og:title" content="Oracle EBS R12 DBA">
<meta property="og:url" content="http://dengliantong.cn/2023/06/03/Oracle-EBS-R12-DBA/index.html">
<meta property="og:site_name" content="互联网新贵邓醒">
<meta property="og:description" content="Oracle 索引的作用以及失效的情况表索引是Oracle数据库中的一种面向查询的数据结构，用于加速查询操作，提高查询性能。索引可以理解为一个指向表中记录的指针列表，通过在查询时查找这些指针，可以快速定位符合条件的记录，避免全表扫描，从而提高查询效率。 索引的作用：  提高查询速度：索引通过快速地查找和访问表中符合特定条件的数据来加快 SQL 查询的速度。 优化查询计划：索引可以帮助数据库优化器确">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images6.alphacoders.com/337/337255.jpg">
<meta property="article:published_time" content="2023-06-03T08:49:58.000Z">
<meta property="article:modified_time" content="2023-06-17T00:18:19.834Z">
<meta property="article:author" content="Xing Deng">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images6.alphacoders.com/337/337255.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://dengliantong.cn/2023/06/03/Oracle-EBS-R12-DBA/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Oracle EBS R12 DBA',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-17 08:18:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://images6.alphacoders.com/337/337255.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="互联网新贵邓醒"><span class="site-name">互联网新贵邓醒</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Oracle EBS R12 DBA</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-03T08:49:58.000Z" title="发表于 2023-06-03 16:49:58">2023-06-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-17T00:18:19.834Z" title="更新于 2023-06-17 08:18:19">2023-06-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>55分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Oracle EBS R12 DBA"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="Oracle-索引的作用以及失效的情况"><a href="#Oracle-索引的作用以及失效的情况" class="headerlink" title="Oracle 索引的作用以及失效的情况"></a>Oracle 索引的作用以及失效的情况</h4><p>表索引是Oracle数据库中的一种面向查询的数据结构，用于加速查询操作，提高查询性能。索引可以理解为一个指向表中记录的指针列表，通过在查询时查找这些指针，可以快速定位符合条件的记录，避免全表扫描，从而提高查询效率。</p>
<p><strong>索引的作用：</strong></p>
<ol>
<li>提高查询速度：索引通过快速地查找和访问表中符合特定条件的数据来加快 SQL 查询的速度。</li>
<li>优化查询计划：索引可以帮助数据库优化器确定最优的查询计划，降低查询复杂度，提高查询效率。</li>
<li>提高数据完整性：索引可以保证表中数据的唯一性和约束完整性，对于频繁更新的表尤为重要。</li>
<li>支持连接操作：索引可以帮助数据库支持连接操作，以提高查询效率。</li>
</ol>
<p>索引（Index）是 Oracle 数据库中用于加快数据检索速度的一种数据结构。它通过在数据库表中创建一个或多个索引来加速查询，并且可以提高 SQL 语句执行的效率。下面是索引的作用和失效的情况：</p>
<p><strong>索引失效的情况：</strong></p>
<ol>
<li>数据分布不均匀：索引失效的一个主要原因是数据分布不均匀。例如，如果表中某一列的值非常少时，使用索引可能比全表扫描更慢。</li>
<li>像操作非常频繁的表：如果一个表的操作频率非常高，那么建立索引会使得更新数据的成本极高，会降低整体的性能。</li>
<li>查询条件不在索引的列上：如果查询条件不在索引列上，则索引可能不起作用。在这种情况下，数据库可能会忽略索引，进行全表扫描，这将极大地降低性能。</li>
<li>使用函数处理查询条件：如果查询条件使用函数处理，则索引可能会失效。例如，如果查询条件为 <code>to_char(date_col,&#39;dd-mm-yyyy&#39;)=&#39;01-01-2022&#39;</code>，则索引上的 <code>date_col</code> 列可能会失效，因为查询条件需要进行函数处理。</li>
<li>数据量太小：在低记录数的表上创建索引是没有必要的，因为索引增加了开销和维护时间，而带来的好处相对较少。</li>
</ol>
<p>综上所述，要正确选择和使用索引来提高数据库的性能，需要根据具体的情况，进行测试和选择最优策略。</p>
<h4 id="Oracle-报文"><a href="#Oracle-报文" class="headerlink" title="Oracle 报文"></a>Oracle 报文</h4><p>对于开发报文，需要根据具体的应用场景和技术要求来确定，因此需要提供更详细的上下文。一般而言，开发报文可以分为前端和后端两部分，其中前端报文主要指前端请求后端的数据格式和数据内容，后端报文则指后端响应前端请求的数据格式和数据内容。下面是一个简单的示例：</p>
<ul>
<li>前端报文：采用 HTTP GET 请求方式，请求获取用户列表数据，请求 URL 为 <a target="_blank" rel="noopener" href="http://example.com/api/user/list%EF%BC%8C%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%8C%85%E5%90%AB%E4%BB%A5%E4%B8%8B%E5%86%85%E5%AE%B9%EF%BC%9A">http://example.com/api/user/list，请求参数包含以下内容：</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;pageIndex&quot;: 1,</span><br><span class="line">   &quot;pageSize&quot;: 10,</span><br><span class="line">   &quot;sortField&quot;: &quot;name&quot;,</span><br><span class="line">   &quot;sortOrder&quot;: &quot;asc&quot;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>后端报文：后端通过解析前端请求参数，在数据库中查询符合条件的用户列表，并通过 JSON 格式返回给前端，示例响应报文如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;success&quot;: true,</span><br><span class="line">   &quot;message&quot;: null,</span><br><span class="line">   &quot;data&quot;: &#123;</span><br><span class="line">       &quot;total&quot;: 50,</span><br><span class="line">       &quot;pageIndex&quot;: 1,</span><br><span class="line">       &quot;pageSize&quot;: 10,</span><br><span class="line">       &quot;list&quot;: [</span><br><span class="line">           &#123;</span><br><span class="line">               &quot;id&quot;: 1,</span><br><span class="line">               &quot;name&quot;: &quot;Tom&quot;,</span><br><span class="line">               &quot;gender&quot;: &quot;male&quot;,</span><br><span class="line">               &quot;age&quot;: 25</span><br><span class="line">           &#125;,</span><br><span class="line">           &#123;</span><br><span class="line">               &quot;id&quot;: 2,</span><br><span class="line">               &quot;name&quot;: &quot;Jane&quot;,</span><br><span class="line">               &quot;gender&quot;: &quot;female&quot;,</span><br><span class="line">               &quot;age&quot;: 30</span><br><span class="line">           &#125;,</span><br><span class="line">           ...</span><br><span class="line">       ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，开发报文通常需要按照特定的技术规范或者标准进行设计，例如 RESTful API、GraphQL 等标准，以方便不同系统之间的交互和集成。</p>
<h4 id="Oracle-临时表"><a href="#Oracle-临时表" class="headerlink" title="Oracle 临时表"></a>Oracle 临时表</h4><p>一、存储空间</p>
<p>Oracle临时表不占用表空间，如果临时表（包括临时表的索引）没有指定表空间，那么插入临时表的数据会存放在临时表空间（TEMP）。</p>
<p>二、两种类型</p>
<p>Oracle临时表有两种类型：一种是会话级临时表，另一种是事物级临时表。</p>
<p>2.1、会话级临时表（SESSION）</p>
<p>临时表中的数据与会话相关，当前会话不退出临时表中的数据就存在，当前会话退出临时表中的数据就会截断（相当于 truncate table 当前会话的数据）。</p>
<p>一个会话看不到另外一个会话插入临时表中的数据，即两个不同会话的数据是互不干扰的。</p>
<p>创建会话级临时表语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE GLOBAL TEMPORARY TABLE table_name</span><br><span class="line"></span><br><span class="line">(col1 type1,col2 type2...) </span><br><span class="line"></span><br><span class="line">ON COMMIT PRESERVE ROWS;</span><br></pre></td></tr></table></figure>



<p>2.2、事务级临时表</p>
<p>临时表中的数据与事务相关，当进行事务提交（commit）或事务回滚（rollback）时，临时表中的数据就会截断（相当于 truncate table 当前事务的数据）。</p>
<p>其他功能与会话级临时表一致（包括退出会话时，事务级临时表也会截断）。</p>
<p>创建事务级临时表语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE GLOBAL TEMPORARY TABLE table_name</span><br><span class="line"></span><br><span class="line">(col1 type1,col2 type2...)</span><br><span class="line"></span><br><span class="line">ON COMMIT DELETE ROWS;</span><br></pre></td></tr></table></figure>

<p>2.3、两种类型临时表的区别</p>
<p>（1）建表语法上，会话级临时表采用 ON COMMIT PRESERVE ROWS，而事务级临时表采用 ON COMMIT DELETE ROWS。</p>
<p>（2）用法上，会话级临时表只有当会话结束时，临时表中的数据才会被截断；而事务级临时表不管是事务提交（commit）、事务回滚（rollback）还是会话结束，临时表中的数据都会被截断</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Create table</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">global</span> temporary <span class="keyword">table</span> CUX.WIP_GA_AUTOTXN_JOBS_TEMP</span><br><span class="line">(</span><br><span class="line">  organization_id          NUMBER,</span><br><span class="line">  inventory_item_id        NUMBER,</span><br><span class="line">  item_number              VARCHAR2(<span class="number">40</span>),</span><br><span class="line">  description              VARCHAR2(<span class="number">240</span>),</span><br><span class="line">  item_revision            VARCHAR2(<span class="number">3</span>),</span><br><span class="line">  uom_code                 VARCHAR2(<span class="number">3</span>),</span><br><span class="line">  demand_quantity          NUMBER,</span><br><span class="line">  supply_subinventory      VARCHAR2(<span class="number">10</span>),</span><br><span class="line">  supp_subinv_quantity     NUMBER,</span><br><span class="line">  plan_issue_quantity      NUMBER,</span><br><span class="line">  material_subinventory    VARCHAR2(<span class="number">10</span>),</span><br><span class="line">  material_subinv_quantity NUMBER,</span><br><span class="line">  min_pack_mod             NUMBER,</span><br><span class="line">  lack_quantity            NUMBER,</span><br><span class="line">  txn_quantity             NUMBER</span><br><span class="line">)</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">commit</span> preserve <span class="keyword">rows</span>;</span><br><span class="line"><span class="comment">-- Create/Recreate indexes </span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index CUX.WIP_GA_AUTOTXN_JOBS_TEMP_U1 <span class="keyword">on</span> CUX.WIP_GA_AUTOTXN_JOBS_TEMP (ORGANIZATION_ID, INVENTORY_ITEM_ID);</span><br></pre></td></tr></table></figure>

<h4 id="Oracle-GoldenGate"><a href="#Oracle-GoldenGate" class="headerlink" title="Oracle GoldenGate"></a>Oracle GoldenGate</h4><p>Oracle GoldenGate (OGG)是一种可靠的高性能数据复制和数据实时同步解决方案，可以在异构数据库和平台之间复制或同步数据。OGG可以将源数据库中的原始数据复制到目标数据库中，同时还可以实时捕获更改并将其应用于目标数据库，这使得用户可以实时访问最新的数据。OGG还支持一些高级功能，如数据筛选、数据转换和数据加密等，可以满足不同用户的需求。</p>
<h4 id="Oracle-DatabaseLink"><a href="#Oracle-DatabaseLink" class="headerlink" title="Oracle DatabaseLink"></a>Oracle DatabaseLink</h4><p>Database Link ，我们习惯称为db link。</p>
<p>作用：用于从a数据库到b数据库之间访问的一种手段。类似于 ogg 中的表同步（用户同步）。如上所述，dblink 的主要作用是跨库查询。</p>
<p>有很多业务都需要进行跨库查询。在我们公司有时就不得不去去创建一些dblink。 </p>
<p>优点：创建方式简单、易懂、可以拥有创建用户的所有权限。</p>
<p>缺点：自然，方便的手段就会有更多的不利。</p>
<p>1 大量消耗数据库资源；本地系统每通过DBLINK链接远端系统一次，都会生成一个本地session，如本地session不退出或者手动释放，只有通过session超时才能自动释放，会浪费大量的系统资源</p>
<p>2 容易出现数据库BUG：大量使用DBLINK，本地系统极易出现ORA-02068、ORA-03113、ORA-02080、ORA-02054、ORA-02050等ORACLE错误，这种错误大部分会影响当前session正在处理的业务</p>
<p>3 性能较差：由于使用DBLINK，本地系统在获取数据时，每次链接都会对远端数据库进行一次全表扫描，且所有数据都会传输回本地数据库内，导致性能降低并且严重浪费当前系统资源。尤其出现一条sql语句从两个DBLINK中取数，更被称之为“性能杀手”，尤其是OLTP型数据库</p>
<p>4 数据传输不稳定，占用带宽严重，容易产生丢包风险：DBLINK本身没有数据存储、监控等功能，是通过网络中的数据库进行传输时，如果在传输过程中出现数据丢包现象，DBLINK本身不会发现，只用当业务进行完毕才能发现丢包现象，这样会影响当前正在处理的业务；另外，通过DBLINK查询的数据会像数据全部传至本地数据库进行操作，数据传输量很大，占用带宽严重，可能会导致网络堵塞</p>
<p>5 Oracle数据功能受限：DBLINK本身不支持对oracle LOB大对象的操作，在使用PROCDURE时，使用COMMIT等操作时可能会出现错误</p>
<p>6 可扩展性较差：如果多系统之间 使用DBLINK进行传输，每增加一个系统，都会增加一个或多个DBLINK链接或者修改对应的接口程序，如果修改其中一个接口，需要修改所有关联系统内的接口程序</p>
<p>7 维护性差、安全性较低：通过DBLINK进行链接需要将远端数据库用户名、密码、IP地址存在本地数据库，如远端进行密码修改、IP地址变更，本地数据库也需要修改，如果系统较多，每个系统都需要同时修改。切本地数据库管理员能够看到远端数据的密码、IP地址，对系统安全产生影响</p>
<p>可是，即使是在缺点这么这么多的情况下，还是会有人用，归根到底，个人感觉还是oracle对两个库之间的交互做的并不是特别好，OGG 好用是好用，但是在表多的情况下，我们可是深受其害。</p>
<p>用法：创建dblink的先决条件便是两个库要能交互（local database to remote database）网络要能连接正常，其次。要在源端数据库tnsname 文件中配置上访问目标的参数。并且能 tnsping 通。</p>
<p>database link 分为两种：一种为 public（公有） 一种为 private（个人）。顾名思义，公有dblink即源库所有的用户都可以使用，个人dblink则只有创建者用户可以使用。</p>
<p>创建dblink是要有相应的权限的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user_sys_privs where privilege like upper(&#x27;%LINK%&#x27;);</span><br></pre></td></tr></table></figure>

<pre><code>   USERNAME    PRIVILEGE    ADMIN_OPTION    COMMON
   APPS        CREATE PUBLIC DATABASE LINK      NO    NO
   APPS        CREATE DATABASE LINK          NO    NO
</code></pre>
<p>CREATE DATABASE LINK 为创建个人dblink权限。</p>
<p>CREATE PUBLIC DATABASE LINK 为创建公有dblink 权限。</p>
<p><strong>创建dblink</strong> </p>
<p>当tnsnames中有了参数。且有了相应的权限之后，就可以创建dblink。创建方式有以下几种。</p>
<p>创建个人dblink语句为 CREATE database link 开头：</p>
<p>使用当前用户的用户名和密码去连接远程数据库。如果密码不对会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database link test1 using &#x27;test&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建公有dblink语句CREATE PUBLIC database link</p>
<p>使用指定的用户和密码创建公有 dblink </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create public database link test3 connect to scott identified by tiger using &#x27;test&#x27;;</span><br></pre></td></tr></table></figure>

<p>建一个shared 的数据库连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create shared public database link test4 connect to scott identified by &quot;tiger&quot; authenticated by username identified by &quot;passwd&quot; using &#x27;test&#x27;;</span><br></pre></td></tr></table></figure>

<p>使用shared方式的 database link是数据库会限制到远程数据库的连接的数量,这样以避免过多的连接对远程数据库造成太大的压力。</p>
<p>还有一种创建方式是不使用tnsname的情况</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> database link link_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">CONNECT</span> <span class="keyword">TO</span> <span class="keyword">user</span> IDENTIFIED <span class="keyword">BY</span> screct</span><br><span class="line"></span><br><span class="line"><span class="keyword">USING</span> <span class="string">&#x27;(DESCRIPTION =</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">(ADDRESS_LIST =</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">(ADDRESS = (PROTOCOL = TCP)(HOST = ip)(PORT = 1521))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">(CONNECT_DATA =</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">(SERVICE_NAME = sales)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">)&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>删除dblink</strong> </p>
<p>首先需要查询出来有哪些dblink </p>
<p>select owner,object_name from dba_objects where object_type=’DATABASE LINK’; </p>
<p>然后如果为pubilc 则删除方式为 drop public database link </p>
<p>如果为个人则删除方式为：drop database link</p>
<p>其实本质上来说，dblink 并不是一个很复杂的东西。但是鉴于对数据库的影响。本着能少用就少用的原则。如果能用一些导入导出去替换dblink（我们也正在这么做）是最好的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE LINK erp_to_tms.INVT.COM.CN </span><br><span class="line"><span class="keyword">CONNECT</span> <span class="keyword">TO</span> invt IDENTIFIED <span class="keyword">by</span>   invt</span><br><span class="line"><span class="keyword">using</span> <span class="string">&#x27;(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=192.168.0.94)(PORT=1521))) (CONNECT_DATA=(SERVICE_NAME=TMS)))&#x27;</span>;</span><br><span class="line"><span class="comment">-----------------------------------------------------------</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE LINK OA.INVT.COM.CN</span><br><span class="line"><span class="keyword">CONNECT</span> <span class="keyword">TO</span> invt IDENTIFIED <span class="keyword">by</span>   invt</span><br><span class="line"><span class="keyword">using</span> <span class="string">&#x27;(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=192.168.1.29)(PORT=1521))) (CONNECT_DATA=(SERVICE_NAME=invtoa)))&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="Oracle-物化视图"><a href="#Oracle-物化视图" class="headerlink" title="Oracle 物化视图"></a>Oracle 物化视图</h4><p>一、与普通视图的区别</p>
<p>普通视图是虚拟表，不能创建索引，任何对视图的查询，Oracle都将转换为对视图SQL语句的查询，这样对整体查询性能的提升，并没有实质上的好处。但同时普通视图也不会占用存储空间。</p>
<p>物化视图可以看作是一种特殊的物理表（可以从 dba_tables 查询出来），可以创建索引，提升查询性能。但同时物化视图也会占用存储空间（可以从 dba_segment 查询出来）。</p>
<p>二、创建或删除物化视图</p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--创建物化视图</span><br><span class="line"></span><br><span class="line">CREATE MATERIALIZED VIEW [mview_name]</span><br><span class="line"></span><br><span class="line">REFRESH [FAST|COMPLETE|FORCE]</span><br><span class="line"></span><br><span class="line">[ON COMMIT|ON DEMAND|START WITH (start_time) NEXT (next_time)]</span><br><span class="line"></span><br><span class="line">AS</span><br><span class="line"></span><br><span class="line">&#123;创建物化视图使用的SQL查询语句&#125;;</span><br><span class="line"></span><br><span class="line">--删除物化视图</span><br><span class="line">DROP MATERIALIZED VIEW mview_name;</span><br></pre></td></tr></table></figure>

<p>举例:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--创建测试主表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cux_test_table</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line"></span><br><span class="line"> test_id  NUMBER,</span><br><span class="line"></span><br><span class="line"> test_code VARCHAR2(<span class="number">10</span>),</span><br><span class="line"></span><br><span class="line"> test_desc VARCHAR2(<span class="number">100</span>),</span><br><span class="line"></span><br><span class="line"> test_date <span class="type">DATE</span></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">--如果是创建增量刷新的物化视图，主表必须有主键</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--如果是创建其他刷新方式的物化视图，主表有无主键均可</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> cux_test_table <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> cux_test_table_pk <span class="keyword">PRIMARY</span> KEY (test_id);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">--如果是创建增量刷新的物化视图，必须创建物化视图日志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--如果是创建其他刷新方式的物化视图，无需创建物化视图日志</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> MATERIALIZED <span class="keyword">VIEW</span> LOG <span class="keyword">ON</span> cux_test_table;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">--创建测试物化视图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--每天凌晨1点增量刷新</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> MATERIALIZED <span class="keyword">VIEW</span> cux_test_mv</span><br><span class="line"></span><br><span class="line">REFRESH FAST</span><br><span class="line"></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">WITH</span> SYSDATE NEXT TRUNC(SYSDATE<span class="operator">+</span><span class="number">1</span>) <span class="operator">+</span> <span class="number">1</span> <span class="operator">/</span> <span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> test_id, test_code, test_desc, test_date <span class="keyword">FROM</span> cux_test_table;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">--删除测试物化视图</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> MATERIALIZED <span class="keyword">VIEW</span> cux_test_mv;</span><br></pre></td></tr></table></figure>

<p>物化视图刷新方式有三种：fast（增量刷新）、complete（全量刷新）、force（默认）。</p>
<p>3.1、fast- 增量刷新</p>
<p>使用增量刷新方式必须满足两个条件：</p>
<p>（1）主表必须有主键；</p>
<p>ALTER TABLE table_name ADD CONSTRAINT primary_name PRIMARY KEY (column_name);</p>
<p>（2）必须创建物化视图日志，用于存放主表数据变化。</p>
<p>CREATE MATERIALIZED VIEW LOG ON （主表名）;</p>
<p>创建物化视图日志后会生成表 mlog$_主表名，主表数据变化会存放在这张表里。</p>
<p>3.2、complete - 全量刷新</p>
<p>3.3、 force - 默认</p>
<p>不指定刷新方式或指定刷新方式为force时，当可以使用fast方式刷新时，采用fast，否则采用complete。</p>
<p>四、刷新触发机制</p>
<p>物化视图刷新触发机制有三种：on commit、on demand、start with (start_time) next (next_time)。</p>
<p>4.1、on commit</p>
<p>当主表数据提交时，刷新物化视图。</p>
<p>4.2、on demand</p>
<p>需要刷新时再刷新，通过调用 dbms_mview.refresh 进行刷新，举例如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--增量刷新</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line"> dbms_mview.refresh(list =&gt; &#x27;CUX_TEST_MV&#x27;, method =&gt; &#x27;FAST&#x27;);</span><br><span class="line"></span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">--全量刷新</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line"> dbms_mview.refresh(list =&gt; &#x27;CUX_TEST_MV&#x27;, method =&gt; &#x27;COMPLETE&#x27;);</span><br><span class="line"></span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">--默认</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line"> dbms_mview.refresh(list =&gt; &#x27;CUX_TEST_MV&#x27;);</span><br><span class="line"></span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>4.3、start with (start_time) next (next_time)</p>
<p>从指定时间开始，每隔一段时间（由next指定）刷新一次。</p>
<p>五、相关查询SQL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM dba_tables t WHERE t.table_name = &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM dba_segments s WHERE s.segment_name = &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM dba_mviews m WHERE m.mview_name = &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM dba_mview_refresh_times t WHERE t.name = &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM dba_mview_analysis a WHERE a.mview_name = &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM mlog$_主表名; --物化视图日志</span><br><span class="line"></span><br><span class="line">SELECT * FROM dba_mview_logs l WHERE l.log_table = &#x27;MLOG$_主表名&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="Oracle-userenv-‘LANG’"><a href="#Oracle-userenv-‘LANG’" class="headerlink" title="Oracle userenv(‘LANG’)"></a>Oracle userenv(‘LANG’)</h4><p>该语句用于获取当前用户会话的语言设置。具体来说，它返回一个字符串，该字符串表示用户会话的数据库语言环境。Oracle数据库支持多种语言，因此用户可以根据需要设置自己的语言环境。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> otta.order_category_code</span><br><span class="line">  <span class="keyword">FROM</span> oe_transaction_types_tl ottt, oe_transaction_types_all otta</span><br><span class="line"> <span class="keyword">WHERE</span> ottt.transaction_type_id <span class="operator">=</span> otta.transaction_type_id</span><br><span class="line">   <span class="keyword">AND</span> ottt.language <span class="operator">=</span> userenv(<span class="string">&#x27;LANG&#x27;</span>)</span><br><span class="line"><span class="keyword">AND</span> otta.transaction_type_code <span class="operator">=</span> <span class="string">&#x27;ORDER&#x27;</span></span><br></pre></td></tr></table></figure>



<h4 id="Oracle-SYNONYM-的作用"><a href="#Oracle-SYNONYM-的作用" class="headerlink" title="Oracle SYNONYM 的作用"></a>Oracle SYNONYM 的作用</h4><p>在 Oracle 数据库中，SYNONYM（同义词）是指数据库中的对象名称的替代名称。Synonym 在 Oracle 中的作用有以下几个方面：</p>
<ol>
<li><p>简化 SQL Query：通过创建 SYNONYM，我们可以为某个对象（如表、视图、存储过程等）指定一个别名。这个别名可以直接在 SQL 查询中使用，从而简化了 SQL 查询的语法。例如，如果您创建了一个名为 emp 的表的同义词 emp_table，那么您可以使用以下语句来查询该表：<code>SELECT * FROM emp_table;</code></p>
</li>
<li><p>提高程序稳定性：如果您将程序的连接字符串或其他配置信息编码到程序代码中，那么每当您更改连接字符串或其他配置信息时，都需要更新程序代码。通过使用同义词，您可以将连接字符串编码为单个对象，仅在需要更改连接字符串时更改该对象，无需修改程序代码。</p>
</li>
<li><p>管理权限：通过分配 SYNONYM 权限，您可以控制用户对特定对象的访问权限。例如，如果您不希望用户直接访问某个表，可以创建一个同义词，然后授予用户对同义词的 SELECT、INSERT、UPDATE 和 DELETE 权限，而不是对表本身的权限。这样可以更好地控制用户对数据的访问权限。</p>
</li>
</ol>
<p>总的来说，SYNONYM 在 Oracle 中具有重要的作用，可以帮助您更好地管理数据库对象并简化 SQL 查询语法。</p>
<h4 id="Oracle-EXISTS"><a href="#Oracle-EXISTS" class="headerlink" title="Oracle EXISTS"></a>Oracle EXISTS</h4><p>在 Oracle 数据库中，EXISTS 是一个条件运算符，用于测试查询结果是否存在。具体来说，它通常用于子查询中，以确定主查询结果集中是否存在与子查询匹配的数据。</p>
<p>EXISTS 的语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name1, column_name2, ... <span class="keyword">FROM</span> table_name1 <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> table_name2 <span class="keyword">WHERE</span> <span class="keyword">condition</span>);</span><br></pre></td></tr></table></figure>

<p>其中，table_name1 是主查询的表名，table_name2 是子查询的表名，condition 是子查询的条件。如果子查询返回至少一行，那么 EXISTS 运算符返回 TRUE，否则返回 FALSE。</p>
<p>例如，如果您需要查找所有员工至少在一个项目中工作过：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees e <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> projects p <span class="keyword">WHERE</span> p.employee_id <span class="operator">=</span> e.employee_id);</span><br></pre></td></tr></table></figure>

<p>这个查询将返回所有在项目中工作过的员工的记录。子查询 <code>SELECT 1 FROM projects p WHERE p.employee_id = e.employee_id</code> 检查对象projects中是否存在具有匹配employee_id的记录。如果匹配，则EXISTS返回 TRUE，查询将返回主查询中与存在记录相匹配的记录。</p>
<p>请注意，EXISTS 运算符可以更高效地进行比大多数 JOIN 操作，因为它只需查找匹配记录的存在性，而不是查找整个结果集。</p>
<h4 id="Oracle-EBS-fnd-global-apps-initialize"><a href="#Oracle-EBS-fnd-global-apps-initialize" class="headerlink" title="Oracle  EBS fnd_global.apps_initialize"></a>Oracle  EBS fnd_global.apps_initialize</h4><p>“fnd_global.apps_initialize”是Oracle E-Business Suite中的一个函数，它用于初始化当前会话的应用程序上下文。该函数通常在应用程序代码中的存储过程或函数中使用，以便在会话开始时设置正确的应用程序上下文。</p>
<p>在调用该函数之前，必须先设置应用程序ID（即”fnd_global.apps_initialize”函数的第一个参数）和用户ID（即”fnd_global.apps_initialize”函数的第二个参数）。这通常是通过将这些值分配给PL/SQL变量来完成的，然后传递给函数作为参数使用。</p>
<p>例如，以下是在Oracle E-Business Suite中使用”fnd_global.apps_initialize”函数的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">  l_user_id       NUMBER;</span><br><span class="line">  l_resp_id       NUMBER;</span><br><span class="line">  l_resp_appl_id  NUMBER;</span><br><span class="line">  l_app_id        NUMBER;</span><br><span class="line">BEGIN</span><br><span class="line">  -- Set the application ID and user ID</span><br><span class="line">  l_app_id := 123; -- Replace with a valid application ID</span><br><span class="line">  l_user_id := 456; -- Replace with a valid user ID</span><br><span class="line"></span><br><span class="line">  -- Call fnd_global.apps_initialize to initialize the application context</span><br><span class="line">  fnd_global.apps_initialize(l_user_id, l_resp_id, l_resp_appl_id, l_app_id);</span><br><span class="line"></span><br><span class="line">  -- Your code here...</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<h4 id="Oracle-EBS-mo-global-set-policy-context"><a href="#Oracle-EBS-mo-global-set-policy-context" class="headerlink" title="Oracle EBS mo_global.set_policy_context"></a>Oracle EBS mo_global.set_policy_context</h4><p><code>mo_global.set_policy_context</code>是Oracle E-Business Suite中的一个函数，用于设置安全策略上下文。该函数接受两个参数，第一个参数是策略类型，第二个参数是策略值。</p>
<p><code>mo_global.set_policy_context</code>函数通常用于设置多组织或多安全上下文。在多组织环境中，该函数可以用于设置当前会话的组织上下文，以实现对特定组织的访问控制。在多安全上下文中，该函数可以用于设置当前会话的权限范围，以实现对特定功能或数据的访问控制。</p>
<p>下面是一些示例：</p>
<ol>
<li><p>设置当前会话的组织上下文：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mo_global.set_policy_context(<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;123&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>  这将会将当前会话的组织上下文设置为组织123，以实现对组织123的访问控制。</p>
<ol start="2">
<li>设置当前会话的安全上下文：</li>
</ol>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mo_global.set_policy_context(<span class="string">&#x27;FND_RESPONSIBILITY_ID&#x27;</span>, <span class="string">&#x27;10001&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>  这将会将当前会话的Responsibility ID设置为10001，以实现对特定功能或数据的访问控制。</p>
<p>总的来说，<code>mo_global.set_policy_context</code>函数是Oracle E-Business Suite中的一个非常有用的函数，可以用于实现访问控制、安全策略管理和权限管理等功能。</p>
<h4 id="Oracle-EBS-fnd-request-submit-request"><a href="#Oracle-EBS-fnd-request-submit-request" class="headerlink" title="Oracle EBS fnd_request.submit_request"></a>Oracle EBS fnd_request.submit_request</h4><p>在 Oracle EBS 中，fnd_request.submit_request 是一个 PL/SQL 过程，它用于提交标准并发程序或请求组。该过程允许并发程序在后台运行，从而避免阻塞前端用户界面，以提高用户体验。</p>
<p>fnd_request.submit_request 过程的语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">fnd_request.submit_request (application <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;应用系统&#x27;</span>,</span><br><span class="line">                            program     <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;程序名称&#x27;</span>,</span><br><span class="line">                            description <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;程序描述&#x27;</span>,</span><br><span class="line">                            start_time  <span class="operator">=</span><span class="operator">&gt;</span> SYSDATE,</span><br><span class="line">                            sub_request <span class="operator">=</span><span class="operator">&gt;</span> <span class="literal">FALSE</span>,</span><br><span class="line">                            argument1   <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;参数值1&#x27;</span>,</span><br><span class="line">                            argument2   <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;参数值2&#x27;</span>...);</span><br></pre></td></tr></table></figure>

<p>该过程的参数解释如下：</p>
<ul>
<li>application：必填项，表示要运行的应用程序的名称；</li>
<li>program：必填项，表示要运行的程序的名称；</li>
<li>description：可选项，表示任务的描述；</li>
<li>start_time：可选项，表示要求任务执行的时间；</li>
<li>sub_request：可选项，表示此任务是否应该作为另一个任务的子任务；</li>
<li>argument1、argument2 等：可选项，表示程序执行所需的参数值。</li>
</ul>
<p>当 fnd_request.submit_request() 函数被调用时，它将创建一个新的并发请求，将其插入 fnd_concurrent_requests 表中，并将参数值传递给并发程序进行处理。</p>
<p>在使用 fnd_request.submit_request() 函数时，需要注意以下几点：</p>
<ol>
<li>确保程序名称和应用程序名称正确；</li>
<li>确保参数的顺序和类型与程序定义的参数一致；</li>
<li>如果程序需要使用值集，需要将该值集注册到数据库中；</li>
<li>如果需要预览并发程序输出，则必须在程序源代码中使用 FND_FILE.PUT 或 FND_FILE.PUT_LINE 函数将输出写入到输出文件中。</li>
</ol>
<p>总的来说，fnd_request.submit_request() 函数是 Oracle EBS 中一个非常有用的函数，它可以帮助将并发请求发送到后台，并且具有很高的灵活性和可定制性。</p>
<p>Oracle fnd_request.submit_request 函数是用于向Oracle Applications程序提交并执行请求的。该函数返回一个唯一标识符作为参数，可以用作获取请求执行状态和结果的参考。</p>
<p>通常情况下，可以将该参数传递给 FND_CONCURRENT.wait_for_request 函数。该函数将等待直到请求执行完成，并返回请求的状态和结果。</p>
<p>示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE</span><br><span class="line"> l_request_id NUMBER;</span><br><span class="line">BEGIN</span><br><span class="line"> l_request_id := fnd_request.submit_request(&#x27;XXMYPACKAGE&#x27;, &#x27;XX_MY_REQUEST&#x27;, NULL, NULL, FALSE, NULL, NULL);</span><br><span class="line"> dbms_output.put_line(&#x27;Request ID: &#x27; || l_request_id);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>该代码向 Oracle Applications 提交一个名为 XX_MY_REQUEST 的请求，并将返回的请求ID打印到输出窗口中。</p>
<h4 id="Oracle-EBS-oe-order-pub-header-rec-type"><a href="#Oracle-EBS-oe-order-pub-header-rec-type" class="headerlink" title="Oracle EBS oe_order_pub.header_rec_type"></a>Oracle EBS oe_order_pub.header_rec_type</h4><p><code>oe_order_pub.header_rec_type</code> 是一个记录类型 (record type)，在 Oracle E-Business Suite (EBS) 中的订单管理模块中定义，用于存储订单头信息。这个记录类型包括以下字段：</p>
<ul>
<li><code>order_number</code>：订单号</li>
<li><code>order_type_id</code>：订单类型 ID</li>
<li><code>order_date</code>：订单日期</li>
<li><code>ordered_by</code>：下单人员工号</li>
<li><code>sold_to_org_id</code>：销售组织 ID</li>
<li><code>bill_to_org_id</code>：账单组织 ID</li>
<li><code>ship_to_org_id</code>：发货组织 ID</li>
<li><code>order_source_id</code>：订单来源 ID</li>
<li><code>po_number</code>：采购订单号</li>
<li><code>cust_po_number</code>：客户采购订单号</li>
<li><code>transaction_type_id</code>：交易类型 ID</li>
<li><code>term_id</code>：付款条件 ID</li>
</ul>
<p>使用 <code>oe_order_pub.header_rec_type</code> 和相关的 API，可以在 EBS 中创建、修改和查询订单头信息。</p>
<h4 id="Oracle-EBS-oe-order-pub-line-tbl-type"><a href="#Oracle-EBS-oe-order-pub-line-tbl-type" class="headerlink" title="Oracle EBS oe_order_pub.line_tbl_type"></a>Oracle EBS oe_order_pub.line_tbl_type</h4><p><code>oe_order_pub.line_tbl_type</code> 是一个自定义的 Oracle E-Business Suite 记录类型 (record type)，用于存储订单行 (order line) 信息。这个记录类型定义了一个包含多个订单行记录的表格类型 (table type)。每个订单行记录包括以下字段：</p>
<ul>
<li><code>line_id</code>：订单行 ID</li>
<li><code>line_number</code>：订单行号</li>
<li><code>inventory_item_id</code>：存货项 (inventory item) ID</li>
<li><code>ordered_quantity</code>：订购数量</li>
<li><code>unit_selling_price</code>：销售单价</li>
<li><code>line_type_id</code>：订单行类型 ID</li>
<li><code>ship_from_org_id</code>：发货组织 ID</li>
<li><code>ship_to_org_id</code>：发货到的组织 ID</li>
<li><code>schedule_ship_date</code>：计划发货日期</li>
<li><code>request_date</code>：需求日期</li>
<li><code>flow_status_code</code>：流程状态代码</li>
</ul>
<p>在 Oracle E-Business Suite 中的订单管理模块中，<code>oe_order_pub.line_tbl_type</code> 可以和相关的 API 一起使用，实现订单行的创建、修改和查询等操作。</p>
<h4 id="Oracle-EBS-oe-order-pub-request-tbl-type"><a href="#Oracle-EBS-oe-order-pub-request-tbl-type" class="headerlink" title="Oracle EBS oe_order_pub.request_tbl_type"></a>Oracle EBS oe_order_pub.request_tbl_type</h4><p><code>oe_order_pub.request_tbl_type</code> 是一个记录类型 (record type)，在 Oracle E-Business Suite (EBS) 中的订单管理模块中定义，用于存储订单请求 (order request) 记录。这个记录类型定义了一个包含多个订单请求记录的表格类型 (table type)，每个订单请求记录包括以下字段：</p>
<ul>
<li><code>header_id</code>：订单头 ID</li>
<li><code>line_id</code>：订单行 ID</li>
<li><code>request_type</code>：请求类型</li>
<li><code>quantity</code>：请求数量</li>
<li><code>flow_status_code</code>：请求流程状态代码</li>
<li><code>request_date</code>：请求日期</li>
</ul>
<p>在 EBS 中，可以通过 <code>oe_order_pub.request_tbl_type</code> 和相关的 API 访问这个记录类型，实现订单请求的创建、更新和查询等操作。</p>
<h4 id="Oracle-EBS-oe-order-pub-g-miss-header-rec"><a href="#Oracle-EBS-oe-order-pub-g-miss-header-rec" class="headerlink" title="Oracle EBS oe_order_pub.g_miss_header_rec"></a>Oracle EBS oe_order_pub.g_miss_header_rec</h4><p><code>oe_order_pub.g_miss_header_rec</code> 是 Oracle E-Business Suite 的一个公共包（public package），包含一个全局的变量 <code>g_miss_header_rec</code>。该全局变量的数据类型是订单头信息的记录（record），用于存储 Oracle Order Entry (OE) 订单处理的丢失头信息。</p>
<p>当调用订单处理API时，如果订单的头信息缺失，会将缺失的头信息存储到 <code>g_miss_header_rec</code> 变量中。在处理缺失头信息时，可以使用 <code>g_miss_header_rec</code> 中存储的数据进行处理，避免出现错误。</p>
<p>需要注意的是，这个包是 Oracle E-Business Suite 内部使用的，如果不是很熟悉订单处理的细节，建议不要随意修改该包中的代码或者变量。</p>
<h4 id="Oracle-EBS-oe-msg-pub-initialize"><a href="#Oracle-EBS-oe-msg-pub-initialize" class="headerlink" title="Oracle EBS oe_msg_pub.initialize"></a>Oracle EBS oe_msg_pub.initialize</h4><p><code>oe_msg_pub.initialize</code> 是 Oracle EBS (E-Business Suite) 中的一个 PL/SQL 过程，用于初始化消息管理器（Message Manager）。它将创建一个用于存储消息信息的临时表，以及一些提示性数据提供给消息管理器使用。</p>
<p>在 Oracle EBS 中，<code>oe_msg_pub.initialize</code> 通常在自定义开发中的交易性代码中使用，以实现在订单管理模块中发送消息给用户。它可以用于将消息文本、语言代码、消息类型、消息级别等信息存储在数据库中，以便稍后在用户界面中显示。</p>
<p>例如，以下是一个使用 <code>oe_msg_pub.initialize</code> 过程初始化消息管理器和发送消息的示例代码片段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">oe_msg_pub.initialize;</span><br><span class="line">oe_msg_pub.set_name(&#x27;XX_MY_CUSTOM_MSG&#x27;);</span><br><span class="line">oe_msg_pub.set_application(&#x27;OE&#x27;);</span><br><span class="line">oe_msg_pub.set_message_number(&#x27;12345&#x27;);</span><br><span class="line">oe_msg_pub.set_default_language(&#x27;US&#x27;);</span><br><span class="line">oe_msg_pub.set_text(&#x27;Your order has been processed successfully.&#x27;);</span><br><span class="line">oe_msg_pub.set_explanation(&#x27;This message indicates that your order has been successfully processed by our system.&#x27;);</span><br><span class="line">oe_msg_pub.set_type(&#x27;I&#x27;);</span><br><span class="line">oe_msg_pub.set_level(&#x27;5&#x27;);</span><br><span class="line">oe_msg_pub.show;</span><br></pre></td></tr></table></figure>

<p>这段代码将初始化消息管理器，设置一个消息名称为 <code>XX_MY_CUSTOM_MSG</code>，其他相关消息内容，然后将该消息显示给用户。</p>
<h4 id="Oracle-EBS-dbms-output-enable-1000000"><a href="#Oracle-EBS-dbms-output-enable-1000000" class="headerlink" title="Oracle EBS dbms_output.enable(1000000)"></a>Oracle EBS dbms_output.enable(1000000)</h4><p>这是一条PL/SQL代码，用于激活Oracle数据库中的dbms_output模块并设置输出缓冲区大小为1000000个字符。这样可以在SQL Developer或SQL*Plus等工具中实现大容量的输出。例如，当我们在PL/SQL中使用dbms_output.put_line()语句输出大量数据时，如果没有启用dbms_output模块或者缓冲区设置过小，可能会导致输出被截断或者不完全显示。因此，通过使用dbms_output.enable()函数并设置合适的缓冲区大小，可以避免这类问题。</p>
<h4 id="Oracle-EBS-oe-holds-pvt"><a href="#Oracle-EBS-oe-holds-pvt" class="headerlink" title="Oracle EBS oe_holds_pvt"></a>Oracle EBS oe_holds_pvt</h4><p>Oracle的oe_holds_pvt是一个PL/SQL包，用于支持订单管理中的暂挂功能。当一个订单被暂挂时，它不能被释放或出货，直到暂挂被取消或过期。oe_holds_pvt包提供了以下子程序：</p>
<ul>
<li>set_hold：在订单上设置暂挂。</li>
<li>release_hold：释放给定订单上的暂挂。</li>
<li>expire_hold：将在给定时间之前设置的暂挂过期。如果没有指定时间，则将所有过期暂挂释放。</li>
<li>check_if_order_held：检查给定订单是否有暂挂设置。</li>
<li>check_hold_expiry：检查给定的暂挂是否已过期。</li>
</ul>
<p>oe_holds_pvt包是Oracle E-Business Suite中订单管理模块的一部分，因此它只适用于这个特定的系统。</p>
<p><strong>举例：</strong></p>
<p>–多张销售订单批量暂挂OE_HOLDS_PVT.process_apply_holds_orders </p>
<p>–多个销售订单行暂挂OE_HOLDS_PVT.process_apply_holds_lines</p>
<h4 id="Oracle-EBS-setContext-retcode-errbuf"><a href="#Oracle-EBS-setContext-retcode-errbuf" class="headerlink" title="Oracle EBS  setContext(retcode, errbuf)"></a>Oracle EBS  setContext(retcode, errbuf)</h4><p>这是一个在Oracle数据库中设置上下文的函数。它需要两个参数：</p>
<ol>
<li>retcode：表示操作的返回代码（通常是整数或枚举类型）。</li>
<li>errbuf：表示操作返回的错误信息（通常是字符串）。</li>
</ol>
<p>setContext函数的作用是设置在当前数据库会话中可以用来共享信息的上下文。它在存储过程和函数中被广泛使用，可以用来保存以后可以在同一会话中使用的数据。 可以根据设置的上下文来处理不同的逻辑，从而实现不同的业务需求。</p>
<h4 id="Oracle-EBS-FND-FILE-OUTPUT"><a href="#Oracle-EBS-FND-FILE-OUTPUT" class="headerlink" title="Oracle EBS FND_FILE.OUTPUT"></a>Oracle EBS FND_FILE.OUTPUT</h4><p>FND_FILE.OUTPUT 是 Oracle E-Business Suite 中的一个会话全局属性，可以用于将输出信息发送到标准 EBS 输出窗口和日志文件。在 EBS 中，默认情况下，标准输出设备是标准输出窗口，而日志文件通常是 $APPLCSF/$APPLLOG，其中 $APPLCSF 和 $APPLLOG 是应用程序上下文文件系统的环境变量。</p>
<p>以下是一个简单的示例，展示如何在 EBS 中使用 FND_FILE.OUTPUT 输出信息：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">FND_FILE.OUTPUT(<span class="string">&#x27;This is a test message.&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，FND_FILE.OUTPUT 将字符串 ‘This is a test message.’ 发送到标准 EBS 输出设备和日志文件。</p>
<p>需要注意的是，在使用 FND_FILE.OUTPUT 时，需要使用 FND_FILE.ENABLE 来启用输出功能，并确保应用程序的日志文件和输出设备具有足够的权限和空间。同时，在实际应用程序中，可以根据需要将输出信息包装为相应的格式，并加入应用程序特定的状态和处理信息。</p>
<p>总之，FND_FILE.OUTPUT 是 Oracle E-Business Suite 中的一个重要会话全局属性，可用于发送输出信息到标准输出设备和日志文件。在使用这个功能时，需要注意权限、空间和格式等方面的问题，并根据实际情况将具体的应用程序状态和处理信息输出到文件中。</p>
<h4 id="Oracle-EBS-FND-FILE-OUTPUT-1"><a href="#Oracle-EBS-FND-FILE-OUTPUT-1" class="headerlink" title="Oracle EBS  FND_FILE.OUTPUT"></a>Oracle EBS  FND_FILE.OUTPUT</h4><p>FND_FILE.PUT_LINE 是 Oracle E-Business Suite (EBS) 应用程序中的一种过程，可以用于在应用程序日志和输出文件中写入一行信息和错误信息。在 EBS 中，FND_FILE.PUT_LINE 通常与 FND_FILE.OPEN 和 FND_FILE.CLOSE 一起使用，以便在日志中写入应用程序的运行状态和处理信息。</p>
<p>以下是一个简单的示例，展示如何在 EBS 中使用 FND_FILE.PUT_LINE 写入日志信息：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line"></span><br><span class="line">  log_file utl_file.file_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">  log_file :<span class="operator">=</span> fnd_file.open(<span class="string">&#x27;/u02/app/test/logs/mylog.txt&#x27;</span>, <span class="string">&#x27;W&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  fnd_file.put_line(log_file, <span class="string">&#x27;Start process at &#x27;</span> <span class="operator">||</span> to_char(sysdate, <span class="string">&#x27;YYYY-MM-DD HH24:MI:SS&#x27;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- ... 运行其他处理 ...</span></span><br><span class="line"></span><br><span class="line">  fnd_file.put_line(log_file, <span class="string">&#x27;End process at &#x27;</span> <span class="operator">||</span> to_char(sysdate, <span class="string">&#x27;YYYY-MM-DD HH24:MI:SS&#x27;</span>));</span><br><span class="line"></span><br><span class="line">  fnd_file.close(log_file);</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>这个 PL/SQL 块将打开一个名为 <code>/u02/app/test/logs/mylog.txt</code> 的日志文件，并使用 FND_FILE.PUT_LINE 打印一些开始和结束日志信息。在实际应用程序中，可以根据需要将这些信息替换为实际的应用程序状态和处理信息。</p>
<p>需要注意的是，在使用 FND_FILE.PUT_LINE 时，还需要特别注意文件权限和文件清理等问题。例如，确保应用程序具有足够的权限来写入和访问指定的日志文件，以及定期清理过期日志文件，避免文件占用空间过多而影响应用程序性能和稳定性。</p>
<p>总之，FND_FILE.PUT_LINE 是 Oracle E-Business Suite 应用程序中的一种过程，用于在日志文件中写入一行信息和错误信息。在使用这个函数时，需要注意文件权限和清理等问题，并根据实际情况将具体的应用程序状态和处理信息写入日志中。</p>
<h4 id="Oracle-TYPE-IS-RECORD"><a href="#Oracle-TYPE-IS-RECORD" class="headerlink" title="Oracle  TYPE IS RECORD"></a>Oracle  TYPE IS RECORD</h4><p>“Oracle TYPE IS RECORD” 的意思是在Oracle数据库中定义一个类型(type)，这个类型包含多个字段(field)，用于组合一组数据，并使用关键字 “record” 表示这个类型是一个记录类型。记录类型用来定义简单数据类型或者复杂数据类型，并可以用于存储单个或多个相关的数据元素。</p>
<h4 id="Oracle-TYPE-IS-TABLE-OF-INDEX-BY-BINARY-INTEGER"><a href="#Oracle-TYPE-IS-TABLE-OF-INDEX-BY-BINARY-INTEGER" class="headerlink" title="Oracle TYPE IS TABLE OF INDEX BY BINARY_INTEGER"></a>Oracle TYPE IS TABLE OF INDEX BY BINARY_INTEGER</h4><p>“Oracle TYPE IS TABLE OF INDEX BY BINARY_INTEGER” 是在 Oracle 数据库中定义一种类型，这种类型被称为 “关联数组类型”，也就是 “索引表类型”。这种类型可以存储一组数据，每个数据元素都有一个与之相关的数字索引，索引可以是二进制整数(binary integer)类型或其他类型。这种类型的声明示例如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">TYPE my_array <span class="keyword">IS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> NUMBER INDEX <span class="keyword">BY</span> BINARY_INTEGER;</span><br></pre></td></tr></table></figure>

<p>该声明定义了一种名为 my_array 的 “关联数组类型”，它可以存储 NUMBER 类型的数据，并使用二进制整数作为索引。我们可以通过如下方式来使用该类型： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE</span><br><span class="line"></span><br><span class="line"> my_data my_array; -- 声明一个名为 my_data 的变量，类型为 my_array</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line"> my_data(1) := 10; -- 将索引1对应的元素设置为10</span><br><span class="line"></span><br><span class="line"> my_data(2) := 20; -- 将索引2对应的元素设置为20</span><br><span class="line"></span><br><span class="line"> my_data(3) := 30; -- 将索引3对应的元素设置为30</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们声明一个 my_data 变量，这个变量是 my_array 类型的。我们可以使用这个变量来存储和访问一组数字数据，每个数据用一个唯一的索引值来标识。</p>
<p> 示例:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--参数变量</span></span><br><span class="line"> TYPE customer_search_record_type <span class="keyword">IS</span> RECORD(</span><br><span class="line">   source_code        VARCHAR2(<span class="number">30</span>),</span><br><span class="line">   source_id          VARCHAR2(<span class="number">150</span>),</span><br><span class="line">   operation_unit     VARCHAR2(<span class="number">50</span>), <span class="comment">--业务实体名称</span></span><br><span class="line">   sales_empoyee_code VARCHAR2(<span class="number">20</span>), <span class="comment">--销售业务人员</span></span><br><span class="line">   attribute1         VARCHAR2(<span class="number">240</span>),</span><br><span class="line">   attribute2         VARCHAR2(<span class="number">240</span>),</span><br><span class="line">   attribute3         VARCHAR2(<span class="number">240</span>),</span><br><span class="line">   attribute4         VARCHAR2(<span class="number">240</span>),</span><br><span class="line">   attribute5         VARCHAR2(<span class="number">240</span>));</span><br><span class="line"></span><br><span class="line"> TYPE customer_search_back_type <span class="keyword">IS</span> RECORD(</span><br><span class="line">   source_code     VARCHAR2(<span class="number">30</span>),</span><br><span class="line">   source_id       VARCHAR2(<span class="number">150</span>),</span><br><span class="line">   customer_number VARCHAR2(<span class="number">20</span>), <span class="comment">--客户编号</span></span><br><span class="line">   NAME            VARCHAR2(<span class="number">120</span>), <span class="comment">--客户名称</span></span><br><span class="line">   process_status  VARCHAR2(<span class="number">5</span>),</span><br><span class="line">   process_message VARCHAR2(<span class="number">240</span>));</span><br><span class="line"></span><br><span class="line"> TYPE crm_search_table_type <span class="keyword">IS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> customer_search_record_type INDEX <span class="keyword">BY</span> BINARY_INTEGER;</span><br><span class="line"></span><br><span class="line"> TYPE crm_search_back_table_type <span class="keyword">IS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> customer_search_back_type INDEX <span class="keyword">BY</span> BINARY_INTEGER;</span><br></pre></td></tr></table></figure>

<h4 id="Oracle-FETCH-BULK-COLLECT-INTO"><a href="#Oracle-FETCH-BULK-COLLECT-INTO" class="headerlink" title="Oracle FETCH BULK COLLECT INTO"></a>Oracle FETCH BULK COLLECT INTO</h4><p>Oracle 中的 FETCH BULK COLLECT INTO 语句是用来进行批量数据读取的一种技术。与传统的逐行读取不同，FETCH BULK COLLECT INTO 可以一次读取多行数据，大幅提高读取数据的效率。在使用 FETCH BULK COLLECT INTO 时，需要先定义一个集合类型（Collection Type），将读取的数据存储到这个集合类型中，再将其转存到其他数据表或数据对象中。</p>
<p>以下是一个简单的示例，展示如何使用 FETCH BULK COLLECT INTO 语句从表 Orders 中读取数据，存储到一维数组 orders 中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  TYPE order_tab <span class="keyword">IS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> Orders<span class="operator">%</span>ROWTYPE;</span><br><span class="line">  orders order_tab;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    BULK <span class="keyword">COLLECT</span> <span class="keyword">INTO</span> orders</span><br><span class="line">    <span class="keyword">FROM</span> Orders</span><br><span class="line">   <span class="keyword">WHERE</span> order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2019-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2020-12-31&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;Number of rows fetched: &#x27;</span> <span class="operator">||</span> orders.COUNT);</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 对 orders 数组进行循环遍历操作</span></span><br><span class="line">  <span class="keyword">FOR</span> i <span class="keyword">IN</span> <span class="number">1.</span>.orders.COUNT LOOP</span><br><span class="line">    <span class="comment">-- 在此进行特定的逻辑处理</span></span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;Order ID: &#x27;</span> <span class="operator">||</span> orders(i).order_id);</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;Order Date: &#x27;</span> <span class="operator">||</span> orders(i).order_date);</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;Order Amount: &#x27;</span> <span class="operator">||</span> orders(i).amount);</span><br><span class="line">  <span class="keyword">END</span> LOOP;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，先定义了一个名为 order_tab 的集合类型，然后使用 SELECT BULK COLLECT INTO 语句来将查询到的数据存储到 orders 变量中。最后，在一个 FOR 循环中对 orders 数组进行遍历，进行特定的业务逻辑处理。</p>
<p>需要注意的是，在使用 FETCH BULK COLLECT INTO 时，需要注意以下几点：</p>
<ol>
<li>必须定义集合类型，集合类型的结构要与查询结果集的结构匹配。</li>
<li>必须使用 BULK COLLECT 子句来获取数据。</li>
<li>为避免数组超出存储能力，读取数据时需要对数据量进行控制，避免一次性读取过多数据。</li>
<li>BULK COLLECT INTO 只能在 PL/SQL 中使用。</li>
</ol>
<p>总之，FETCH BULK COLLECT INTO 是 Oracle 数据库中用于进行批量数据读取的一种技术，可以大幅提高数据读取的效率。在使用时，需要注意定义集合类型、使用 BULK COLLECT 子句来获取数据、控制数据量以及在 PL/SQL 中使用等方面的问题。</p>
<h4 id="Oracle-NOCPY"><a href="#Oracle-NOCPY" class="headerlink" title="Oracle NOCPY"></a>Oracle NOCPY</h4><p>“NOCOPY” 不是一个数据类型，而是一个 Oracle 提供的参数提示符号，用于告知编译器在调用子程序时不要执行参数的传递方式通常的传递方式，即值传递。该提示符可用于以下类型的参数：</p>
<p>- 基本数据类型（如数字、字符、日期、布尔等）。</p>
<p>- 大对象（LOB）或对象类型（如游标、集合类型、记录类型等）。</p>
<p>但是，需要注意的是，对于那些在子程序中被修改的参数，不应该使用 NOCOPY，而应该使用传值方式传递，否则可能会发生意想不到的错误。</p>
<p>以下是一个使用 NOCOPY 的简单示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">PROCEDURE</span> process_data (p_data <span class="keyword">IN</span> <span class="keyword">out</span> NOCOPY my_collection) <span class="keyword">IS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们定义了一个名为 <code>process_data</code> 的存储过程，其中包含一个名为 <code>p_data</code> 的参数。通过在参数名后添加 <code>NOCOPY</code> 标识符，我们告知编译器不要将 <code>p_data</code> 参数作为值传递进来，而应将其作为引用传递。这能够提高存储过程的性能，特别是在处理大型集合时。</p>
<p>注意，使用 NOCOPY 操作符需要非常小心，因为它可能会影响存储过程的语义和正确性。如果在存储过程中修改了传入的参数，就不能使用 NOCOPY 操作符。此外，对于较小的参数，NO COPY 可能会导致性能下降，因为它会增加一些不必要的复杂性。因此，我们需要在使用 NOCOPY 时谨慎权衡性能和正确性之间的平衡。</p>
<h4 id="Oracle-GOTO"><a href="#Oracle-GOTO" class="headerlink" title="Oracle GOTO"></a>Oracle GOTO</h4><p>在Oracle PL/SQL语言中，可以使用 <code>GOTO</code> 语句实现跳转控制语句。<code>GOTO</code> 语句让程序执行跳到一个标记（label）所在的位置，然后从那里继续执行。</p>
<p>例如，以下代码展示了如何使用 <code>GOTO</code> 语句跳转到标记处：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;Start of my program&#x27;</span>);</span><br><span class="line">   </span><br><span class="line">   GOTO mylabel;</span><br><span class="line">   </span><br><span class="line">   DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;This line is skipped&#x27;</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="operator">&lt;&lt;</span>mylabel<span class="operator">&gt;&gt;</span></span><br><span class="line">   DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;End of my program&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>上述代码中，<code>GOTO</code> 语句跳转到 <code>&lt;mylabel&gt;</code> 标记后面的代码行，然后输出 “End of my program”。在 <code>GOTO</code> 语句后面的代码行（即第7行）被忽略了。</p>
<p>需要注意的是，<code>GOTO</code> 语句不建议滥用，因为它可能增加程序的复杂性和难以维护性。使用 <code>GOTO</code> 语句时，应当确保它对于程序结构和逻辑的理解是正确的，并且在满足特定的需要时使用。</p>
<h4 id="Oracle-ROLLBACK"><a href="#Oracle-ROLLBACK" class="headerlink" title="Oracle ROLLBACK"></a>Oracle ROLLBACK</h4><p>在Oracle数据库中，ROLLBACK语句用于回滚交易中未提交的更改。该语句用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>

<p>当执行ROLLBACK语句时，Oracle数据库将撤消当前活动的事务所做出的所有更改，并将数据库状态恢复到事务开始之前的状态。这意味着原来未提交的更改将不再存在于数据库中，并且不会影响到后续的查询。</p>
<h4 id="Oracle-PRAGMA-AUTONOMOUS-TRANSACTION"><a href="#Oracle-PRAGMA-AUTONOMOUS-TRANSACTION" class="headerlink" title="Oracle PRAGMA AUTONOMOUS_TRANSACTION"></a>Oracle PRAGMA AUTONOMOUS_TRANSACTION</h4><p>在Oracle PL/SQL语言中，可以使用 <code>PRAGMA AUTONOMOUS_TRANSACTION</code> 来声明一个自主事务。它可以在当前事务的上下文中执行一个相对独立的子事务，不会受到当前事务的提交或回滚的影响。</p>
<p>声明一个带有 <code>PRAGMA AUTONOMOUS_TRANSACTION</code> 的函数时，该函数可以独立于主程序运行，且其提交或回滚的操作不会影响主程序事务的提交或回滚。当函数执行完毕后，其中执行的事务会自动提交或回滚。</p>
<p>例如，以下代码中展示了在 <code>PRAGMA AUTONOMOUS_TRANSACTION</code> 中执行的插入操作独立于主程序的事务并可以正常执行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  PRAGMA AUTONOMOUS_TRANSACTION;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees (employee_id, first_name, last_name, email, phone_number, hire_date, job_id, salary)</span><br><span class="line">  <span class="keyword">VALUES</span> (<span class="number">123</span>, <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Doe&#x27;</span>, <span class="string">&#x27;jdoe@example.com&#x27;</span>, <span class="string">&#x27;555-1234&#x27;</span>, SYSDATE, <span class="string">&#x27;IT_PROG&#x27;</span>, <span class="number">9000</span>);</span><br><span class="line">  <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- This query returns no rows, because the transaction opened in the previous block is already committed.</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>PRAGMA AUTONOMOUS_TRANSACTION</code> 被广泛用于在事务中执行一些在主事务提交或者回滚时需要继续执行的 SQL 语句，比如发送电子邮件、写日志等操作。但是需要避免在 <code>PRAGMA AUTONOMOUS_TRANSACTION</code> 中执行对主事务数据操作的 SQL 语句，以免破坏事务的完整性和一致性。</p>
<h4 id="Oracle-dbms-utility-format-error-backtrace"><a href="#Oracle-dbms-utility-format-error-backtrace" class="headerlink" title="Oracle dbms_utility.format_error_backtrace"></a>Oracle dbms_utility.format_error_backtrace</h4><p>“Oracle dbms_utility.format_error_backtrace” 是一个 Oracle 数据库中的 PL/SQL 工具包，用于在发生异常错误时生成堆栈跟踪信息，方便管理员或开发人员对错误信息进行分析和调试。</p>
<p>当执行 PL/SQL 程序时发生异常错误时，可以使用 dbms_utility.format_error_backtrace 函数来输出该异常错误发生时的堆栈跟踪信息。该函数返回一个字符串，其中包含了堆栈跟踪信息，其中包括存储过程、函数和代码块的名称及其调用层次结构。</p>
<p>例如，以下代码段演示了如何在异常处理程序中使用 dbms_utility.format_error_backtrace 函数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line"></span><br><span class="line"> l_error_msg VARCHAR2(<span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">-- 执行某些 PL/SQL 代码，可能会出现异常错误</span></span><br><span class="line"></span><br><span class="line">EXCEPTION</span><br><span class="line"></span><br><span class="line"> <span class="keyword">WHEN</span> OTHERS <span class="keyword">THEN</span></span><br><span class="line"></span><br><span class="line">  l_error_msg :<span class="operator">=</span> dbms_utility.format_error_backtrace;</span><br><span class="line"></span><br><span class="line">  dbms_output.put_line(l_error_msg);</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>在上述代码示例中，如果在执行某些 PL/SQL 代码时发生异常错误，异常处理程序将捕获该错误并调用 dbms_utility.format_error_backtrace 函数来生成堆栈跟踪信息。然后，该信息将作为字符串存储在 l_error_msg 变量中，并输出到会话的屏幕上，以便管理员或开发人员进行调试。</p>
<h4 id="Oracle-fnd-global-user-id"><a href="#Oracle-fnd-global-user-id" class="headerlink" title="Oracle fnd_global.user_id"></a>Oracle fnd_global.user_id</h4><p>“Oracle fnd_global.user_id” 是一个 Oracle E-Business Suite 应用程序中使用的全局变量。它由 FND_GLOBAL 访问代码库提供，用来表示当前登录用户的用户ID。</p>
<p>在 Oracle E-Business Suite 应用程序中，FND_GLOBAL 是一个公共的 PL/SQL 包，它包含一组可访问的全局变量和函数。通过访问 fnd_global.user_id 变量，应用程序可以获取当前已经登录的用户 ID。该变量返回的值为数字类型，对应于登录用户的唯一标识符。</p>
<p>在应用程序中，可以使用 fnd_global.user_id 变量来执行基于用户 ID 的安全验证，或者根据登录用户的身份来授权用户访问特定的应用程序功能等。</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    X_XAS <span class="type">VARCHAR</span>(<span class="number">2000</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    X_XAS :<span class="operator">=</span> FND_GLOBAL.USER_ID;</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(X_XAS);  <span class="comment">-- -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<h4 id="Oracle-INSTR-SUBSTR"><a href="#Oracle-INSTR-SUBSTR" class="headerlink" title="Oracle INSTR  SUBSTR"></a>Oracle INSTR  SUBSTR</h4><p> <code>INSTR()</code> 和 <code>SUBSTR()</code> 是 Oracle 数据库中常用的字符串函数。</p>
<p><code>INSTR()</code> 函数用于查找一个子字符串在另一个字符串中出现的位置。其语法为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">INSTR(string, substring, start_position, occurrence);</span><br></pre></td></tr></table></figure>

<p>其中，<code>string</code> 是要在其中查找子字符串的字符串，<code>substring</code> 是要查找的子字符串，<code>start_position</code> 是要开始查找的位置，<code>occurrence</code> 是要在字符串中查找的第几个子字符串。如果 <code>INSTR()</code> 函数找不到子字符串，则返回 0。</p>
<p>以下是一个简单的示例，展示如何使用 <code>INSTR()</code> 函数查找一个字符串中子字符串的位置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> INSTR(<span class="string">&#x27;Hello, world&#x27;</span>, <span class="string">&#x27;world&#x27;</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="comment">-- Returns 8</span></span><br></pre></td></tr></table></figure>

<p>这个查询将返回 8，这是 <code>world</code> 子字符串在 <code>Hello, world</code> 字符串中的起始位置。</p>
<p><code>SUBSTR()</code> 函数用于从一个字符串中提取一个子字符串。其语法为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SUBSTR(string, start_position, [length]);</span><br></pre></td></tr></table></figure>

<p>其中，<code>string</code> 是要从中提取子字符串的字符串，<code>start_position</code> 是子字符串的起始位置，<code>length</code> 是要提取的字符串的长度。如果 <code>length</code> 被省略，则 <code>SUBSTR()</code> 函数将返回从 <code>start_position</code> 开始的未截断的子字符串。</p>
<p>以下是一个简单的示例，展示如何使用 <code>SUBSTR()</code> 函数从一个字符串中提取子字符串：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;Hello, world&#x27;</span>, <span class="number">1</span>, <span class="number">5</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="comment">-- Returns &#x27;Hello&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个查询将返回 <code>Hello</code>，这是从 <code>Hello, world</code> 字符串中提取的前 5 个字符。</p>
<p>需要注意的是，<code>INSTR()</code> 和 <code>SUBSTR()</code> 函数的参数名称根据具体场景而变化。有些示例中使用的是 <code>string</code> 和 <code>substring</code>，而有些示例中使用的是 <code>source</code> 和 <code>target</code>，或者是其他类似的名称。在使用这些函数时，重要的是理解函数的语法和参数，以便可以正确地构建查询。</p>
<p>总之，<code>INSTR()</code> 和 <code>SUBSTR()</code> 是 Oracle 数据库中经常使用的字符串函数，可以用来查找子字符串的位置和提取子字符串。熟练掌握这些函数可以让查询语句更加灵活和高效。</p>
<h4 id="Oracle-ROW"><a href="#Oracle-ROW" class="headerlink" title="Oracle ROW()"></a>Oracle ROW()</h4><p><code>ROW()</code> 是 Oracle 数据库中用于创建含有多个列的行的一个函数。该函数用于将多个表达式组合成一行，以便在 SELECT 语句中返回多个值。这个函数可以在 SQL 查询中用于快速构建数据集合，而无需创建一个实际的表。</p>
<p>以下是一个简单的示例，展示如何使用 ROW() 函数创建一个行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="type">ROW</span>(<span class="number">1</span>, <span class="string">&#x27;John Doe&#x27;</span>, <span class="string">&#x27;1985-10-15&#x27;</span>) <span class="keyword">AS</span> person <span class="keyword">FROM</span> DUAL;</span><br></pre></td></tr></table></figure>

<p>这个 SQL 查询将会创建一行，其中包括三个不同的值：一个数值、一个字符串和一个日期。注意，这个函数可以接受任意数量的参数，返回一行，其中包括输入的参数。 </p>
<p>如果需要按行返回多个结果，则可以使用 ROW() 函数来组合多个列数据。以下是一个更为复杂的示例： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="type">ROW</span>(id, first_name, last_name, hire_date) <span class="keyword">AS</span> employee</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> hire_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2021-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2021-12-31&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这个 SQL 查询将会搜索一个名为 employees 的表，然后选择在 2021 年雇用的所有员工，并且将每个被选中员工的 ID、名字、姓氏和雇用日期都作为一个行返回。</p>
<p>这可以方便地将这些数据传递到其他 PL/SQL 程序，并在必要时进行处理。</p>
<p>总之，Oracle 数据库中的 ROW() 函数用于在 SELECT 语句中创建一组值，并将它们组合成一行。外面的 SELECT 语句可以使用ROW() 函数返回的行数据进行额外的处理或展示。这个函数在构建数据集合时非常有用，因为它可以方便地将多个值组合成一个行，而无需创建实际的表。</p>
<h4 id="Oracle-PIPE"><a href="#Oracle-PIPE" class="headerlink" title="Oracle PIPE"></a>Oracle PIPE</h4><p><code>PIPE</code> 是在 Oracle 数据库中用于创建和定义 PL/SQL 管道的一种特定类型的对象。PL/SQL 管道允许以流的形式在多个 PL/SQL 环境中共享数据，可以在 PL/SQL 程序之间或在 PL/SQL 和 SQL 语句之间传递数据。</p>
<p>使用 PIPE 可以将数据流发送到一个或多个消费者中，从而构建更为灵活和高效的应用程序。在使用 PIPE 时，首先需要定义一个 PIPE 对象，然后编写生产者和消费者的代码，以便根据需要生成或使用数据。</p>
<p>以下是一个简单的示例，展示了如何使用 PIPE 在两个 PL/SQL 程序之间共享数据：</p>
<p>首先，创建一个 PIPE 对象：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE TYPE my_pipe_type <span class="keyword">AS</span> OBJECT (<span class="keyword">value</span> VARCHAR2(<span class="number">50</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE TYPE my_pipe_type_list <span class="keyword">AS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> my_pipe_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE PACKAGE my_pipe_pkg <span class="keyword">AS</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">FUNCTION</span> my_pipe (input VARCHAR2) <span class="keyword">RETURN</span> my_pipe_type_list PIPELINED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span></span><br></pre></td></tr></table></figure>

<p>这个代码段中定义了一个 PIPE 的类型 <code>my_pipe_type</code> 和 <code>my_pipe_type_list</code>，以及一个存放在 <code>my_pipe_pkg</code> 包中的 PIPE 程序 <code>my_pipe</code>。这个 PIPE 程序接收一个字符串作为输入，并将 <code>my_pipe_type</code> 对象逐行返回 PIPE。</p>
<p>然后，创建一个 PIPE 生产者：</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">PROCEDURE</span> my_pipe_producer</span><br><span class="line"></span><br><span class="line"><span class="keyword">IS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">FOR</span> i <span class="keyword">IN</span> <span class="number">1.</span><span class="number">.10</span></span><br><span class="line"></span><br><span class="line"> LOOP</span><br><span class="line"></span><br><span class="line">  PIPE <span class="type">ROW</span> (my_pipe_type(<span class="string">&#x27;Value &#x27;</span> <span class="operator">||</span> i));</span><br><span class="line"></span><br><span class="line"> <span class="keyword">END</span> LOOP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span></span><br></pre></td></tr></table></figure>

<p>这个代码段中定义了一个 <code>my_pipe_producer</code> 程序，用于生成一系列 <code>my_pipe_type</code> 对象，并将它们逐行返回管道。</p>
<p>最后，创建一个 PIPE 消费者：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">PROCEDURE</span> my_pipe_consumer</span><br><span class="line"></span><br><span class="line"><span class="keyword">IS</span></span><br><span class="line"></span><br><span class="line"> l_value my_pipe_type_list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"> l_value :<span class="operator">=</span> my_pipe_pkg.my_pipe(<span class="string">&#x27;Input Value&#x27;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">FOR</span> i <span class="keyword">IN</span> <span class="number">1.</span>.l_value.COUNT</span><br><span class="line"></span><br><span class="line"> LOOP</span><br><span class="line"></span><br><span class="line">  DBMS_OUTPUT.PUT_LINE(l_value(i).<span class="keyword">value</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">END</span> LOOP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span></span><br></pre></td></tr></table></figure>

<p>这个代码段中定义了一个 <code>my_pipe_consumer</code> 程序，用于从管道中获取 <code>my_pipe_type</code> 对象，并逐个打印它们的值。在这个程序中，我们首先调用了 <code>my_pipe_pkg.my_pipe</code> 程序来获取传递给管道的 <code>my_pipe_type</code> 对象，然后使用 <code>FOR</code> 循环迭代这些对象，并使用 <code>DBMS_OUTPUT.PUT_LINE</code> 打印它们的值。</p>
<p>运行上述程序后，可以在 SQL Plus 控制台上看到 <code>my_pipe_consumer</code> 程序输出的数据。</p>
<p>总之，PIPE 是在 Oracle 中用于创建和定义 PL/SQL 管道的一种特定类型的对象，可以用于在多个 PL/SQL 程序之间或在 PL/SQL 和 SQL 语句之间传递数据。通过定义生产者和消费者的代码，我们可以灵活地生成或使用数据，从而构建更高效和灵活的应用程序。</p>
<h4 id="Oracle-PIPELINED"><a href="#Oracle-PIPELINED" class="headerlink" title="Oracle PIPELINED"></a>Oracle PIPELINED</h4><p><code>PIPELINED</code> 是在 Oracle 数据库中用于创建和定义返回集合的函数的一种选项。使用 <code>PIPELINED</code> 关键字定义的函数将被认为是返回一系列行（或元组）的函数，每当一个行被生成时就会提供结果集，而不是在所有行都生成时才返回整个结果集。</p>
<p>使用 <code>PIPELINED</code> 让函数更像是一个生成器，可以一行一行地产生数据，而不是像普通函数那样一口气返回所有数据。这种方式可以提高函数的效率和响应时间，特别是当返回的数据集较大时，更加明显。</p>
<p>下面是一个例子，展示了如何使用 <code>PIPELINED</code> 返回一个包含数字的数据集：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE FUNCTION GENERATE_NUMBERS(max_num NUMBER)</span><br><span class="line"></span><br><span class="line">  RETURN sys.odcinumberlist</span><br><span class="line"></span><br><span class="line">  PIPELINED IS</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">  FOR i IN 1 .. max_num LOOP</span><br><span class="line"></span><br><span class="line">    PIPE ROW(i);</span><br><span class="line"></span><br><span class="line">  END LOOP;</span><br><span class="line"></span><br><span class="line">  RETURN;</span><br><span class="line"></span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>这个函数接收一个数字 <code>max_num</code>，然后返回一个包含从 1 到 <code>max_num</code> 的数字序列的数据集。这个函数使用了 <code>PIPELINED</code> 关键字，以便在生成数据时可以逐行返回结果集。</p>
<p>在使用这个函数时，可以按照如下方式进行操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM TABLE(GENERATE_NUMBERS(10));</span><br></pre></td></tr></table></figure>

<p>这个 SQL 语句会返回一个包含 10 行数据的结果集，每一行表示一个数字。由于使用了 <code>PIPELINED</code>，函数将逐行返回结果，因此查询操作会比使用普通函数更加高效。</p>
<p>总之，<code>PIPELINED</code> 是一个在 Oracle 中用于定义返回集合的函数的选项，它可以让函数一行一行地生成数据，并逐行返回结果集，提高函数的效率和响应时间。</p>
<h4 id="Oracle-PLS-INTEGE"><a href="#Oracle-PLS-INTEGE" class="headerlink" title="Oracle PLS_INTEGE"></a>Oracle PLS_INTEGE</h4><p><code>PLS_INTEGER</code> 是 Oracle 数据库中一种整数类型，它是 <code>BINARY_INTEGER</code> 的别名，用于存储大于等于 -2^31 而小于等于 2^31-1 的整数。</p>
<p><code>PLS_INTEGER</code> 和 <code>BINARY_INTEGER</code> 的区别在于：</p>
<p>- <code>PLS_INTEGER</code> 是一个可移植数据类型，而 <code>BINARY_INTEGER</code> 是一个实现特定的数据类型。<code>PLS_INTEGER</code> 的范围在不同的 Oracle 版本中是一样的，而 <code>BINARY_INTEGER</code> 的范围可能会因实现而异。</p>
<p>- 对于使用 <code>PLS_INTEGER</code> 类型的变量，如果期望变量的值超出范围会引发一个运行时异常；而对于使用 <code>BINARY_INTEGER</code> 类型的变量，如果变量值超出了范围，它将会在编译时发出一个警告。</p>
<p>在 PL/SQL 中，使用 <code>PLS_INTEGER</code> 变量的好处在于，它可以提供更好的性能和可移植性。由于 <code>PLS_INTEGER</code> 的范围固定，因此 Oracle 在编译时可以优化代码，以避免需要在运行时进行范围检查。这种优化可以在某些情况下提高程序的性能。同时，<code>PLS_INTEGER</code> 是一个可移植的数据类型，因此在不同的 Oracle 版本之间移植代码时，可以避免由于范围的不同而导致的问题。</p>
<p>以下是一个使用 <code>PLS_INTEGER</code> 类型的简单示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE</span><br><span class="line"></span><br><span class="line"> x PLS_INTEGER := 10;</span><br><span class="line"></span><br><span class="line"> y PLS_INTEGER := 20;</span><br><span class="line"></span><br><span class="line"> z PLS_INTEGER;</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line"> z := x + y;</span><br><span class="line"></span><br><span class="line"> DBMS_OUTPUT.PUT_LINE(&#x27;z = &#x27; || z);</span><br><span class="line"></span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>以上代码将声明三个 <code>PLS_INTEGER</code> 类型的变量，计算它们的和，并输出结果。注意，<code>PLS_INTEGER</code> 类型的变量赋值时需要使用 <code>:=</code> 操作符，而不是 <code>=</code> 操作符。</p>
<p>总之，<code>PLS_INTEGER</code> 类型是 Oracle 中的一种优化整数类型，可以在一定程度上提高程序的性能。在编写需要处理整数的 PL/SQL 代码时，可以考虑使用 <code>PLS_INTEGER</code> 类型来获得更好的性能和可移植性。</p>
<h4 id="Oracle-sys-DBMS-DEBUG-VC2COLL"><a href="#Oracle-sys-DBMS-DEBUG-VC2COLL" class="headerlink" title="Oracle sys.DBMS_DEBUG_VC2COLL"></a>Oracle sys.DBMS_DEBUG_VC2COLL</h4><p>sys.DBMS_DEBUG_VC2COLL` 是 Oracle 数据库中提供的一种类型定义，用于在 PL/SQL 中定义一个 Varchar2 数组类型。这个类型是用于调试目的而创建的，一般不用于实际应用。</p>
<p>该类型定义位于 <code>SYS.DBMS_DEBUG</code> 包中，它定义了一组用于调试的子程序和函数。其中，<code>sys.DBMS_DEBUG_VC2COLL</code> 定义一个单列的 <code>Varchar2</code> 数组类型。</p>
<p>可以使用以下方法来创建一个包含 <code>sys.DBMS_DEBUG_VC2COLL</code> 类型变量的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE FUNCTION MY_FUNCTION RETURN sys.DBMS_DEBUG_VC2COLL IS</span><br><span class="line"></span><br><span class="line">  l_var sys.DBMS_DEBUG_VC2COLL;</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">  l_var(1) := &#x27;test1&#x27;;</span><br><span class="line"></span><br><span class="line">  l_var(2) := &#x27;test2&#x27;;</span><br><span class="line"></span><br><span class="line">  l_var(3) := &#x27;test3&#x27;;</span><br><span class="line"></span><br><span class="line">  RETURN l_var;</span><br><span class="line"></span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>上面的函数将返回一个包含 “test1”、”test2” 和 “test3” 三个元素的字符串数组。</p>
<p>需要注意的是，<code>sys.DBMS_DEBUG_VC2COLL</code> 类型并不是 Oracle 官方正式支持的类型之一，因此不建议在实际应用中使用该类型，而是应该使用 Oracle 提供的正式类型。</p>
<h4 id="Oracle-自定义SPLIT和SPLITSTR函数批量分隔字符串"><a href="#Oracle-自定义SPLIT和SPLITSTR函数批量分隔字符串" class="headerlink" title="Oracle 自定义SPLIT和SPLITSTR函数批量分隔字符串"></a>Oracle 自定义SPLIT和SPLITSTR函数批量分隔字符串</h4><p>RACLE使用SPLIT和SPLITSTR函数批量分隔字符串</p>
<p>项目中有很多需要做批量操作的需求，客户端把一组逗号分隔的ID字符串传给数据库，存储过程就需要把它们分割，然后逐个处理。</p>
<p>ORACLE没有提供类似JAVA中SPLIT的函数来将字符串分割成数组,需要开发者自己搞定.</p>
<p>首先定一个数组类型,再定义一个函数或存储过程,处理字符串分割操作,</p>
<p>以往的处理方式有如下几种：</p>
<p>1、在存储过程内写循环，逐个分析字符串中的ID，然后逐个处理。缺点：循环一次处理一个，如果每次判断都很多，效率将很受影响。适合每次处理要做单独判断的情况。</p>
<p>2、使用临时表，先调用一个存储过程将ID拆分并插入到临时表中，然后结合临时表可以写SQL一次处理多笔。缺点：需要插临时表，效率不高，数据量越大影响越严重。</p>
<p>以前的项目用的最多的还是第2中方式，毕竟方便，且效率比第1种好。</p>
<p>ORACLE添加SPLIT函数是完全可以实现的，避免了插入临时表，所以效率比上面的第2中方法效率高很多。</p>
<p>后来还添加了SPLITSTR函数，可以很方便获取字符串中的指定节点。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Oracle 创建 split 和 splitstr 函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个表类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE TYPE TABLETYPE <span class="keyword">AS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> VARCHAR2(<span class="number">32676</span>)；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建 split 函数 */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> split(p_list <span class="type">CLOB</span>, p_sep VARCHAR2 :<span class="operator">=</span> <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">RETURN</span> tabletype</span><br><span class="line">    PIPELINED</span><br><span class="line"><span class="comment">/**************************************</span></span><br><span class="line"><span class="comment">    * Name:        split</span></span><br><span class="line"><span class="comment">    * Author:      Xing Deng.</span></span><br><span class="line"><span class="comment">    * Date:        2023-05-03.</span></span><br><span class="line"><span class="comment">    * Function:    返回字符串被指定字符分割后的表类型。</span></span><br><span class="line"><span class="comment">    * Parameters:  p_list: 待分割的字符串。</span></span><br><span class="line"><span class="comment">                   p_sep: 分隔符，默认逗号，也可以指定字符或字符串。</span></span><br><span class="line"><span class="comment">    * Example:     SELECT *</span></span><br><span class="line"><span class="comment">                     FROM users</span></span><br><span class="line"><span class="comment">                   WHERE u_id IN (SELECT COLUMN_VALUE</span></span><br><span class="line"><span class="comment">                                     FROM table (split (&#x27;1,2&#x27;)))</span></span><br><span class="line"><span class="comment">                  返回u_id为1和2的两行数据。</span></span><br><span class="line"><span class="comment">    **************************************/</span></span><br><span class="line"> <span class="keyword">IS</span></span><br><span class="line">    l_idx  PLS_INTEGER;</span><br><span class="line">    v_list VARCHAR2(<span class="number">32676</span>) :<span class="operator">=</span> p_list;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    LOOP</span><br><span class="line">        l_idx :<span class="operator">=</span> INSTR(v_list, p_sep);</span><br><span class="line">    </span><br><span class="line">        IF l_idx <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">            PIPE <span class="type">ROW</span>(SUBSTR(v_list, <span class="number">1</span>, l_idx <span class="operator">-</span> <span class="number">1</span>));</span><br><span class="line">            v_list :<span class="operator">=</span> SUBSTR(v_list, l_idx <span class="operator">+</span> LENGTH(p_sep));</span><br><span class="line">        <span class="keyword">ELSE</span></span><br><span class="line">            PIPE <span class="type">ROW</span>(v_list);</span><br><span class="line">            EXIT;</span><br><span class="line">        <span class="keyword">END</span> IF;</span><br><span class="line">    <span class="keyword">END</span> LOOP;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建 splitstr 函数 */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> splitstr(str <span class="keyword">IN</span> <span class="type">CLOB</span>,</span><br><span class="line">                                    i   <span class="keyword">IN</span> NUMBER :<span class="operator">=</span> <span class="number">0</span>,</span><br><span class="line">                                    sep <span class="keyword">IN</span> VARCHAR2 :<span class="operator">=</span> <span class="string">&#x27;,&#x27;</span>) <span class="keyword">RETURN</span> VARCHAR2</span><br><span class="line"><span class="comment">/**************************************</span></span><br><span class="line"><span class="comment">    * Name:        splitstr</span></span><br><span class="line"><span class="comment">    * Author:      Sean Zhang.</span></span><br><span class="line"><span class="comment">    * Date:        2012-09-03.</span></span><br><span class="line"><span class="comment">    * Function:    返回字符串被指定字符分割后的指定节点字符串。</span></span><br><span class="line"><span class="comment">    * Parameters:  str: 待分割的字符串。</span></span><br><span class="line"><span class="comment">                   i: 返回第几个节点。当i为0返回str中的所有字符，当i 超过可被分割的个数时返回空。</span></span><br><span class="line"><span class="comment">                   sep: 分隔符，默认逗号，也可以指定字符或字符串。当指定的分隔符不存在于str中时返回sep中的字符。</span></span><br><span class="line"><span class="comment">    * Example:     select splitstr(&#x27;abc,def&#x27;, 1) as str from dual;  得到 abc</span></span><br><span class="line"><span class="comment">                   select splitstr(&#x27;abc,def&#x27;, 3) as str from dual;  得到 空</span></span><br><span class="line"><span class="comment">    **************************************/</span></span><br><span class="line"> <span class="keyword">IS</span></span><br><span class="line">    t_i     NUMBER;</span><br><span class="line">    t_count NUMBER;</span><br><span class="line">    t_str   VARCHAR2(<span class="number">4000</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    IF i <span class="operator">=</span> <span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">        t_str :<span class="operator">=</span> str;</span><br><span class="line">    ELSIF INSTR(str, sep) <span class="operator">=</span> <span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">        t_str :<span class="operator">=</span> sep;</span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> t_count <span class="keyword">FROM</span> <span class="keyword">table</span>(split(str, sep));</span><br><span class="line"></span><br><span class="line">        IF i <span class="operator">&lt;=</span> t_count <span class="keyword">THEN</span></span><br><span class="line">            <span class="keyword">SELECT</span> str</span><br><span class="line">              <span class="keyword">INTO</span> t_str</span><br><span class="line">              <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> ROWNUM <span class="keyword">AS</span> item, COLUMN_VALUE <span class="keyword">AS</span> str</span><br><span class="line">                      <span class="keyword">FROM</span> <span class="keyword">table</span>(split(str, sep)))</span><br><span class="line">             <span class="keyword">WHERE</span> item <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">END</span> IF;</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">RETURN</span> t_str;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<h4 id="Oracle-REGEXP-SUBSTR"><a href="#Oracle-REGEXP-SUBSTR" class="headerlink" title="Oracle REGEXP_SUBSTR"></a>Oracle REGEXP_SUBSTR</h4><p>在 Oracle 中，可以使用 <code>REGEXP_SUBSTR</code> 函数来进行字符串分隔。以下是一个示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> REGEXP_SUBSTR(<span class="string">&#x27;A,B,C,D,E&#x27;</span>, <span class="string">&#x27;[^,]+&#x27;</span>, <span class="number">1</span>, LEVEL) <span class="keyword">result</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> dual</span><br><span class="line"></span><br><span class="line"><span class="keyword">CONNECT</span> <span class="keyword">BY</span> LEVEL <span class="operator">&lt;=</span> REGEXP_COUNT(<span class="string">&#x27;A,B,C,D,E&#x27;</span>, <span class="string">&#x27;,&#x27;</span>) <span class="operator">+</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RESULT </span><br><span class="line"></span><br><span class="line">--------</span><br><span class="line"></span><br><span class="line">A    </span><br><span class="line"></span><br><span class="line">B    </span><br><span class="line"></span><br><span class="line">C    </span><br><span class="line"></span><br><span class="line">D    </span><br><span class="line"></span><br><span class="line">E    </span><br></pre></td></tr></table></figure>

<p>在上面的示例中，使用了 <code>REGEXP_SUBSTR</code> 函数和 <code>CONNECT BY LEVEL</code> 子句来对字符串进行分隔。<code>REGEXP_SUBSTR</code> 函数使用正则表达式来匹配字符串中的子串，<code>CONNECT BY LEVEL</code> 子句用于循环将字符串分段。<code>REGEXP_COUNT</code> 函数用于计算分隔符出现的次数，从而确定分割的次数。</p>
<p>当然，你也可以将该查询语句封装成一个函数，实现批量分隔字符串的功能。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> SPLITSTR (</span><br><span class="line"></span><br><span class="line">  p_str <span class="keyword">IN</span> VARCHAR2,</span><br><span class="line"></span><br><span class="line">  p_delimiter <span class="keyword">IN</span> VARCHAR2</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">RETURN</span> sys.DBMS_DEBUG_VC2COLL</span><br><span class="line"></span><br><span class="line"><span class="keyword">IS</span></span><br><span class="line"></span><br><span class="line">  l_tablen PLS_INTEGER;</span><br><span class="line"></span><br><span class="line">  l_arr sys.DBMS_DEBUG_VC2COLL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> REGEXP_COUNT(p_str, p_delimiter) <span class="operator">+</span> <span class="number">1</span> <span class="keyword">INTO</span> l_tablen <span class="keyword">FROM</span> dual;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> REGEXP_SUBSTR(p_str, <span class="string">&#x27;[^&#x27;</span> <span class="operator">||</span> p_delimiter <span class="operator">||</span> <span class="string">&#x27;]+&#x27;</span>, <span class="number">1</span>, LEVEL)</span><br><span class="line"></span><br><span class="line">  BULK <span class="keyword">COLLECT</span> <span class="keyword">INTO</span> l_arr <span class="keyword">FROM</span> dual</span><br><span class="line"></span><br><span class="line">  <span class="keyword">CONNECT</span> <span class="keyword">BY</span> LEVEL <span class="operator">&lt;=</span> l_tablen;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">RETURN</span> l_arr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span> SPLITSTR;</span><br></pre></td></tr></table></figure>



<p>该函数的参数为要分割的字符串和分隔符，返回值为一个字符串数组。可以使用以下的方式调用该函数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> COLUMN_VALUE results FROTABLEM (SPLITSTR(<span class="string">&#x27;A,B,C,D,E&#x27;</span>, <span class="string">&#x27;,&#x27;</span>));</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RESULT </span><br><span class="line"></span><br><span class="line">--------</span><br><span class="line"></span><br><span class="line">A    </span><br><span class="line"></span><br><span class="line">B    </span><br><span class="line"></span><br><span class="line">C    </span><br><span class="line"></span><br><span class="line">D    </span><br><span class="line"></span><br><span class="line">E    </span><br></pre></td></tr></table></figure>

<p>这样就可以快速地实现批量分隔字符串的功能了。</p>
<h4 id="Oracle-CONNECT-BY"><a href="#Oracle-CONNECT-BY" class="headerlink" title="Oracle CONNECT BY"></a>Oracle CONNECT BY</h4><p>在 Oracle 数据库中，没有内置的 <code>SPLIT</code> 和 <code>SPLITSTR</code> 函数，但可以使用 <code>REGEXP_SUBSTR</code> 函数配合 <code>CONNECT BY</code> 子句或者采用其他方法来实现字符串的分割。</p>
<p>以下是一个使用 <code>REGEXP_SUBSTR</code> 函数和 <code>CONNECT BY</code> 子句来实现字符串分割的示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">TRIM</span>(REGEXP_SUBSTR(<span class="string">&#x27;A,B,C,D,E&#x27;</span>, <span class="string">&#x27;[^,]+&#x27;</span>, <span class="number">1</span>, LEVEL) ) results</span><br><span class="line"></span><br><span class="line"> <span class="keyword">FROM</span> dual</span><br><span class="line"></span><br><span class="line"><span class="keyword">CONNECT</span> <span class="keyword">BY</span> REGEXP_SUBSTR(<span class="string">&#x27;A,B,C,D,E&#x27;</span>, <span class="string">&#x27;[^,]+&#x27;</span>, <span class="number">1</span>, LEVEL) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RESULT </span><br><span class="line"></span><br><span class="line">--------</span><br><span class="line"></span><br><span class="line">A    </span><br><span class="line"></span><br><span class="line">B    </span><br><span class="line"></span><br><span class="line">C    </span><br><span class="line"></span><br><span class="line">D    </span><br><span class="line"></span><br><span class="line">E </span><br></pre></td></tr></table></figure>



<p>以上 SQL 语句将以逗号为分隔符的字符串 <code>&#39;A,B,C,D,E&#39;</code> 分割成多个子串，并将其作为结果集返回。</p>
<p>如果需要将字符串的分割结果存储到一个 <code>VARCHAR2</code> 数组变量中，可以使用 <code>BULK COLLECT</code> 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line"></span><br><span class="line">  TYPE t_results <span class="keyword">IS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> VARCHAR2(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  t_res t_results;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="built_in">TRIM</span>(REGEXP_SUBSTR(<span class="string">&#x27;A,B,C,D,E&#x27;</span>, <span class="string">&#x27;[^,]+&#x27;</span>, <span class="number">1</span>, LEVEL) ) </span><br><span class="line"></span><br><span class="line">  BULK <span class="keyword">COLLECT</span> <span class="keyword">INTO</span> t_res</span><br><span class="line"></span><br><span class="line">  <span class="keyword">FROM</span> dual</span><br><span class="line"></span><br><span class="line">  <span class="keyword">CONNECT</span> <span class="keyword">BY</span> REGEXP_SUBSTR(<span class="string">&#x27;A,B,C,D,E&#x27;</span>, <span class="string">&#x27;[^,]+&#x27;</span>, <span class="number">1</span>, LEVEL) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">FOR</span> i <span class="keyword">IN</span> t_res.FIRST..t_res.LAST LOOP</span><br><span class="line"></span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(t_res(i));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">END</span> LOOP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>

<p>以上示例使用 <code>BULK COLLECT</code> 将分割后的结果集存储到 <code>t_res</code> 变量中，然后逐个输出每个子串。</p>
<p>此外，还可以通过自定义函数的方式来实现字符串的批量分割，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE TYPE t_results <span class="keyword">AS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> VARCHAR2(<span class="number">4000</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> SPLITSTR(</span><br><span class="line"></span><br><span class="line">  p_str <span class="keyword">IN</span> VARCHAR2,</span><br><span class="line"></span><br><span class="line">  p_delimiter <span class="keyword">IN</span> VARCHAR2</span><br><span class="line"></span><br><span class="line">) <span class="keyword">RETURN</span> t_results <span class="keyword">IS</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">--TYPE t_results IS TABLE OF VARCHAR2(4000);</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  l_tablen PLS_INTEGER;</span><br><span class="line"></span><br><span class="line">  l_arr t_results;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> REGEXP_COUNT(p_str, p_delimiter) <span class="operator">+</span> <span class="number">1</span> <span class="keyword">INTO</span> l_tablen <span class="keyword">FROM</span> dual;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="built_in">TRIM</span>(REGEXP_SUBSTR(p_str, <span class="string">&#x27;[^&#x27;</span> <span class="operator">||</span> p_delimiter <span class="operator">||</span> <span class="string">&#x27;]+&#x27;</span>, <span class="number">1</span>, LEVEL))</span><br><span class="line"></span><br><span class="line">  BULK <span class="keyword">COLLECT</span> <span class="keyword">INTO</span> l_arr <span class="keyword">FROM</span> dual</span><br><span class="line"></span><br><span class="line">  <span class="keyword">CONNECT</span> <span class="keyword">BY</span> LEVEL <span class="operator">&lt;=</span> l_tablen;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">RETURN</span> l_arr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">--TYPE t_results IS TABLE OF VARCHAR2(4000);</span></span><br><span class="line"></span><br><span class="line">  t_res t_results;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">  t_res :<span class="operator">=</span> SPLITSTR(<span class="string">&#x27;A,B,C,D,E&#x27;</span>, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">FOR</span> i <span class="keyword">IN</span> t_res.FIRST..t_res.LAST LOOP</span><br><span class="line"></span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(t_res(i));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">END</span> LOOP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span></span><br></pre></td></tr></table></figure>



<p>以上示例定义了一个名为 <code>SPLITSTR</code> 的函数，函数接受两个参数，一个是要分割的字符串，另一个是分隔符。函数返回一个 <code>VARCHAR2</code> 数组类型的结果集。然后在 PL/SQL 代码中调用该函数，并输出每个子串。</p>
<p>总之，Oracle 数据库中可以使用 <code>REGEXP_SUBSTR</code> 函数、<code>CONNECT BY</code> 子句、<code>BULK COLLECT</code> 等方法来实现字符串的批量分割。大家可以根据自己的实际需求选择合适的方法。</p>
<h4 id="Oracle-INSERT-INTO-SELECT"><a href="#Oracle-INSERT-INTO-SELECT" class="headerlink" title="Oracle INSERT INTO SELECT"></a>Oracle INSERT INTO SELECT</h4><p>INSERT INTO SELECT是一种在 SQL 中用于从一个表格复制数据到另一个表格的语句。其基本语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO table2</span><br><span class="line"></span><br><span class="line">SELECT * FROM table1</span><br><span class="line"></span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure>

<p>其中，table2 代表目标表格，table1 代表源表格，* 表示将所有的列都复制到目标表格中。</p>
<p>在实际使用中，可以根据需要指定所要复制的列名称，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO table2 (col1, col2, col3)</span><br><span class="line"></span><br><span class="line">SELECT col1, col2, col3 FROM table1</span><br><span class="line"></span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure>

<p>这样就只会复制名为 col1、col2 和 col3 的三个列。</p>
<p>在执行 INSERT INTO SELECT 语句时，需要注意源表格和目标表格的列类型和数量必须匹配，否则会出现错误。同时，为了确保数据的安全性和正确性，也应该在执行 INSERT INTO SELECT 语句之前进行数据备份。</p>
<h4 id="Oracle-MINUS-UNION"><a href="#Oracle-MINUS-UNION" class="headerlink" title="Oracle MINUS UNION"></a>Oracle MINUS UNION</h4><p>Minux和Union是Oracle SQL中常用的两种集合运算，它们的区别在于以下几个方面：</p>
<ol>
<li><p>返回结果集的数量： Union操作返回两个查询的并集，即包含两个查询的所有行并去除重复的行，而Minus操作返回的是第一个查询与第二个查询的差集，即第一个查询的结果集中去除在第二个查询结果集中也存在的行。</p>
</li>
<li><p>结果的列：Union和Minus操作要求两个查询的结果集包含相同数量和类型的列。</p>
</li>
<li><p>数据集的排序：Union操作默认按照第一个查询结果集中的列进行排序，Minus操作则没有排序的限制。</p>
</li>
</ol>
<p>下面是一个示例说明：</p>
<p>假设我们有这么两个查询：</p>
<p>Query1：SELECT id FROM table1;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+</span><br><span class="line"></span><br><span class="line">| id |</span><br><span class="line"></span><br><span class="line">+----+</span><br><span class="line"></span><br><span class="line">| 1 |</span><br><span class="line"></span><br><span class="line">| 2 |</span><br><span class="line"></span><br><span class="line">| 3 |</span><br><span class="line"></span><br><span class="line">| 4 |</span><br><span class="line"></span><br><span class="line">+----+</span><br></pre></td></tr></table></figure>

<p>Query2：SELECT id FROM table2;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+</span><br><span class="line"></span><br><span class="line">| id |</span><br><span class="line"></span><br><span class="line">+----+</span><br><span class="line"></span><br><span class="line">| 2 |</span><br><span class="line"></span><br><span class="line">| 3 |</span><br><span class="line"></span><br><span class="line">| 5 |</span><br><span class="line"></span><br><span class="line">| 6 |</span><br><span class="line"></span><br><span class="line">+----+</span><br></pre></td></tr></table></figure>

<p>使用UNION操作的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT id FROM table1</span><br><span class="line"></span><br><span class="line"> UNION</span><br><span class="line"></span><br><span class="line">SELECT id FROM table2;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">+----+</span><br><span class="line"></span><br><span class="line">| id |</span><br><span class="line"></span><br><span class="line">+----+</span><br><span class="line"></span><br><span class="line">| 1 |</span><br><span class="line"></span><br><span class="line">| 2 |</span><br><span class="line"></span><br><span class="line">| 3 |</span><br><span class="line"></span><br><span class="line">| 5 |</span><br><span class="line"></span><br><span class="line">| 6 |</span><br><span class="line"></span><br><span class="line">+----+</span><br></pre></td></tr></table></figure>

<p>使用MINUS操作的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT id FROM table1</span><br><span class="line"></span><br><span class="line"> MINUS</span><br><span class="line"></span><br><span class="line">SELECT id FROM table2;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">+----+</span><br><span class="line"></span><br><span class="line">| id |</span><br><span class="line"></span><br><span class="line">+----+</span><br><span class="line"></span><br><span class="line">| 1 |</span><br><span class="line"></span><br><span class="line">| 4 |</span><br><span class="line"></span><br><span class="line">+----+ </span><br></pre></td></tr></table></figure>

<p>这里可以看出，UNION操作返回了两个查询的并集，并去掉了重复项，而MINUS操作返回了第一个查询结果集中存在，但在第二个查询结果集中不存在的行。</p>
<p>结论</p>
<p>MINUS</p>
<p>SELECT * FROM table_a MINUS SELECT * FROM table_b; –取A表中有且B表中无的</p>
<p>UNION</p>
<p>SELECT * FROM table_a UNION SELECT * FROM table_b; –取A表中有或B表中有的</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://dengliantong.cn">Xing Deng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://dengliantong.cn/2023/06/03/Oracle-EBS-R12-DBA/">http://dengliantong.cn/2023/06/03/Oracle-EBS-R12-DBA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://dengliantong.cn" target="_blank">互联网新贵邓醒</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://images6.alphacoders.com/337/337255.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/06/10/Oracle-EBS-R12-%E6%8E%A5%E5%8F%A3%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/" title="Oracle EBS R12 接口参考文档"><img class="cover" src="/img/loading.gif" data-original="https://images3.alphacoders.com/103/103237.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Oracle EBS R12 接口参考文档</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xing Deng</div><div class="author-info__description">起风了,唯有努力生存!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/waFroppy"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome To My Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%9C%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">Oracle 索引的作用以及失效的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-%E6%8A%A5%E6%96%87"><span class="toc-text">Oracle 报文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-%E4%B8%B4%E6%97%B6%E8%A1%A8"><span class="toc-text">Oracle 临时表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-GoldenGate"><span class="toc-text">Oracle GoldenGate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-DatabaseLink"><span class="toc-text">Oracle DatabaseLink</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE"><span class="toc-text">Oracle 物化视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-userenv-%E2%80%98LANG%E2%80%99"><span class="toc-text">Oracle userenv(‘LANG’)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-SYNONYM-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">Oracle SYNONYM 的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-EXISTS"><span class="toc-text">Oracle EXISTS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-EBS-fnd-global-apps-initialize"><span class="toc-text">Oracle  EBS fnd_global.apps_initialize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-EBS-mo-global-set-policy-context"><span class="toc-text">Oracle EBS mo_global.set_policy_context</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-EBS-fnd-request-submit-request"><span class="toc-text">Oracle EBS fnd_request.submit_request</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-EBS-oe-order-pub-header-rec-type"><span class="toc-text">Oracle EBS oe_order_pub.header_rec_type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-EBS-oe-order-pub-line-tbl-type"><span class="toc-text">Oracle EBS oe_order_pub.line_tbl_type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-EBS-oe-order-pub-request-tbl-type"><span class="toc-text">Oracle EBS oe_order_pub.request_tbl_type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-EBS-oe-order-pub-g-miss-header-rec"><span class="toc-text">Oracle EBS oe_order_pub.g_miss_header_rec</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-EBS-oe-msg-pub-initialize"><span class="toc-text">Oracle EBS oe_msg_pub.initialize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-EBS-dbms-output-enable-1000000"><span class="toc-text">Oracle EBS dbms_output.enable(1000000)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-EBS-oe-holds-pvt"><span class="toc-text">Oracle EBS oe_holds_pvt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-EBS-setContext-retcode-errbuf"><span class="toc-text">Oracle EBS  setContext(retcode, errbuf)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-EBS-FND-FILE-OUTPUT"><span class="toc-text">Oracle EBS FND_FILE.OUTPUT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-EBS-FND-FILE-OUTPUT-1"><span class="toc-text">Oracle EBS  FND_FILE.OUTPUT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-TYPE-IS-RECORD"><span class="toc-text">Oracle  TYPE IS RECORD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-TYPE-IS-TABLE-OF-INDEX-BY-BINARY-INTEGER"><span class="toc-text">Oracle TYPE IS TABLE OF INDEX BY BINARY_INTEGER</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-FETCH-BULK-COLLECT-INTO"><span class="toc-text">Oracle FETCH BULK COLLECT INTO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-NOCPY"><span class="toc-text">Oracle NOCPY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-GOTO"><span class="toc-text">Oracle GOTO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-ROLLBACK"><span class="toc-text">Oracle ROLLBACK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-PRAGMA-AUTONOMOUS-TRANSACTION"><span class="toc-text">Oracle PRAGMA AUTONOMOUS_TRANSACTION</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-dbms-utility-format-error-backtrace"><span class="toc-text">Oracle dbms_utility.format_error_backtrace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-fnd-global-user-id"><span class="toc-text">Oracle fnd_global.user_id</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-INSTR-SUBSTR"><span class="toc-text">Oracle INSTR  SUBSTR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-ROW"><span class="toc-text">Oracle ROW()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-PIPE"><span class="toc-text">Oracle PIPE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-PIPELINED"><span class="toc-text">Oracle PIPELINED</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-PLS-INTEGE"><span class="toc-text">Oracle PLS_INTEGE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-sys-DBMS-DEBUG-VC2COLL"><span class="toc-text">Oracle sys.DBMS_DEBUG_VC2COLL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-%E8%87%AA%E5%AE%9A%E4%B9%89SPLIT%E5%92%8CSPLITSTR%E5%87%BD%E6%95%B0%E6%89%B9%E9%87%8F%E5%88%86%E9%9A%94%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">Oracle 自定义SPLIT和SPLITSTR函数批量分隔字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-REGEXP-SUBSTR"><span class="toc-text">Oracle REGEXP_SUBSTR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-CONNECT-BY"><span class="toc-text">Oracle CONNECT BY</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-INSERT-INTO-SELECT"><span class="toc-text">Oracle INSERT INTO SELECT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Oracle-MINUS-UNION"><span class="toc-text">Oracle MINUS UNION</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/10/18/Elasticsearch/" title="无题"><img src="/img/loading.gif" data-original="https://images3.alphacoders.com/103/103237.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/10/18/Elasticsearch/" title="无题">无题</a><time datetime="2023-10-18T09:26:51.193Z" title="发表于 2023-10-18 17:26:51">2023-10-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/20/JavaWeb/" title="JavaWeb"><img src="/img/loading.gif" data-original="https://images3.alphacoders.com/103/103237.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaWeb"/></a><div class="content"><a class="title" href="/2023/09/20/JavaWeb/" title="JavaWeb">JavaWeb</a><time datetime="2023-09-20T01:39:10.000Z" title="发表于 2023-09-20 09:39:10">2023-09-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/20/Java%E5%9F%BA%E7%A1%80/" title="Java基础"><img src="/img/loading.gif" data-original="https://images.alphacoders.com/484/484614.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础"/></a><div class="content"><a class="title" href="/2023/09/20/Java%E5%9F%BA%E7%A1%80/" title="Java基础">Java基础</a><time datetime="2023-09-20T01:38:45.000Z" title="发表于 2023-09-20 09:38:45">2023-09-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/19/SSM%E6%A1%86%E6%9E%B6/" title="SSM框架"><img src="/img/loading.gif" data-original="https://images3.alphacoders.com/103/103237.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SSM框架"/></a><div class="content"><a class="title" href="/2023/09/19/SSM%E6%A1%86%E6%9E%B6/" title="SSM框架">SSM框架</a><time datetime="2023-09-19T07:55:40.000Z" title="发表于 2023-09-19 15:55:40">2023-09-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/12/Oracle-EBS-R12-%E9%87%87%E8%B4%AD%E5%88%B0%E5%BA%94%E4%BB%98%E4%BA%A7%E7%94%9F%E7%9A%84%E4%BC%9A%E8%AE%A1%E5%88%86%E5%BD%95/" title="Oracle EBS R12 采购到应付产生的会计分录"><img src="/img/loading.gif" data-original="https://images6.alphacoders.com/337/337255.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Oracle EBS R12 采购到应付产生的会计分录"/></a><div class="content"><a class="title" href="/2023/06/12/Oracle-EBS-R12-%E9%87%87%E8%B4%AD%E5%88%B0%E5%BA%94%E4%BB%98%E4%BA%A7%E7%94%9F%E7%9A%84%E4%BC%9A%E8%AE%A1%E5%88%86%E5%BD%95/" title="Oracle EBS R12 采购到应付产生的会计分录">Oracle EBS R12 采购到应付产生的会计分录</a><time datetime="2023-06-12T00:58:47.000Z" title="发表于 2023-06-12 08:58:47">2023-06-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://images6.alphacoders.com/337/337255.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Xing Deng</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="富强,民主,文明,和谐,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>