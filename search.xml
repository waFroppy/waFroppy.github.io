<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaWeb</title>
      <link href="/2023/09/20/JavaWeb/"/>
      <url>/2023/09/20/JavaWeb/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2023/09/20/Java%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/09/20/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a><strong>常量</strong></h3><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a><strong>变量</strong></h3><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a><strong>类型</strong></h3><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a><strong>运算符</strong></h3><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a><strong>方法</strong></h3><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a><strong>流程控制</strong></h3><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a><strong>数组</strong></h3><h3 id="类"><a href="#类" class="headerlink" title="类"></a><strong>类</strong></h3><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a><strong>对象</strong></h3><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a><strong>封装</strong></h3><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h3><h3 id="静态"><a href="#静态" class="headerlink" title="静态"></a><strong>静态</strong></h3><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h3><h3 id="String"><a href="#String" class="headerlink" title="String"></a><strong>String</strong></h3><h3 id="super"><a href="#super" class="headerlink" title="super"></a><strong>super</strong></h3><h3 id="this"><a href="#this" class="headerlink" title="this"></a><strong>this</strong></h3><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a><strong>抽象类</strong></h3><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a><strong>接口</strong></h3><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a><strong>多态</strong></h3><h3 id="final"><a href="#final" class="headerlink" title="final"></a><strong>final</strong></h3><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a><strong>权限</strong></h3><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a><strong>内部类</strong></h3><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a><strong>集合</strong></h3><p>Collection:单列集合</p><p><code>List</code>的特点是元素有序、元素可重复。</p><p><code>Set</code>的特点是元素无序，而且不可重复。</p><p><code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code></p><p><code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code></p><ul><li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li><li><code>public void clear()</code> :清空集合中所有的元素。</li><li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li><li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li><li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li><li><code>public int size()</code>: 返回集合中元素的个数。</li><li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li></ul><h3 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a><strong>Iterator迭代器</strong></h3><p><strong>Iterator接口</strong></p><ul><li><code>public E next()</code>:返回迭代的下一个元素。</li><li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a><strong>增强for</strong></h3><p>底层是实现迭代器接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a><strong>泛型</strong></h3><p>好处：</p><ul><li>将运行时期的ClassCastException，转移到了编译时期变成了编译失败。</li><li>避免了类型强转的麻烦。</li></ul><p>自定义泛型类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyGenericClass&lt;MVP&gt; &#123;</span><br><span class="line">//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型</span><br><span class="line">private MVP mvp;</span><br><span class="line"></span><br><span class="line">    public void setMVP(MVP mvp) &#123;</span><br><span class="line">        this.mvp = mvp;</span><br><span class="line">    &#125;</span><br><span class="line">    public MVP getMVP() &#123;</span><br><span class="line">        return mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义泛型方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyGenericMethod &#123;  </span><br><span class="line">    public &lt;MVP&gt; void show1(MVP mvp) &#123;</span><br><span class="line">    System.out.println(mvp.getClass());</span><br><span class="line">    &#125;    </span><br><span class="line">    public &lt;MVP&gt; MVP show2(MVP mvp) &#123;</span><br><span class="line">    return mvp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义泛型接口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface MyGenericInterface&lt;E&gt;&#123;</span><br><span class="line">public abstract void add(E e);</span><br><span class="line">public abstract E getE();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型通配符:</p><p><strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p><p>此时只能接受数据,不能往该集合中存储数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getElement</span><span class="params">(Collection&lt;?&gt; coll)</span>&#123;&#125;</span><br><span class="line"><span class="comment">//？代表可以接收任意类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Collection&lt;Intger&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    getElement(list1);</span><br><span class="line">    Collection&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    getElement(list2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>泛型上限</strong></p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li></ul><p><strong>泛型下限</strong></p><ul><li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li><li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类</span><br><span class="line">public static void getElement1(Collection&lt;? extends Number&gt; coll)&#123;&#125;</span><br><span class="line">// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类</span><br><span class="line">public static void getElement2(Collection&lt;? super Number&gt; coll)&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li><p>堆栈</p><p><strong>栈</strong>：<strong>stack</strong>,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</p><p>采用该结构的集合，对元素的存取有如下的特点</p><ul><li><p>先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</p></li><li><p>栈的入口、出口的都是栈的顶端位置。</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309171804960.png" alt="image-20230917180447896"></p><ul><li><strong>压栈</strong>：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li><li><strong>弹栈</strong>：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li></ul></li></ul></li><li><p>队列</p><p><strong>队列</strong>：<strong>queue</strong>,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</p><p>采用该结构的集合，对元素的存取有如下的特点：</p><ul><li><p>先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。</p></li><li><p>队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309171807256.bmp" alt="队列图"></p></li></ul></li><li><p>数组</p><p><strong>数组</strong>:<strong>Array</strong>,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。</p><p>采用该结构的集合，对元素的存取有如下的特点：</p><ul><li><p>查找元素快：通过索引，可以快速访问指定位置的元素</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309171808875.png" alt="image-20230917180810843"></p></li><li><p>增删元素慢</p><ul><li><p><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309171809969.png" alt="image-20230917180906932"></p></li><li><p><strong>指定索引位置删除元素：</strong>需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309171809989.png" alt="image-20230917180945960"></p></li></ul></li></ul></li><li><p>链表</p><p><strong>链表</strong>:<strong>linked list</strong>,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，这里只说<strong>单向链表</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309171810652.png" alt="image-20230917181045622"></p><p>采用该结构的集合，对元素的存取有如下的特点：</p><ul><li><p>多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</p><p><img src="https://gitee.com/dengxing1277/blogimage/raw/master/imgs/202309211114035.png" alt="image-20230921111426007"></p></li><li><p>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</p></li><li><p>增删元素快：</p><ul><li><p>增加元素：只需要修改连接下个元素的地址即可。</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309171811993.png" alt="image-20230917181131960"></p></li><li><p>删除元素：只需要修改连接下个元素的地址即可。</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309171812342.bmp" alt="删除结点"></p></li></ul></li></ul></li><li><p>红黑树 </p><ul><li><p><strong>二叉树</strong>：<strong>binary tree</strong> ,是每个结点不超过2的有序<strong>树（tree）</strong> 。</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309171813241.bmp" alt="二叉树"></p><p>我们要说的是二叉树的一种比较有意思的叫做<strong>红黑树</strong>，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。</p><p>红黑树的约束:</p><ol><li>节点可以是红色的或者黑色的</li></ol></li></ul></li></ul><pre><code>2. 根节点是黑色的3. 叶子节点(特指空节点)是黑色的4. 每个红色节点的子节点都是黑色的5. 任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同红黑树的特点:​    速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍</code></pre><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>特点:</p><ul><li>它是一个元素存取有序的集合</li><li>它是一个带有索引的集合</li><li>集合中可以有重复的元素,通过元素的equals方法，来比较是否为重复的元素。</li></ul><p><strong>ArrayList</strong></p><p>数组结构,增删慢,查找快,多用于遍历和查找</p><p><strong>LinkedList</strong></p><p>链表结构,增删快</p><p>常用方法</p><ul><li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li><li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li><li><code>public E getFirst()</code>:返回此列表的第一个元素。</li><li><code>public E getLast()</code>:返回此列表的最后一个元素。</li><li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li><li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li><li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li><li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li><li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">list.isEmpty();</span><br><span class="line">list.pop();</span><br><span class="line">list.push(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">list.addFirst(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">list.addLast(<span class="string">&quot;last&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a><strong>Set</strong></h3><p><strong>特点:</strong></p><ul><li>元素无序</li><li>不允许重复</li></ul><p><strong>HashSet</strong></p><p>底层的实现是<code>java.util.HashMap</code>类支持</p><p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p><p>在<strong>JDK1.8</strong>之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p><p>简单的来说，哈希表是由<strong>数组+链表+红黑树</strong>（JDK1.8增加了红黑树部分）实现的，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309171830107.png" alt="image-20230917183042052"></p><p><strong>HashSet存储自定义类型元素</strong></p><p>自定义的存储元素对象必须重写 hashCode() 和equals方法,保证元素的唯一</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//idea 快捷键 Alt+Insert</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Peroson)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> <span class="type">Peroson</span> <span class="variable">peroson</span> <span class="operator">=</span> (Peroson) o;</span><br><span class="line"> <span class="keyword">return</span> id.equals(peroson.id) &amp;&amp; username.equals(peroson.username) &amp;&amp; password.equals(peroson.password);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Objects.hash(id, username, password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可变参数</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型... 形参名)&#123;  &#125;</span><br><span class="line">//等价于</span><br><span class="line">修饰符 返回值类型 方法名(参数类型[] 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure><p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组,这就是简单之处，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。</p><blockquote><p>注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int add(int... arr) &#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i : arr) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections**"></a>Collections**</h3><ul><li><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。部分方法如下：</li></ul><ul><li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)  </code>:往集合中添加一些元素。</li><li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li><li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li></ul><p><strong>Comparator比较器</strong></p><p><code>java.lang.Comparable</code></p><p><code>java.util.Comparator</code></p><ul><li><code> public int compare(String o1, String o2)</code>：比较其两个参数的顺序。</li></ul><blockquote><p>两个对象比较的结果有三种：大于，等于，小于。</p><p>如果要按照升序排序，<br>则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）<br>如果要按照降序排序<br>则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）</p></blockquote><p><strong>Comparable和Comparator的区别</strong></p><p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。</p><p><strong>Comparator</strong>强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">20</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">22</span>));</span><br><span class="line">        students.add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Charlie&quot;</span>, <span class="number">18</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用Comparator比较器按学生年龄进行排序</span></span><br><span class="line">        Collections.sort(students, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student s1, Student s2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> s1.getAge() - s2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输出排序后的学生列表</span></span><br><span class="line">        <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">            System.out.println(student.getName() + <span class="string">&quot; - &quot;</span> + student.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map&lt;key,value&gt;</p><p>value可以重复,key不能重复</p><ul><li>**HashMap&lt;K,V&gt;**：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li><li>**LinkedHashMap&lt;K,V&gt;**：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li></ul><blockquote><p>tips：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。</p></blockquote><p><strong>常用方法</strong></p><ul><li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li><li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li><li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li><li><code>boolean containsKey(Object key)  </code> 判断集合中是否包含指定的键。</li><li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><blockquote><p>tips:</p><p>使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； </p><p>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。 </p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">put1</span> <span class="operator">=</span> stringStringMap.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;102&quot;</span>);</span><br><span class="line">System.out.println(put1);<span class="comment">//null</span></span><br><span class="line"><span class="type">String</span> <span class="variable">put2</span> <span class="operator">=</span> stringStringMap.put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;103&quot;</span>);</span><br><span class="line">System.out.println(put2);<span class="comment">//返回102</span></span><br></pre></td></tr></table></figure><p><strong>Map遍历键找值</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取所有的键  获取键集</span></span><br><span class="line">Set&lt;String&gt; keys = map.keySet();</span><br><span class="line"><span class="comment">// 遍历键集 得到 每一个键</span></span><br><span class="line"><span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">  <span class="comment">//key就是键</span></span><br><span class="line">    <span class="comment">//获取对应值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">    System.out.println(key+<span class="string">&quot;的CP是：&quot;</span>+value);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>Entry键值对对象</strong></p><p><code>Map</code>中存放的是两种对象，一种称为<strong>key</strong>(键)，一种称为<strong>value</strong>(值)，它们在在<code>Map</code>中是一一对应关系，这一对对象又称做<code>Map</code>中的一个<code>Entry(项)</code>。<code>Entry</code>将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历<code>Map</code>集合时，就可以从每一个键值对（<code>Entry</code>）对象中获取对应的键与对应的值。</p><p>方法</p><ul><li><code>public K getKey()</code>：获取Entry对象中的键。</li><li><code>public V getValue()</code>：获取Entry对象中的值。</li></ul><p>Map集合获取Entry对象</p><ul><li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li></ul><p><strong>Map遍历键值对找值</strong></p><ol><li> 获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:<code>entrySet()</code>。</li><li> 遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</li><li> 通过键值对(Entry)对象，获取Entry对象中的键与值。  方法提示:<code>getkey() getValue()</code>     </li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = stringStringMap.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : entries) &#123;</span><br><span class="line">    System.out.println(entry.getKey()+<span class="string">&quot;:&quot;</span>+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p> <strong>HashMap存储自定义类型键值</strong></p><p>自定义类中重写hashCode()和equals()方法 确保元素不重复 确保Key值唯一</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1,创建Hashmap集合对象。</span><br><span class="line">Map&lt;Student,String&gt;map = new HashMap&lt;Student,String&gt;();</span><br></pre></td></tr></table></figure><ul><li>当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。</li><li>如果要保证map中存放的key和取出的顺序一致，可以使用<code>java.util.LinkedHashMap</code>集合来存放</li></ul><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>HashMap保证成对元素唯一，并且查询速度很快，可是成对元素存放进去是没有顺序的，那么我们要保证有序，还要保证查询速度快,我们使用LinkedHashMap&lt;key,value&gt;</p><p>在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedHashMap&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String, String&gt;();</span><br></pre></td></tr></table></figure><h3 id="集合工厂"><a href="#集合工厂" class="headerlink" title="集合工厂"></a>集合工厂</h3><p><strong>JDK9</strong>添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可以更方便地创建集合的不可变实例。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integers = List.of(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Set&lt;String&gt; strings = Set.of(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>);</span><br><span class="line">Map.of(<span class="number">1</span>,<span class="string">&quot;张三&quot;</span>,<span class="number">2</span>,<span class="string">&quot;李四&quot;</span>,<span class="number">3</span>,<span class="string">&quot;王五&quot;</span>); </span><br></pre></td></tr></table></figure><blockquote><p>tips:</p><p>1:of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如    HashSet，ArrayList等</p><p>2:返回的集合是不可变的；</p></blockquote><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><strong>异常</strong> ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</p><p>在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。</p><blockquote><p>异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.</p></blockquote><p>异常根类:</p><p><code>java.lang.Throwable</code></p><p>子类：</p><p><code>java.lang.Error</code></p><p><code>java.lang.Exception</code></p><p>平常所说的异常指<code>java.lang.Exception</code></p><p><strong>Throwable中的常用方法：</strong></p><ul><li><p><code>public void printStackTrace()</code>:打印异常的详细信息。</p><p><em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p></li><li><p><code>public String getMessage()</code>:获取发生异常的原因。</p><p><em>提示给用户的时候,就提示错误原因。</em></p></li><li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p></li></ul><p><strong>异常(Exception)的分类</strong>:</p><ul><li><strong>编译时期异常</strong>:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)</li><li><strong>运行时期异常</strong>:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)</li></ul><p><strong>异常的处理</strong></p><p>try、catch、finally、throw、throws</p><p><strong>throw</strong></p><p>throw<strong>用在方法内</strong>，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断索引是否越界</span></span><br><span class="line"><span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。</span></span><br><span class="line"><span class="comment">    这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(<span class="string">&quot;哥们，角标越界了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：产生了问题，就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。</p><p>那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。</p></blockquote><p><strong>throws</strong></p><p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。</p><p>关键字<strong>throws</strong>运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).</p><p><strong>声明异常格式：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123;   &#125;</span><br></pre></td></tr></table></figure><p><strong>捕获异常</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">     编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  e)&#123;</span><br><span class="line">     处理异常的代码</span><br><span class="line">     <span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>finally 代码块</strong></p><p><strong>finally</strong>：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p><strong>异常类如何定义:</strong></p><ol><li>自定义一个编译期异常: 自定义类 并继承于<code>java.lang.Exception</code>。</li><li>自定义一个运行时期的异常类:自定义类 并继承于<code>java.lang.RuntimeException</code></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 业务逻辑异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegisterException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空参构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RegisterException</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 表示异常提示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RegisterException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p><strong>并发与并行</strong></p><ul><li><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。</li><li><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。</li></ul><p><strong>线程与进程</strong></p><ul><li><p><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p></li><li><p><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 </p></li></ul><p><strong>线程调度:</strong></p><ul><li><p>分时调度</p><p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p></li><li><p>抢占式调度</p><p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p></li></ul><p><strong>线程类</strong></p><p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p><ol><li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li><li>创建Thread子类的实例，即创建了线程对象</li><li>调用线程对象的start()方法来启动该线程</li></ol><p><strong>自定义线程类:继承Thread类</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">//定义指定线程名称的构造方法</span><br><span class="line">public MyThread(String name) &#123;</span><br><span class="line">//调用父类的String参数的构造方法，指定线程的名称</span><br><span class="line">super(name);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 重写run方法，完成该线程执行的逻辑</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">System.out.println(getName()+&quot;：正在执行！&quot;+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用线程</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">NewThread</span>(<span class="string">&quot;线程1&quot;</span>).run();</span><br></pre></td></tr></table></figure><p>多线程执行时，在栈内存中，<strong>其实每一个执行线程都有一片自己所属的栈内存空间</strong>。进行方法的压栈和弹栈。</p><p><strong>构造函数</strong></p><ul><li>public Thread() :分配一个新的线程对象。</li><li>public Thread(String name) :分配一个指定名字的新的线程对象。</li><li>public Thread(Runnable target) :分配一个带有指定目标新的线程对象。</li><li>public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字</li></ul><p><strong>常用方法</strong></p><ul><li>public String getName() :获取当前线程名称。</li><li>public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。</li><li>public void run() :此线程要执行的任务在此处定义代码。</li><li>public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</li><li>public static Thread currentThread() :返回对当前正在执行的线程对象的引用。</li></ul><p><strong>自定义线程:实现Runnable</strong></p><p>步骤如下：</p><ol><li><p>定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</p></li><li><p>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正<br>的线程对象。</p></li><li><p>调用线程对象的start()方法来启动线程。<br>代码如下：</p></li></ol>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span>    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;        </span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);         </span><br><span class="line">    &#125;        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  使用</p>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyRunnable</span> <span class="variable">myrunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(myrunnable, <span class="string">&quot;线程名&quot;</span>).start();</span><br></pre></td></tr></table></figure><p><strong>Thread 和Runnable的区别</strong></p><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。<br><strong>总结：</strong><br>实现Runnable接口比继承Thread类所具有的优势：</p><ol><li><p>适合多个相同的程序代码的线程去共享同一个资源。</p></li><li><p>可以避免java中的单继承的局限性。</p></li><li><p>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</p></li><li><p>线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。</p></li></ol><blockquote><p>扩充：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。</p></blockquote><p><strong>使用匿名内部类实现线程创建</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(System.currentTimeMillis());</span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(runnable).start();</span><br></pre></td></tr></table></figure><p><strong>线程安全</strong></p><blockquote><p>线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p></blockquote><p><strong>线程同步</strong></p><p><code>synchronized</code></p><p>  1 . 同步代码块:关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">synchronized(同步锁)&#123;</span><br><span class="line">     需要同步操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>同步锁</strong>:对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁.</p><ul><li>锁对象 可以是任意类型。</li><li>多个线程对象 要使用同一把锁。<br>注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着<br>(BLOCKED)。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line"><span class="comment">//代码块</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>同步方法::使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public synchronized void methodDemo()&#123;</span><br><span class="line">   可能会产生线程安全问题的代码 </span><br><span class="line">&#125;</span><br><span class="line">//run方法调用锁住的方法</span><br><span class="line">@override</span><br><span class="line">public void run()&#123;</span><br><span class="line">while(true)&#123;</span><br><span class="line">methodDemo();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同步锁是谁?<br>对于非static方法,同步锁就是this。<br>对于static方法,我们使用当前方法所在类的字节码对象(类名.class)</p></blockquote></li><li><p>锁机制:<code>java.util.concurrent.locks.Lock </code></p></li></ol><p>​    Lock锁也称同步锁，加锁与释放锁方法化了</p><ul><li>public void lock() :加同步锁。</li><li>public void unlock() :释放同步锁。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@override</span><br><span class="line">public void run()&#123;</span><br><span class="line">while(true)&#123;</span><br><span class="line">Lock.lock();</span><br><span class="line">//中间放存在线程安全的代码</span><br><span class="line">Lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a><strong>线程状态</strong></h3><p><strong>线程状态</strong></p><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，在API中 <code>java.lang.Thread.State </code>这个枚举中给出了六种线程状态：</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309172224406.png" alt="image-20230917222411304"></p><p><strong>Timed Waiting （计时等待）</strong></p><p>调用sleep()方法之后,当前执行的线程进入到睡眠的状态,就是所谓的Timed Waiting （计时等待）状态</p><blockquote><p>tips:</p><ol><li>进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协作关系。</li><li>为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程中会睡眠</li><li>sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态</li><li>sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始立刻执行。</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309172231802.png" alt="image-20230917223102753"></p><p><strong>BLOCKED （锁阻塞）</strong></p><p>Runnable状态进入Blocked状态:</p><p>线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。</p><p>Waiting以及Time Waiting进入到Blocked状态</p><p><strong>Waiting （无限等待）</strong></p><p>一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      lock.wait();<span class="comment">//无限时睡眠 等待唤醒</span></span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">runnable1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">              <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                  lock.notify();<span class="comment">//唤醒当前睡眠锁对象</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure><p>一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的Object.notify()方法 或 Object.notifyAll()方法。</p><p>其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，多个线程会争取锁，同时相互之间又存在协作关系。<br>当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309172244933.png" alt="image-20230917224455853"></p><p><strong>等待唤醒机制</strong></p><ul><li>为什么要处理线程间通信：</li></ul><p>多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。</p><ul><li>如何保证线程间通信有效利用资源：</li></ul><p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— <strong>等待唤醒机制。</strong></p><p><strong>什么是等待唤醒机制</strong></p><p>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的<strong>竞争（race）</strong>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。</p><p>就是在一个线程进行了规定操作后，就进入等待状态（**wait()<strong>）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（</strong>notify()**）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。</p><p>wait/notify 就是线程间的一种协作机制。</p><p><strong>等待唤醒中的方法</strong></p><p>等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：</p><ol><li>wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个<strong>特别的动作</strong>，也即是“<strong>通知（notify）</strong>”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中</li><li>notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。</li><li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li></ol><blockquote><p>注意：</p><p>哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。</p><p>总结如下：</p><ul><li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；</li><li>否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态</li></ul></blockquote><p><strong>调用wait和notify方法需要注意的细节</strong></p><ol><li>wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li><li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li><li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。</li></ol><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><strong>使用线程池</strong></p><p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p><p>在<code>java.util.concurrent.Executors</code>线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。</p><p>Executors类中有个创建线程池的方法如下：</p><ul><li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)</li></ul><p>获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：</p><ul><li><p><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</p><blockquote><p>Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。</p></blockquote></li></ul><p>使用线程池中线程对象的步骤：</p><ol><li>创建线程池对象。</li><li>创建Runnable接口子类对象。(task)</li><li>提交Runnable接口子类对象。(take task)</li><li>关闭线程池(一般不关闭)。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程池对象,包含2个线程对象</span></span><br><span class="line">     <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">     <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">             System.out.println(Thread.currentThread().getName());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="comment">//从线程池中获取线程对象,然后调用runnable中的run()</span></span><br><span class="line">     service.submit(runnable);</span><br><span class="line">     <span class="comment">//多次调用</span></span><br><span class="line">     service.submit(runnable);</span><br><span class="line">     service.submit(runnable);</span><br><span class="line">     <span class="comment">//关闭线程池</span></span><br><span class="line">     service.shutdown();</span><br></pre></td></tr></table></figure><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a><strong>Lambda表达式</strong></h3><p><strong>强调做什么，而不是以什么形式做</strong></p><p>格式:</p><ul><li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li><li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li><li>大括号内的语法与传统方法体要求基本一致。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(参数类型 参数名称) -&gt; &#123; 代码语句 &#125;</span><br></pre></td></tr></table></figure><p><strong>Lambda表达式的使用条件</strong></p><p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p><ol><li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。<br>无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</li><li>使用Lambda必须具有<strong>上下文推断</strong>。<br>也就是<strong>方法的参数或局部变量类型</strong>必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li></ol><blockquote><p>备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p></blockquote><p>匿名内部类-&gt;Lambda表达式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="comment">//Lambda表达式</span></span><br><span class="line">* 前面的一对小括号即`run`方法的参数（无），代表不需要任何条件；</span><br><span class="line">      * 中间的一个箭头代表将前面的参数传递给后面的代码；</span><br><span class="line">      * 后面的输出语句即业务逻辑代码。</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="string">&quot;多线程任务执行！&quot;</span>)).start();</span><br></pre></td></tr></table></figure><p><strong>使用Lambda标准格式（无参无返回）</strong></p><p>定义一个接口,内含唯一一个抽象方法,无参无返回值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cook</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeFood</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个方法,方法使用接口作为形式参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeCook</span><span class="params">(Cook cook)</span> &#123;</span><br><span class="line">        cook.makeFood();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lambda实现:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">invokeCook(() -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;吃饭啦！&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>使用Lambda标准格式（有参有返回）</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Calculator &#123;</span><br><span class="line">    int calc(int a, int b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeCalc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, Calculator calculator)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;结果是：&quot;</span> + calculator.calc(a, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lambda实现:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invokeCalc(1,2,(int a,int b)-&gt;&#123;return a+b&#125;);,</span><br></pre></td></tr></table></figure><p><strong>Lambda省略格式</strong></p><p><strong>可推导即可省略</strong></p><p>Lambda强调的是“做什么”而不是“怎么做”，所以凡是可以根据上下文推导得知的信息，都可以省略。</p><p><strong>省略规则</strong></p><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p><ol><li>小括号内参数的类型可以省略；</li><li>如果小括号内<strong>有且仅有一个参</strong>，则小括号可以省略；</li><li>如果大括号内<strong>有且仅有一个语句</strong>，则无论是否有返回值，都可以省略大括号、return关键字及语句分号 (;)。</li></ol><p><strong>Lambda的延迟执行</strong></p><p>解决资源浪费问题</p><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口在Java中是指：有且仅有一个抽象方法的接口。<br>函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。</p><blockquote><p>备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部类的“语法糖”，但是二者在原理上是不同的。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 interface 接口名称 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名称(可选参数信息);</span><br><span class="line">    <span class="comment">// 其他非抽象方法内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口当中抽象方法的 public abstract 可省略</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyFunctionalInterface</span> &#123;   </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@FunctionalInterface</strong></p><p>与 @Override 注解的作用类似，Java 8中专门为函数式接口引入了一个新的注解： @FunctionalInterface 。该注解可用于一个接口的定义上：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyFunctionalInterface</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>典型使用场景:作为方法的参数</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用自定义的函数式接口作为方法参数    </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(MyFunctionalInterface inter)</span> &#123;    </span><br><span class="line">inter.myMethod(); <span class="comment">// 调用自定义的函数式接口方法        </span></span><br><span class="line">&#125;    </span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    </span><br><span class="line"><span class="comment">// 调用使用函数式接口的方法        </span></span><br><span class="line">doSomething(() ‐&gt; System.out.println(<span class="string">&quot;Lambda执行啦！&quot;</span>));        </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a><strong>Stream流</strong></h3><p>专注于做什么而不是怎么做</p><p>解决集合的现有弊端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = List.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;姜子牙&quot;</span>, <span class="string">&quot;李元芳&quot;</span>, <span class="string">&quot;典韦&quot;</span>);</span><br><span class="line">strings.stream().filter(s-&gt;s.startsWith(<span class="string">&quot;张&quot;</span>));</span><br><span class="line">strings.stream().filter(s-&gt;s.length() == <span class="number">3</span>);</span><br><span class="line">strings.stream().forEach(System.out::println); </span><br><span class="line"></span><br><span class="line"><span class="comment">//流式 语义: 获取流、过滤姓张、过滤长度为3、逐一打印</span></span><br><span class="line">strings.stream().filter(s-&gt;s.startsWith(<span class="string">&quot;张&quot;</span>)).filter(s-&gt;s.length() == <span class="number">3</span>).forEach(System.out::println); </span><br></pre></td></tr></table></figure><p><strong>流式思想</strong></p><p>流式思想类似于工厂车间的“<strong>生产流水线</strong>”。</p><p><code> filter</code> 、 <code>map</code> 、 <code>skip </code>都是在对函数模型进行操作，集合元素并没有真正被处理。只有当终结方法 <code>count</code>执行的时候，整个模型才会按照指定策略执行操作。而这得益于Lambda的延迟执行特性。</p><blockquote><p>“Stream流”其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）。</p></blockquote><p><strong>Stream流</strong></p><ul><li><p>Stream（流）是一个来自数据源的元素队列</p><p>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</p></li><li><p>数据源 流的来源。 可以是集合，数组 等。</p><p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p><ul><li>Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluentstyle）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li><li>内部迭代： 以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式，流可以直接调用遍历方法。</li></ul><p>当使用一个流的时候，通常包括三个基本步骤：获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道。</p></li></ul><p><strong>获取流</strong></p><p><code>java.util.stream.Stream&lt;T&gt;</code> 是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。）<br>获取一个流非常简单，有以下几种常用的方式：<br>所有的 Collection 集合都可以通过 stream 默认方法获取流；<br>Stream 接口的静态方法 of 可以获取数组对应的流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Collection获取流</span></span><br><span class="line">List&lt;String&gt; strings = List.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;姜子牙&quot;</span>, <span class="string">&quot;李元芳&quot;</span>, <span class="string">&quot;典韦&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stream = strings.stream();</span><br><span class="line"><span class="comment">//Map获取流</span></span><br><span class="line">Map&lt;Integer, String&gt; map = Map.of(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">2</span>, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream1 = map.keySet().stream();</span><br><span class="line">Stream&lt;String&gt; stream2 = map.values().stream();</span><br><span class="line">Stream&lt;Map.Entry&lt;Integer, String&gt;&gt; stream3 = map.entrySet().stream();</span><br><span class="line"><span class="comment">//数组获取流  of 方法的参数是一个可变参数，所以支持数组。</span></span><br><span class="line">Integer[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Stream&lt;Integer&gt; stream4 = Stream.of(array);</span><br></pre></td></tr></table></figure><p><strong>方法</strong></p><ul><li><strong>延迟方法：</strong>返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为延迟方法。</li><li><strong>终结方法：</strong>返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调用。终结方法包括 count 和 forEach 方法等。</li></ul><p><strong>foreach:循环</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void forEach(Consumer&lt;? super T&gt; action);</span><br><span class="line">接收一个 Consumer 接口函数，会将每一个流元素交给该函数进行处理。</span><br><span class="line">java.util.function.Consumer&lt;T&gt;接口是一个消费型接口。</span><br><span class="line">Consumer接口中包含抽象方法void accept(T t)，意为消费一个指定泛型的数据。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">练习:</span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);</span><br><span class="line">stream.forEach(name‐&gt; System.out.println(name));</span><br></pre></td></tr></table></figure><p><strong>filter:过滤</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</span><br><span class="line">java.util.stream.Predicate 函数式接口包含抽象方法</span><br><span class="line">boolean test(T t);</span><br><span class="line">该方法将会产生一个boolean值结果，代表指定的条件是否满足。如果结果为true，那么Stream流的 filter 方法将会留用元素；如果结果为false，那么 filter 方法将会舍弃元素。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">练习:</span><br><span class="line"> Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);</span><br><span class="line"> Stream&lt;String&gt; result = original.filter(s ‐&gt; s.startsWith(&quot;张&quot;));</span><br></pre></td></tr></table></figure><p><strong>map:映射</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</span><br><span class="line">java.util.stream.Function 函数式接口的抽象方法</span><br><span class="line">R apply(T t);可以将当前流中的T类型数据转换为另一种R类型的流。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用:</span><br><span class="line">Stream&lt;String&gt; original = Stream.of(&quot;10&quot;, &quot;12&quot;, &quot;18&quot;);</span><br><span class="line">Stream&lt;Integer&gt; result = original.map(str‐&gt;Integer.parseInt(str));</span><br></pre></td></tr></table></figure><p><strong>count:计数</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; s = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);</span><br><span class="line">s.count();</span><br></pre></td></tr></table></figure><p><strong>limit:截取前几个</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;张三丰&quot;</span>, <span class="string">&quot;周芷若&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; result = original.limit(<span class="number">2</span>);<span class="comment">//取前两个</span></span><br></pre></td></tr></table></figure><p><strong>skip:跳过前几个</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; original = Stream.of(&quot;张无忌&quot;, &quot;张三丰&quot;, &quot;周芷若&quot;);</span><br><span class="line">Stream&lt;String&gt; result = original.skip(2);</span><br></pre></td></tr></table></figure><p><strong>concat:组合</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//静态方法</span><br><span class="line">Stream&lt;String&gt; streamA = Stream.of(&quot;张无忌&quot;);</span><br><span class="line">Stream&lt;String&gt; streamB = Stream.of(&quot;张翠山&quot;);</span><br><span class="line">Stream&lt;String&gt; result = Stream.concat(streamA, streamB);</span><br></pre></td></tr></table></figure><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码</span><br><span class="line">* 反射：将类的各个组成部分封装为其他对象，这就是反射机制</span><br><span class="line">* 好处：</span><br><span class="line">1. 可以在程序运行过程中，操作这些对象。</span><br><span class="line">2. 可以解耦，提高程序的可扩展性。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 获取Class对象的方式：</span><br><span class="line">1. Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象</span><br><span class="line">* 多用于配置文件，将类名定义在配置文件中。读取文件，加载类</span><br><span class="line">2. 类名.class：通过类名的属性class获取</span><br><span class="line">* 多用于参数的传递</span><br><span class="line">3. 对象.getClass()：getClass()方法在Object类中定义着。</span><br><span class="line">* 多用于对象的获取字节码的方式</span><br><span class="line"></span><br><span class="line">* 结论：</span><br><span class="line">同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* Class对象功能：</span><br><span class="line">* 获取功能：</span><br><span class="line">1. 获取成员变量们</span><br><span class="line">* Field[] getFields() ：获取所有public修饰的成员变量</span><br><span class="line">* Field getField(String name)   获取指定名称的 public修饰的成员变量</span><br><span class="line"></span><br><span class="line">* Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符</span><br><span class="line">* Field getDeclaredField(String name)  </span><br><span class="line">2. 获取构造方法们</span><br><span class="line">* Constructor&lt;?&gt;[] getConstructors()  </span><br><span class="line">* Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)  </span><br><span class="line"></span><br><span class="line">* Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)  </span><br><span class="line">* Constructor&lt;?&gt;[] getDeclaredConstructors()  </span><br><span class="line">3. 获取成员方法们：</span><br><span class="line">* Method[] getMethods()  </span><br><span class="line">* Method getMethod(String name, 类&lt;?&gt;... parameterTypes)  </span><br><span class="line"></span><br><span class="line">* Method[] getDeclaredMethods()  </span><br><span class="line">* Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)  </span><br><span class="line"></span><br><span class="line">4. 获取全类名</span><br><span class="line">* String getName()  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* Field：成员变量</span><br><span class="line">* 操作：</span><br><span class="line">1. 设置值</span><br><span class="line">* void set(Object obj, Object value)  </span><br><span class="line">2. 获取值</span><br><span class="line">* get(Object obj) </span><br><span class="line"></span><br><span class="line">3. 忽略访问权限修饰符的安全检查</span><br><span class="line">* setAccessible(true):暴力反射</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* Constructor:构造方法</span><br><span class="line">* 创建对象：</span><br><span class="line">* T newInstance(Object... initargs)  </span><br><span class="line"></span><br><span class="line">* 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* Method：方法对象</span><br><span class="line">* 执行方法：</span><br><span class="line">* Object invoke(Object obj, Object... args)  </span><br><span class="line"></span><br><span class="line">* 获取方法名称：</span><br><span class="line">* String getName:获取方法名</span><br></pre></td></tr></table></figure><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p>Java中的File类可以用于描述和操作文件或目录。File类提供了一些方法来创建、删除、重命名、判断文件是否存在等操作。在处理文件流时，可以使用FileInputStream和FileOutputStream来读写文件。</p><p>创建File对象： 可以使用File类的构造函数来创建File对象，可以传入文件路径或目录路径作为参数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;path/to/file.txt&quot;</span>);</span><br></pre></td></tr></table></figure><p>判断文件是否存在： 可以使用File对象的exists()方法来判断文件是否存在。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> file.exists();</span><br></pre></td></tr></table></figure><p>创建文件或目录： 可以使用File对象的createNewFile()方法创建新的文件，使用mkdir()方法创建新的目录。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> file.createNewFile();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> file.mkdir();</span><br></pre></td></tr></table></figure><p>删除文件或目录： 可以使用File对象的delete()方法来删除文件或目录。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> file.delete();</span><br></pre></td></tr></table></figure><p>重命名文件或目录： 可以使用File对象的renameTo()方法来重命名文件或目录。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">newFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;path/to/newname.txt&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> file.renameTo(newFile);</span><br></pre></td></tr></table></figure><p>读取文件： 可以使用FileInputStream类来读取文件的内容。首先创建FileInputStream对象，然后使用其read()方法读取文件中的数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="keyword">while</span> ((data = fis.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理读取到的数据</span></span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure><p>写入文件： 可以使用FileOutputStream类来写入数据到文件中。首先创建FileOutputStream对象，然后使用其write()方法将数据写入文件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line"><span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">fos.write(data.getBytes());</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li><p><strong>递归</strong>：指在当前方法内调用自己的这种现象。</p></li><li><p><strong>递归的分类:</strong></p><ul><li>递归分为两种，直接递归和间接递归。</li><li>直接递归称为方法自身调用自己。</li><li>间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。</li></ul></li><li><p><strong>注意事项</strong>：</p><ul><li>递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。</li><li>在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。</li><li>构造方法,禁止递归</li></ul></li></ul><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><p><strong>分类</strong></p><ul><li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 </li><li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。</li></ul><p><strong>类型</strong></p><p>Java中提供了两种不同类型的流用于处理输入和输出：字节流和字符流。字节流主要用于读写二进制数据，而字符流主要用于读写文本文件。</p><p><strong>字节流：</strong></p><ol><li>字节输入流-InputStream：<ul><li>InputStream是所有字节输入流的基类，可以使用它来从源读取字节数据。常用的子类有FileInputStream、ByteArrayInputStream等。</li><li>使用字节输入流读取数据可以通过read()、read(byte[] buffer)等方法，读取单个字节或者一次读取多个字节。可以使用循环结构一次读取多个字节，并处理读取到的字节数据。</li></ul></li><li>字节输出流-OutputStream：<ul><li>OutputStream是所有字节输出流的基类，可以使用它来向目标写入字节数据。常用的子类有FileOutputStream、ByteArrayOutputStream等。</li><li>使用字节输出流写入数据可以通过write(int b)、write(byte[] buffer)等方法，写入单个字节或者一次写入多个字节。可以使用循环结构一次写入多个字节。</li></ul></li></ol><p><strong>字符流：</strong></p><ol><li>字符输入流-Reader：<ul><li>Reader是所有字符输入流的基类，可以使用它来从源读取字符数据。常用的子类有FileReader、CharArrayReader等。</li><li>使用字符输入流读取数据可以通过read()、read(char[] buffer)等方法，读取单个字符或者一次读取多个字符。可以使用循环结构一次读取多个字符，并处理读取到的字符数据。</li></ul></li><li>字符输出流-Writer：<ul><li>Writer是所有字符输出流的基类，可以使用它来向目标写入字符数据。常用的子类有FileWriter、CharArrayWriter等。</li><li>使用字符输出流写入数据可以通过write(int c)、write(String str)等方法，写入单个字符或者一次写入多个字符。可以使用循环结构一次写入多个字符。</li></ul></li></ol><p>注意事项：</p><ul><li>字节流适用于处理二进制文件和任意文件的输入输出。</li><li>字符流适用于处理文本文件和文本数据的输入输出。</li><li>在处理文本文件时，使用字符流更为方便，可直接按行读取和写入文本数据。</li></ul><p><strong>父类</strong></p><table><thead><tr><th align="center"></th><th align="center"><strong>输入流</strong></th><th align="center">输出流</th></tr></thead><tbody><tr><td align="center"><strong>字节流</strong></td><td align="center">字节输入流 <strong>InputStream</strong></td><td align="center">字节输出流 <strong>OutputStream</strong></td></tr><tr><td align="center"><strong>字符流</strong></td><td align="center">字符输入流 <strong>Reader</strong></td><td align="center">字符输出流 <strong>Writer</strong></td></tr></tbody></table><p><strong>字节流</strong></p><p><strong>字节输出流:OutputStream</strong></p><p>共性方法:</p><ul><li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。  </li><li><code>public void flush() </code> ：刷新此输出流并强制任何缓冲的输出字节被写出。  </li><li><code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。  </li><li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  </li><li><code>public abstract void write(int b)</code> ：将指定的字节输出流。</li></ul><p><strong>FileOutputStream</strong></p><p><code>java.io.FileOutputStream</code></p><p>构造方法</p><ul><li><code>public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的 File对象表示的文件。 </li><li><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称写入文件。 </li></ul><p><strong>字节输入流:InputStream</strong></p><p><code>java.io.InputStream </code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。    </li><li><code>public abstract int read()</code>： 从输入流读取数据的下一个字节。 </li><li><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中</li></ul><p><strong>FileInputStream</strong></p><p>构造方法</p><ul><li><code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 </li><li><code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。  </li></ul><p><strong>字符流</strong></p><p> <strong>字符输入流:Reader</strong></p><p><code>java.io.Reader</code>抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。    </li><li><code>public int read()</code>： 从输入流读取一个字符。 </li><li><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。</li></ul><p><strong>FileReader</strong></p><p>构造方法</p><ul><li><code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的File对象。   </li><li><code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的名称。 </li></ul><p><strong>字符输出流:Writer</strong></p><p><code>java.io.Writer </code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p><ul><li><code>void write(int c)</code> 写入单个字符。</li><li><code>void write(char[] cbuf) </code>写入字符数组。 </li><li><code>abstract  void write(char[] cbuf, int off, int len) </code>写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 </li><li><code>void write(String str) </code>写入字符串。 </li><li><code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</li><li><code>void flush() </code>刷新该流的缓冲。  </li><li><code>void close()</code> 关闭此流，但要先刷新它。 </li></ul><p><strong>FileWriter</strong></p><p>构造方法</p><ul><li><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。   </li><li><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。  </li></ul><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p><code>java.util.Properties </code> 继承于<code> Hashtable</code> ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，<code>System.getProperties</code> 方法就是返回一个<code>Properties</code>对象。</p><p>构造方法</p><p><code>public Properties()</code> :创建一个空的属性列表。</p><p>存储方法</p><ul><li><code>public Object setProperty(String key, String value)</code> ： 保存一对属性。  </li><li><code>public String getProperty(String key) </code> ：使用此属性列表中指定的键搜索属性值。</li><li><code>public Set&lt;String&gt; stringPropertyNames() </code> ：所有键的名称的集合。</li></ul><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p>缓冲流,也叫高效流，是对4个基本的<code>FileXxx</code> 流的增强，所以也是4个流，按照数据类型分类：</p><ul><li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li><li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code></li></ul><p>缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</p><p><strong>字节缓冲流</strong></p><p>构造方法</p><ul><li><code>public BufferedInputStream(InputStream in)</code> ：创建一个 新的缓冲输入流。 </li><li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的缓冲输出流。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字节缓冲输入流</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;bis.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 创建字节缓冲输出流</span></span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;bos.txt&quot;</span>));</span><br></pre></td></tr></table></figure><p><strong>字符缓冲流</strong></p><p>构造方法</p><ul><li><code>public BufferedReader(Reader in)</code> ：创建一个 新的缓冲输入流。 </li><li><code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字符缓冲输入流</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;br.txt&quot;</span>));</span><br><span class="line"><span class="comment">// 创建字符缓冲输出流</span></span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;bw.txt&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a><strong>转换流</strong></h3><p><strong>InputStreamReader</strong></p><p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p><p><strong>构造方法</strong></p><ul><li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 </li><li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;in.txt&quot;</span>));</span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;in.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>OutputStreamWriter</strong></p><p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p><p><strong>构造方法</strong></p><ul><li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 </li><li><code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>));</span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">isr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>) , <span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="序列流"><a href="#序列流" class="headerlink" title="序列流"></a>序列流</h3><p>Java 提供了一种对象<strong>序列化</strong>的机制。用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<strong>持久保存</strong>了一个对象的信息。 </p><p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行<strong>反序列化</strong>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。看图理解序列化： </p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309181509834.png" alt="image-20230918150948635"></p><p><code>java.io.ObjectOutputStream </code> 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</p><p><strong>构造方法</strong></p><ul><li><code>public ObjectOutputStream(OutputStream out) </code>： 创建一个指定OutputStream的ObjectOutputStream。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;employee.txt&quot;</span>);</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOut);</span><br></pre></td></tr></table></figure><p><strong>序列化满足条件</strong></p><ul><li>该类必须实现<code>java.io.Serializable </code> 接口，<code>Serializable</code> 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出<code>NotSerializableException</code> 。</li><li>该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Employee implements java.io.Serializable &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public String address;</span><br><span class="line">    public transient int age; // transient瞬态修饰成员,不会被序列化</span><br><span class="line">    public void addressCheck() &#123;</span><br><span class="line">      System.out.println(&quot;Address  check : &quot; + name + &quot; - &quot; + address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法</strong></p><p><code>public final void writeObject (Object obj)</code> : 将指定的对象写出</p><p><strong>反序列化</strong></p><p><code>ObjectInputStream</code></p><p>ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 </p><p>构造方法</p><p><code>public ObjectInputStream(InputStream in) </code>： 创建一个指定InputStream的ObjectInputStream。</p><p>方法</p><p><strong>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</strong>  </p><p><strong>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个<code>InvalidClassException</code>异常。</strong></p><p><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号。<code>serialVersionUID</code> 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Employee implements java.io.Serializable &#123;</span><br><span class="line">     // 加入序列版本号</span><br><span class="line">     private static final long serialVersionUID = 1L;</span><br><span class="line">     public String name;</span><br><span class="line">     </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p><code>print</code>方法和<code>println</code>这两个方法都来自于<code>java.io.PrintStream</code>类</p><p><strong>PrintStream</strong></p><p>构造方法</p><p><code>public PrintStream(String fileName)  </code>： 使用指定的文件名创建一个新的打印流。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PrintStream ps = new PrintStream(&quot;ps.txt&quot;)；</span><br></pre></td></tr></table></figure><h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><p><strong>软件结构</strong></p><p><strong>C/S结构</strong> ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件</p><p><strong>B/S结构</strong> ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。</p><p><strong>协议</strong></p><ul><li><strong>TCP/IP协议：</strong> 传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309181857749.png" alt="image-20230918185708648"></p><p><strong>协议分类</strong></p><ul><li><p>UDP</p><p>UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。</p><p>使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输</p></li><li><p>TCP/IP</p><p>传输控制协议 (Transmission Control Protocol)。TCP协议是<strong>面向连接</strong>的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</p><p>在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”。</p><ul><li>三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。<ul><li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认。</li><li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求。</li><li>第三次握手，客户端再次向服务器端发送确认信息，确认连接。整个交互过程如下图所示。</li></ul></li></ul></li></ul><p>网络编程三要素:协议,IP地址,端口号</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a><strong>TCP</strong></h3><p><strong>在Java中，提供了两个类用于实现TCP通信程序：</strong></p><ol><li>客户端：<code>java.net.Socket</code> 类表示。创建<code>Socket</code>对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li><li>服务端：<code>java.net.ServerSocket</code> 类表示。创建<code>ServerSocket</code>对象，相当于开启一个服务，并等待客户端的连接。</li></ol><p><strong>Socket类</strong>  </p><p><code>Socket</code> 类：该类实现客户端套接字，套接字指的是两台设备之间通讯的端点。</p><p><strong>构造方法</strong></p><ul><li><p><code>public Socket(String host, int port)</code> :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null ，则相当于指定地址为回送地址。  </p><blockquote><p>小贴士：回送地址(127.x.x.x) 是本机回送地址（Loopback Address），主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，立即返回，不进行任何网络传输。</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br></pre></td></tr></table></figure><p><strong>成员方法</strong></p><ul><li><code>public InputStream getInputStream()</code> ： 返回此套接字的输入流。<ul><li>如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。</li><li>关闭生成的InputStream也将关闭相关的Socket。</li></ul></li><li><code>public OutputStream getOutputStream()</code> ： 返回此套接字的输出流。<ul><li>如果此Scoket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。</li><li>关闭生成的OutputStream也将关闭相关的Socket。</li></ul></li><li><code>public void close()</code> ：关闭此套接字。<ul><li>一旦一个socket被关闭，它不可再使用。</li><li>关闭此socket也将关闭相关的InputStream和OutputStream 。 </li></ul></li><li><code>public void shutdownOutput()</code> ： 禁用此套接字的输出流。   <ul><li>任何先前写出的数据将被发送，随后终止输出流。 </li></ul></li></ul><p><strong>ServerSocket类</strong></p><p><code>ServerSocket</code>类：这个类实现了服务器套接字，该对象等待通过网络的请求。</p><p><strong>构造方法</strong></p><ul><li><code>public ServerSocket(int port)</code> ：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure><p><strong>成员方法</strong></p><ul><li><code>public Socket accept()</code> ：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直阻塞直到建立连接。 </li></ul><p><strong>TCP通信分析图解</strong></p><ol><li>【服务端】启动,创建ServerSocket对象，等待连接。</li><li>【客户端】启动,创建Socket对象，请求连接。</li><li>【服务端】接收连接,调用accept方法，并返回一个Socket对象。</li><li>【客户端】Socket对象，获取OutputStream，向服务端写出数据。</li><li>【服务端】Scoket对象，获取InputStream，读取客户端发送的数据。</li></ol><blockquote><p>到此，客户端向服务端发送数据成功。</p></blockquote><p><img src="https://gitee.com/dengxing1277/blogimage/raw/master/imgs/202309211115393.jpeg"></p><blockquote><p>自此，服务端向客户端回写数据。</p></blockquote><ol start="6"><li>【服务端】Socket对象，获取OutputStream，向客户端回写数据。</li><li>【客户端】Scoket对象，获取InputStream，解析回写数据。</li><li>【客户端】释放资源，断开连接。</li></ol><p><strong>客户端向服务器发送数据</strong></p><p><strong>服务端实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerTCP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端启动 , 等待连接 .... &quot;</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">server</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">      <span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      <span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        <span class="comment">//5.关闭资源.</span></span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTCP</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;客户端 发送数据&quot;</span>);</span><br><span class="line"><span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line"><span class="comment">// 2.获取流对象 . 输出流</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line"><span class="comment">// 3.写出数据.</span></span><br><span class="line">os.write(<span class="string">&quot;你好么? tcp ,我来了&quot;</span>.getBytes());</span><br><span class="line"><span class="comment">// 4. 关闭资源 .</span></span><br><span class="line">os.close();</span><br><span class="line">client.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>服务器向客户端回写数据</strong></p><p><strong>服务端实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerTCP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端启动 , 等待连接 .... &quot;</span>);</span><br><span class="line">        <span class="comment">// 1.创建 ServerSocket对象，绑定端口，开始等待连接</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br><span class="line">        <span class="comment">// 2.接收连接 accept 方法, 返回 socket 对象.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">server</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">// 3.通过socket 获取输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> server.getInputStream();</span><br><span class="line">        <span class="comment">// 4.一次性读取数据</span></span><br><span class="line">      <span class="comment">// 4.1 创建字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      <span class="comment">// 4.2 据读取到字节数组中.</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> is.read(b)；</span><br><span class="line">        <span class="comment">// 4.3 解析数组,打印字符串信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">      <span class="comment">// =================回写数据=======================</span></span><br><span class="line">      <span class="comment">// 5. 通过 socket 获取输出流</span></span><br><span class="line">       <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> server.getOutputStream();</span><br><span class="line">      <span class="comment">// 6. 回写数据</span></span><br><span class="line">       out.write(<span class="string">&quot;我很好,谢谢你&quot;</span>.getBytes());</span><br><span class="line">      <span class="comment">// 7.关闭资源.</span></span><br><span class="line">      out.close();</span><br><span class="line">        is.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端实现：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientTCP</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;客户端 发送数据&quot;</span>);</span><br><span class="line"><span class="comment">// 1.创建 Socket ( ip , port ) , 确定连接到哪里.</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6666</span>);</span><br><span class="line"><span class="comment">// 2.通过Scoket,获取输出流对象 </span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> client.getOutputStream();</span><br><span class="line"><span class="comment">// 3.写出数据.</span></span><br><span class="line">os.write(<span class="string">&quot;你好么? tcp ,我来了&quot;</span>.getBytes());</span><br><span class="line">      <span class="comment">// ==============解析回写=========================</span></span><br><span class="line">      <span class="comment">// 4. 通过Scoket,获取 输入流对象</span></span><br><span class="line">      <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> client.getInputStream();</span><br><span class="line">      <span class="comment">// 5. 读取数据数据</span></span><br><span class="line">      <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span>];</span><br><span class="line">      <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> in.read(b);</span><br><span class="line">      System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len));</span><br><span class="line"><span class="comment">// 6. 关闭资源 .</span></span><br><span class="line">      in.close();</span><br><span class="line">os.close();</span><br><span class="line">client.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SSM框架</title>
      <link href="/2023/09/19/SSM%E6%A1%86%E6%9E%B6/"/>
      <url>/2023/09/19/SSM%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="SSM框架"><a href="#SSM框架" class="headerlink" title="SSM框架"></a>SSM框架</h3><p>SSM框架是指Spring+SpringMVC+MyBatis的组合，它是Java Web开发中常用的一套开发框架。</p><ul><li>Spring是一个应用开发框架，它提供了一系列的模块和类库，用于简化Java应用的开发。它提供了控制反转（IoC）和面向切面编程（AOP）等功能。</li></ul><ul><li>SpringMVC是基于Spring框架的一个MVC（Model-View-Controller）框架，它通过将请求分发给对应的控制器，然后生成相应的视图来实现Web应用的开发。</li></ul><ul><li>MyBatis是一个持久层框架，它提供了数据库操作的SQL映射关系管理，并且能够将结果映射为Java对象。</li></ul><p>SSM框架的优点在于：</p><ol><li>简化开发：使用SSM框架可以减少很多传统Java Web开发中的繁琐工作，提高开发效率。</li><li>轻量级：SSM框架相较于其他框架来说，比较精简，占用资源较少。</li><li>统一标准：SSM框架提供了一套统一的开发标准，能够帮助开发团队协作开发。</li><li>易于扩展：SSM框架的各个组件都可以自由扩展，方便根据实际需求进行定制开发。</li></ol><p>总结来说，SSM框架结合了Spring的依赖注入、控制反转等优点，SpringMVC的Web开发模式以及MyBatis的持久化操作，使得Java Web开发更加简便、高效。</p><ul><li><p>Spring框架</p><p>指 <code>Spring Framework</code>，是整个Spring生态的核心，提供了一个IoC容器，用于管理对象的生命周期和依赖关系。</p></li><li><p>Spring MVC框架</p><p>SpringMVC是基于Spring框架的MVC（Model-View-Controller，模型-视图-控制器）架构的Web框架，用于快速开发Web应用程序。</p></li><li><p>MyBatis框架</p><p>MyBatis是一个开源的持久层框架，它提供了一种将Java对象与关系型数据库之间进行映射的方式，MyBatis通过配置文件或注解来定义SQL映射。    </p></li></ul><p>仓库地址:<a href="https://gitee.com/teduwang/jsd2306-ssm-teacher.git">https://gitee.com/teduwang/jsd2306-ssm-teacher.git</a></p><p><strong>SSM框架注解</strong></p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309191556549.png" alt="SSM"></p><ul><li><p>三大框架注解</p><p>Spring + Spring MVC + MyBatis</p></li><li><p>其他框架注解</p><ul><li>Spring Boot</li><li>Lombok</li><li>Knife4j</li><li>Spring Validation</li></ul></li></ul><table><thead><tr><th></th><th>注解</th><th>所属框架</th><th>作用</th></tr></thead><tbody><tr><td><strong>1</strong></td><td><code>@Component</code></td><td>Spring</td><td>添加在类上，标记当前类是组件类，可以通过参数配置Spring Bean名称</td></tr><tr><td><strong>2</strong></td><td><code>@Controller</code></td><td>Spring</td><td>添加在类上，标记当前类是控制器组件类，用法同<code>@Component</code></td></tr><tr><td><strong>3</strong></td><td><code>@Service</code></td><td>Spring</td><td>添加在类上，标记当前类是业务逻辑组件类，用法同<code>@Component</code></td></tr><tr><td><strong>4</strong></td><td><code>@Repository</code></td><td>Spring</td><td>添加在类上，标记当前类是数据访问组件类，用法同<code>@Component</code></td></tr><tr><td><strong>5</strong></td><td><code>@Configuration</code></td><td>Spring</td><td>添加在类上，仅添加此注解的类才被视为配置类，通常不配置注解参数</td></tr><tr><td><strong>6</strong></td><td><code>@ComponentScan</code></td><td>Spring</td><td>添加在配置类上，开启组件扫描。<br />如果没有配置包名，则扫描当前配置类所在的包，<br />如果配置了包名，则扫描所配置的包及其子孙包</td></tr><tr><td><strong>7</strong></td><td><code>@Value</code></td><td>Spring</td><td>添加在属性上，或添加在被Spring调用的方法的参数上，用于读取<code>Environment</code>中的属性值，为对象的属性或方法的参数注入值</td></tr><tr><td><strong>8</strong></td><td><code>@Autowired</code></td><td>Spring</td><td>添加在属性上，使得Spring自动装配此属性的值<br />添加在构造方法上，使得Spring自动调用此构造方法<br />添加在Setter方法上，使得Spring自动调用此方法</td></tr><tr><td><strong>9</strong></td><td><code>@Qualifier</code></td><td>Spring</td><td>添加在属性上，或添加在方法的参数上，<br />配合自动装配机制，用于指定需要装配的Spring Bean的名称</td></tr><tr><td><strong>10</strong></td><td><code>@Resource</code></td><td>Spring</td><td>此注解是<code>javax</code>包中的注解，<br />添加在属性上，使得Spring自动装配此属性的值，<br />通常不推荐使用此注解</td></tr><tr><td><strong>11</strong></td><td><code>@Scope</code></td><td>Spring</td><td>添加在组件类上，或添加在已经添加了<code>@Bean</code>注解的方法上，<br />用于指定作用域，注解参数为<code>singleton</code>（默认）时为“单例”，注解参数为<code>prototype</code>时为“非单例”</td></tr><tr><td><strong>12</strong></td><td><code>@Mapper</code></td><td>Mybatis</td><td>添加在Mapper接口上，用于标记此接口是Mybatis的Mapper接口</td></tr><tr><td><strong>13</strong></td><td><code>@MapperScan</code></td><td>Mybatis</td><td>添加在配置类上，用于指定Mapper接口的根包，Mybatis将根据此根包执行扫描，以找到各Mapper接口</td></tr><tr><td><strong>14</strong></td><td><code>@Select</code></td><td>Mybatis</td><td>添加在Mapper接口的抽象方法上，可以通过此注解直接配置此抽象方法对应的SQL语句（不必将SQL语句配置在XML文件中），用于配置<code>SELECT</code>类的SQL语句，但是，非常不推荐这种做法</td></tr><tr><td><strong>15</strong></td><td><code>@Insert</code></td><td>Mybatis</td><td>同上，用于配置<code>INSERT</code>类的SQL语句</td></tr><tr><td><strong>16</strong></td><td><code>@Update</code></td><td>Mybatis</td><td>同上，用于配置<code>UPDATE</code>类的SQL语句</td></tr><tr><td><strong>17</strong></td><td><code>@Delete</code></td><td>Mybatis</td><td>同上，用于配置<code>DELETE</code>类的SQL语句</td></tr><tr><td><strong>18</strong></td><td><code>@SpringBootApplication</code></td><td>Spring Boot</td><td>添加在类上，用于标记此类是Spring Boot的启动类，每个Spring Boot项目应该只有1个类添加了此注解</td></tr><tr><td><strong>19</strong></td><td><code>@SpringBootTest</code></td><td>Spring Boot</td><td>添加在类上，用于标记此类是加载Spring环境的测试类</td></tr><tr><td><strong>20</strong></td><td>@Test</td><td>Spring Boot</td><td>添加在方法上，用于标记此方法是Spring环境的测试方法</td></tr><tr><td><strong>21</strong></td><td><code>@RequestMapping</code></td><td>Spring MVC</td><td>添加在类上，也可以添加在处理请求的方法上，<br />通常用于配置请求路径</td></tr><tr><td><strong>22</strong></td><td><code>@ResponseBody</code></td><td>Spring MVC</td><td>添加在方法上，标记此方法是“响应正文”的，<br />添加在类上，标记此类中所有方法都是“响应正文”的</td></tr><tr><td><strong>23</strong></td><td><code>@RestController</code></td><td>Spring MVC</td><td>添加在类上，标记此类是一个“响应正文”的控制器类</td></tr><tr><td><strong>24</strong></td><td><code>@GetMapping</code></td><td>Spring MVC</td><td>添加在方法上，是将请求方式限制为<code>GET</code>的<code>@RequestMapping</code></td></tr><tr><td><strong>25</strong></td><td><code>@PostMapping</code></td><td>Spring MVC</td><td>添加在方法上，是将请求方式限制为<code>POST</code>的<code>@RequestMapping</code></td></tr><tr><td><strong>26</strong></td><td><code>@DeleteMapping</code></td><td>Spring MVC</td><td>添加在方法上，是将请求方式限制为<code>DELETE</code>的<code>@RequestMapping</code></td></tr><tr><td><strong>27</strong></td><td><code>@PutMapping</code></td><td>Spring MVC</td><td>添加在方法上，是将请求方式限制为<code>PUT</code>的<code>@RequestMapping</code></td></tr><tr><td><strong>28</strong></td><td><code>@PathVariable</code></td><td>Spring MVC</td><td>添加在请求参数上，用于标记此参数的值来自URL中的占位符，如果URL中的占位符名称与方法的参数名称不同，需要配置此注解参数来指定URL中的占位符名称</td></tr><tr><td><strong>29</strong></td><td><code>@RequestBody</code></td><td>Spring MVC</td><td>添加在请求参数上，用于标记此参数必须是对象格式的参数，如果未添加此注解，参数必须是FormData格式的</td></tr><tr><td><strong>30</strong></td><td><code>@ExceptionHandler</code></td><td>Spring MVC</td><td>添加在方法上，标记此方法是处理异常的方法，可以通过配置注解参数来指定需要处理的异常类型，如果没有配置注解参数，所处理的异常类型取决于方法的参数列表中的异常类型</td></tr><tr><td><strong>31</strong></td><td><code>@ControllerAdvice</code></td><td>Spring MVC</td><td>添加在类上，标记此类中特定的方法将作用于每次处理请求的过程中</td></tr><tr><td><strong>32</strong></td><td><code>@RestControllerAdvice</code></td><td>Spring MVC</td><td>添加在类上，是<code>@ControllerAdvice</code>和<code>@ResponseBody</code>的组合注解</td></tr><tr><td><strong>33</strong></td><td><code>@Data</code></td><td>Lombok</td><td>添加在类上，将在编译期生成此类中所有属性的Setter、Getter方法，及<code>hashCode()</code>、<code>equals()</code>、<code>toString()</code>方法</td></tr><tr><td><strong>34</strong></td><td><code>@Setter</code></td><td>Lombok</td><td>添加在类上，将在编译期生成此类中所有属性的Setter方法，也可以添加在类的属性上，将在编译期生成此属性的Setter方法</td></tr><tr><td><strong>35</strong></td><td><code>@Getter</code></td><td>Lombok</td><td>添加在类上，将在编译期生成此类中所有属性的Getter方法，也可以添加在类的属性上，将在编译期生成此属性的Getter方法</td></tr><tr><td><strong>36</strong></td><td><code>@ToString</code></td><td>Lombok</td><td>添加在类上，将在编译期生成基于此类中所有属性的<code>toString()</code>方法</td></tr><tr><td><strong>37</strong></td><td><code>@NoArgConstructor</code></td><td>Lombok</td><td>添加在类上，将在编译期生成此类的无参数构造方法</td></tr><tr><td><strong>38</strong></td><td><code>@AllArgsConstructor</code></td><td>Lombok</td><td>添加在类上，将在编译期生成基于此类中所有属性的全参构造方法</td></tr><tr><td><strong>39</strong></td><td><code>@Api</code></td><td>Knife4j</td><td>添加在控制器类上，通过此注解的<code>tags</code>属性配置API文档中的模块名称</td></tr><tr><td><strong>40</strong></td><td><code>@ApiOperation</code></td><td>Knife4j</td><td>添加在控制器类中处理请求的方法上，用于配置业务名称</td></tr><tr><td><strong>41</strong></td><td><code>@ApiModelProperty</code></td><td>Knife4j</td><td>添加在封装的请求参数类型中的属性上，用于配置请求参数的详细说明，包括：名称、数据类型、是否必须等</td></tr><tr><td><strong>42</strong></td><td><code>@ApiImplicitParam</code></td><td>Knife4j</td><td>添加在控制器类中处理请求的方法上，用于配置请求参数的详细说明，包括：名称、数据类型、是否必须等</td></tr><tr><td><strong>43</strong></td><td><code>@ApiImplicitParams</code></td><td>Knife4j</td><td>添加在控制器类中处理请求的方法上，如果需要通过<code>@ApiImplicitParam</code>注解配置的参数超过1个，则必须将多个<code>@ApiImplicitParam</code>注解作为此注解的参数</td></tr><tr><td><strong>44</strong></td><td><code>@ApiIgnore</code></td><td>Knife4j</td><td>添加在请求参数上，用于标记API文档中将不关心此参数</td></tr><tr><td><strong>45</strong></td><td><code>@Valid</code></td><td>Spring Validation</td><td>添加在方法的参数上，标记此参数需要经过Validation框架的检查</td></tr><tr><td><strong>46</strong></td><td><code>@Validated</code></td><td>Spring Validation</td><td>添加在方法的参数上，标记此参数需要经过Validation框架的检查；添加在类上，并结合方法上的检查注解（例如<code>@NotNull</code>等）实现对未封装的参数的检查</td></tr><tr><td><strong>47</strong></td><td><code>@NotNull</code></td><td>Spring Validation</td><td>添加在需要被检查的参数上，或添加在需要被检查的封装类型的属性上，用于配置“不允许为<code>null</code>”的检查规则</td></tr><tr><td><strong>48</strong></td><td><code>@NotEmpty</code></td><td>Spring Validation</td><td>使用位置同<code>@NotNull</code>，用于配置“不允许为空字符串”的检查规则</td></tr><tr><td><strong>49</strong></td><td><code>@NotBlank</code></td><td>Spring Validation</td><td>使用位置同<code>@NotNull</code>，用于配置“不允许为空白”的检查规则</td></tr><tr><td><strong>50</strong></td><td><code>@Pattern</code></td><td>Spring Validation</td><td>使用位置同<code>@NotNull</code>，用于配置正则表达式的检查规则</td></tr><tr><td><strong>51</strong></td><td><code>@Range</code></td><td>Spring Validation</td><td>使用位置同<code>@NotNull</code>，用于配置“数值必须在某个取值区间”的检查规则</td></tr></tbody></table><p><strong>基于SpringBoot的SSM框架依赖</strong></p><p><strong>勾选依赖项</strong></p><p><strong>1 Spring MVC依赖</strong></p><p><font color=red><strong>SpringBoot构建工程时：勾选 Spring Web 项</strong></font></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Spring MVC依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2 MyBatis依赖</strong></p><p><font color=red><strong>SpringBoot构建工程时：勾选 MyBatis Framework 项</strong></font></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--MyBatis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3 MySQL依赖</strong></p><p><font color=red><strong>SpringBoot构建工程时，勾选 MySQL Driver 项</strong></font></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--MySQL依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>4 Lombok依赖</strong></p><p><font color=red><strong>SpringBoot构建工程时，勾选 Lombok 项</strong></font></p><p><font color=blue><strong>需要注意：确认是否安装了Lombok的插件，在 File - Settings - Plugins 中确认</strong></font></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Lombok依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>5 Spring Validation依赖</strong></p><p><font color=red><strong>SpringBoot构建工程时，勾选 Validation 项</strong></font></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Validation依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>手动添加依赖项</strong></p><p><strong>1 Knife4j依赖</strong></p><p><font color=blue><strong>SpringBoot构建工程时，无法勾选，需要手动添加该项依赖</strong></font></p><p><font color=blue><strong>注意：添加完依赖之后，需要先创建Knife4j的配置文件后再使用</strong></font></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加Knife4j依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-openapi2-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>默认添加依赖项</strong></p><p><strong>1 SpringBoot测试依赖</strong></p><p><font color=red><strong>SpringBoot构建工程时，无须勾选，默认会自动添加</strong></font></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringBoot测试组件依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><p>Spring Boot是一个Java软件开发框架（Spring 脚手架） 简化项目的初始搭建以及开发过程</p><p>SpringBoot核心特性<br>起步依赖<br>创建项目时，会默认添加基础依赖，简化我们自己查找依赖的过程。<br>嵌入式服务(Tomcat)<br>SpringBoot工程支持内嵌的web服务，可以将tomcat这样的服务直接嵌套到web依赖中。</p><p>创建SpringBoot工程</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309111909099.png" alt="image-20230911190936021"></p><p>添加相关依赖</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309191556165.png" alt="image-20230911191013223"></p><p>Spring Boot  指定版本为 <strong>2.7.15</strong></p><p>SpringBoot项目目录结构</p><p>Application  为引导类 </p><p> <img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309191556960.png" alt="image-20230911192935436"></p><p>@SpringBootApplication 组合注解包含了以下三个重要注解</p><ul><li>@EnableAutoConfiguration：开启自动配置</li><li>@ComponentScan：开启注解扫描</li><li>@SpringBootConfiguration</li></ul><p>使用SpringBoot构建一个项目，只需要引入所需依赖，配置就可以交给SpringBoot处理了</p><p>创建包需要在引导类的同级目录下或者子目录下 否则会报错 </p><p>Application.properties  为配置文件</p><p>SpringBoot为我们提供了默认配置，而默认配置生效的条件一般有两个：</p><ul><li>你引入了相关依赖</li><li>你自己没有配置</li></ul><p>1）启动器</p><p>我们如果不想配置，只需要引入依赖即可，而依赖版本我们也不用操心，因为只要引入了SpringBoot提供的stater（启动器），就会自动管理依赖及版本了。</p><p>因此SpringBoot的第一件事情，就是找启动器，SpringBoot提供了大量的默认启动器</p><p>2）全局配置</p><p>另外，SpringBoot的默认配置，都会读取默认属性，而这些属性可以通过自定义<code>application.properties</code>文件来进行覆盖。这样虽然使用的还是默认配置，但是配置中的值改成了我们自定义的。</p><p>因此，玩SpringBoot的第二件事情，就是通过<code>application.properties</code>来覆盖默认属性值，形成自定义配置。我们需要知道SpringBoot的默认属性key</p><p><strong>Spring Boot 常见配置:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改端口:# 映射端口 </span><br><span class="line">server.port=80</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/blog?serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line"></span><br><span class="line">#jdbc自带的hikari连接池</span><br><span class="line">spring.datasource.hikari.idle-timeout=60000</span><br><span class="line">spring.datasource.hikari.maximum-pool-size=30</span><br><span class="line">spring.datasource.hikari.minimum-idle=10</span><br><span class="line"></span><br><span class="line">#druid连接池</span><br><span class="line">#初始化连接数</span><br><span class="line">spring.datasource.druid.initial-size=1</span><br><span class="line">#最小空闲连接</span><br><span class="line">spring.datasource.druid.min-idle=1</span><br><span class="line">#最大活动连接</span><br><span class="line">spring.datasource.druid.max-active=20</span><br><span class="line">#获取连接时测试是否可用</span><br><span class="line">spring.datasource.druid.test-on-borrow=true</span><br><span class="line">#监控页面启动</span><br><span class="line">spring.datasource.druid.stat-view-servlet.allow=true</span><br><span class="line"></span><br><span class="line"># mybatis 别名扫描  批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以）</span><br><span class="line">mybatis.type-aliases-package=cn.deng.mapper</span><br><span class="line"># 设置MyBatis框架的映射（Mapper）配置文件的位置</span><br><span class="line">mybatis.mapper-locations=classpath:mappers/*.xml</span><br><span class="line"></span><br><span class="line"># 设置org.springframework包的日志级别为debug  </span><br><span class="line">logging.level.org.springframework=debug</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>SpringBoot整合SpringMVC添加拦截器</strong>  </p><p>通过实现<code>WebMvcConfigurer</code>并添加<code>@Configuration</code>注解来实现自定义部分SpringMvc配置。</p><p>定义拦截器:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;preHandle method is running!&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;postHandle method is running!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;afterCompletion method is running!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>定义配置类,注册拦截器:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MvcConfiguration implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private HandlerInterceptor myInterceptor;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重写接口中的addInterceptors方法，添加自定义拦截器</span><br><span class="line">     * @param registry</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        registry.addInterceptor(myInterceptor).addPathPatterns(&quot;/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>SpringBoot 整合连接池:</strong></p><p>引入JDBC启动器</p><!--jdbc的启动器，默认使用HikariCP连接池--><dependency>    <groupId>org.springframework.boot</groupId>    <artifactId>spring-boot-starter-jdbc</artifactId></dependency><p>引入Druid连接池启动器</p><!-- Druid连接池 --><dependency>    <groupId>com.alibaba</groupId>    <artifactId>druid-spring-boot-starter</artifactId>    <version>1.1.6</version></dependency><p><strong>Spring Boot 控制数据库事务</strong></p><p>@Transactional</p><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><p>IOC  控制反转 </p><p>方便解耦，简化开发<br>通过 Spring提供的 IoC容器，可以将对象间的依赖关系交由 Spring进行控制，避免硬编码所造<br>成的过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可<br>以更专注于上层的应用。</p><p>DI    依赖注入 它是 spring 框架核心 ioc 的具体实现</p><p>比如框架把持久层对象传入业务层，而不用我们自己去获取</p><p>Spring bean 对象</p><p> AOP面向切面编程</p><p>  Aspect Oriented Programming 的简写，为 面向切面编程。AOP用来封装多个类的公共行为，将那些与业务无关，却为业务模块共同调用的逻辑封装起来，减少系统的重复代码。</p><p>xml配置文件:</p><?xml version="1.0" encoding="UTF-8"?><p><beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsd"><br></beans></p><!-- bean 标签：用于配置让 spring 创建对象，并且存入 ioc 容器之中id 属性：对象的唯一标识。class 属性：指定要创建对象的全限定类名--><!-- 配置 dao --><p><bean id="accountDao" class="com.deng.dao.impl.AccountDaoImpl"></bean></p><p><strong>包路径快捷键</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows:  Ctrl + Shift + Alt + c</span><br></pre></td></tr></table></figure><p><strong>Bean 的 生命周期</strong></p><ul><li><p>实例化</p><p>给当前Bean对象去分配资源，通过无参构造方法实现；</p></li><li><p>属性赋值</p><p>依赖注入，通过set方法；</p></li><li><p>初始化</p><p>通过 <code>@PostConstruct</code> 注解进行一些初始化的操作，比如连接数据库，打开文件……</p></li><li><p>使用阶段</p></li><li><p>销毁</p><p>通过 <code>@PreDestroy</code> 注解进行一些资源的释放的操作，比如断开数据库连接，关闭文件……</p></li></ul><p><strong>SpringBean对象属性值的三种注入方法:</strong></p><p><strong>构造函数注入</strong></p><!-- 使用构造函数的方式，给 service 中的属性传值要求：类中需要提供一个对应参数列表的构造函数。涉及的标签：constructor-arg属性：index:指定参数在构造函数参数列表的索引位置type:指定参数在构造函数中的数据类型name:指定参数在构造函数中的名称 用这个找给谁赋值=======上面三个都是找给谁赋值，下面两个指的是赋什么值的==============value:它能赋的值是基本数据类型和 String 类型ref:它能赋的值是其他 bean 类型，也就是说，必须得是在配置文件中配置过的 bean--><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;accountService&quot; class=&quot;com.deng.service.impl.AccountServiceImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;name&quot; value=&quot; 张三 &quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><strong>set 方法注入</strong></p><!-- 通过配置文件给 bean 中的属性传值：使用 set 方法的方式涉及的标签：property属性：name：找的是类中 set 方法后面的部分ref：给属性赋值是其他 bean 类型的value：给属性赋值是基本数据类型和 string 类型的实际开发中，此种方式用的较多。--><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;accountService&quot; class=&quot;com.deng.service.impl.AccountServiceImpl&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;test&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><strong>p 名称空间注入数据（本质还是调用 set 方法）</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line"></span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">&lt;bean id=&quot;accountService&quot;</span><br><span class="line">class=&quot;com.deng.service.impl.AccountServiceImpl4&quot;</span><br><span class="line">p:name=&quot;test&quot; p:age=&quot;21&quot; p:birthday-ref=&quot;now&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p><strong>集合注入</strong></p><p>顾名思义，就是给类中的集合成员传值，它用的也是set方法注入的方式，只不过变量的数据类型都是集合。<br>我们这里介绍注入数组，List,Set,Map,Properties。</p><!-- 注入集合数据List 结构的：array,list,setMap 结构的map,entry,props,prop--><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;</span><br><span class="line">&lt;!-- 在注入集合数据时，只要结构相同，标签可以互换 --&gt;</span><br><span class="line">&lt;!-- 给数组注入数据 --&gt;</span><br><span class="line">&lt;property name=&quot;myStrs&quot;&gt;</span><br><span class="line">&lt;set&gt;</span><br><span class="line">&lt;value&gt;AAA&lt;/value&gt;</span><br><span class="line">&lt;value&gt;BBB&lt;/value&gt;</span><br><span class="line">&lt;value&gt;CCC&lt;/value&gt;</span><br><span class="line">&lt;/set&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!-- 注入 list 集合数据 --&gt;</span><br><span class="line">&lt;property name=&quot;myList&quot;&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">&lt;value&gt;AAA&lt;/value&gt;</span><br><span class="line">&lt;value&gt;BBB&lt;/value&gt;</span><br><span class="line">&lt;value&gt;CCC&lt;/value&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!-- 注入 set 集合数据 --&gt;</span><br><span class="line">&lt;property name=&quot;mySet&quot;&gt;</span><br><span class="line">&lt;list&gt;</span><br><span class="line">&lt;value&gt;AAA&lt;/value&gt;</span><br><span class="line">&lt;value&gt;BBB&lt;/value&gt;</span><br><span class="line">&lt;value&gt;CCC&lt;/value&gt;</span><br><span class="line">&lt;/list&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!-- 注入 Map 数据 --&gt;</span><br><span class="line">&lt;property name=&quot;myMap&quot;&gt;</span><br><span class="line">&lt;props&gt;</span><br><span class="line">&lt;prop key=&quot;testA&quot;&gt;aaa&lt;/prop&gt;</span><br><span class="line">&lt;prop key=&quot;testB&quot;&gt;bbb&lt;/prop&gt;</span><br><span class="line">&lt;/props&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!-- 注入 properties 数据 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;property name=&quot;myProps&quot;&gt;&lt;map&gt;</span><br><span class="line">&lt;entry key=&quot;testA&quot; value=&quot;aaa&quot;&gt;&lt;/entry&gt;</span><br><span class="line">&lt;entry key=&quot;testB&quot;&gt;</span><br><span class="line">&lt;value&gt;bbb&lt;/value&gt;</span><br><span class="line">&lt;/entry&gt;</span><br><span class="line">&lt;/map&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><strong>基于XML配置获取Springbean 对象</strong></p><p>//1.使用 ApplicationContext 接口，就是在获取 spring 容器<br>ApplicationContext ac = new ClassPathXmlApplicationContext(“bean.xml”);<br>//2.根据 bean 的 id 获取对象<br>IAccountService aService = (IAccountDao) ac.getBean(“accountDao”);</p><p><strong>基于注解方式获取Spring bean  对象</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(<span class="string">&quot;cn.deng.spring&quot;</span>);<span class="comment">//获取IOC容器</span></span><br><span class="line"><span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> context.getBean(UserDao.class);<span class="comment">//获取Bean对象</span></span><br></pre></td></tr></table></figure><p><strong>基于注解的 IOC 配置</strong></p><p>xml配置文件中告知spring 创建容器时要扫描的包</p><p>&lt;context:component-scan base-package=”cn.deng”&gt;</context:component-scan></p><p><strong>注解方式:</strong></p><p>@Component(value=””)   相当于：<bean id="" class=""></p><p> value：指定 bean 的 id。如果不指定 value 属性，默认 bean 的 id 是当前类的类名。首字母小写。<br>    @Repository   Dao层 数据访问层<br>    @Service        Service层   业务层</p><p>​    @Controller    Controller层  控制层</p><p>@Value          将属性值(基本类型和String 类型值)直接注入到bean中       </p><p>@Autowired   将对象 接口注入到bean 中<br>当接口只有唯一一个实现类的时候 spring会通过接口找到该实现类 并创建bean对象以及DI注入操作<br>当接口有多个实现类的时候 spring无法确定注入哪个实现类对象  可以使用@Qualifier 来解决</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Autowired   </span><br><span class="line">@Qualifier()</span><br></pre></td></tr></table></figure><p>@Qualifier      通过 value 来确定使用哪个实现类对象</p><p>​    搭配@Component组件一起使用</p><p>@Resource    直接按照 Bean 的 id 注入。它只能注入其他 bean 类型。</p><p>@Scope    bean的作用域<br>    Singleton (数据库连接) Prototype(多任务)</p><p>@PostConstruct  Bean对象创建之后初始化 作用在方法上</p><p>@PreDestroy  Bean对象销毁之前关闭资源 作用在方法上</p><p>@PropertySource(“classpath:”) Bean对象注入外部文件</p><p>@ComponentScan 注解用于指定要扫描的包或类 生成SpringBean 对象</p><p>@Configuration    Spring配置类</p><p>@Bean  将方法声明为一个注册Bean的方法，Spring会自动调用该方法，将方法的返回值加入Spring容器中。相当于以前的bean标签</p><p>@Import  作用：<br>        用于导入其他配置类，在引入其他配置类时，可以不用再写@Configuration 注解。当然，写上也没问题。<br>        属性：<br>        value[]：用于指定其他配置类的字节码。</p><p><strong>Spring纯注解配置</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &quot;com.deng.spring&quot;)</span><br><span class="line">@Import(&#123; JdbcConfig.class&#125;)</span><br><span class="line">public class SpringConfiguration &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br><span class="line">public class JdbcConfig&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><p>Mybatis<br>DAO 层 数据层</p><p>pojo   映射实体类<br>dto      客户端传给服务端数据<br>vo类   服务端返回给数据端的数据类</p><p><strong>@Mapper   映射数据层接口</strong><br>描述数据层的接口 为此接口创建实现类<br>@Insert  插入数据<br>根据接口方法参数类型自动的插入数据</p><p><strong>Mybatis 使用 XML 方式</strong></p><p>第1步：创建工程  springboot 工程配置mybatis相关的依赖<br>第2步：配置文件中配置数据库连接信息（application.properties）<br>spring.datasource.url=jdbc:mysql://localhost:3306/mybatisdb<br>spring.datasource.username=root<br>spring.datasource.password=root<br>第3步：配置文件中配置xml文件映射位置（application.properties）<br>mybatis.mapper-locations=classpath:mappers/*.xml<br>第4步：创建xml文件存放目录，并拷贝xml模板文件<br>mappers/<em><strong>Mapper.xml<br>第5步：创建映射接口，</strong>并添加 @Mapper 注解</em>*</p><p>第6步：定义接口方法，指定返回值类型[如有必要则创建VO类]<br>第7步：xml文件配置SQL</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;cn.deng.egmybatis2.mapper.CustomersMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第8步：定义测试方法进行测试（首先要进行自动装配）<br>@Autowired 自动装配<br>装配需要测试的 Mpaper 接口 </p><p><strong>Mybatis  XML  常用语法</strong></p><p>select<br>用于查询操作，包括多表查询、条件查询等。可以使用 resultType 来指定返回结果的类型。</p><p>查询数据库对象和POJO对象不一致情况 需要给查询的数据起别名</p><p>insert<br>用于插入操作，并将其自动注入实体类中。</p><p>update<br>用于更新操作，包括更新一条记录或者批量更新。</p><p>delete<br>用于删除操作，包括删除一条记录或者批量删除。</p><p>if、foreach、set<br>用于条件控制，可以根据不同的条件进行查询、插入、更新和删除操作。if 标签用于指定可以为空的查询条件，foreach 标签用于循环查询，set 标签用于指定更新操作的字段值。</p><p>sql：用于定义可重用的 SQL 片段，通常是一些较为复杂的 SQL 片段。可以在其它 SQL 语句中使用 include 标签来引用 SQL 片段。</p><p>include：用于引入外部的 SQL 片段。可以在 include 标签的 refid 属性中指定外部 SQL 片段的名字，然后在当前 SQL 中使用它。</p><p>resultType   返回类型</p><p><strong>动态 SQL</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;if test=&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;where&gt;&lt;where/&gt; </span><br></pre></td></tr></table></figure><p>搭配 include 标签使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;include refid=&quot;deleteSql&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;where&gt;&lt;if test=&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;where/&gt; </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--重复SQL抽取--&gt;</span><br><span class="line">&lt;sql id=&quot;deleteSql&quot;&gt;</span><br><span class="line">    DELETE FROM blog.comment WHERE id IN</span><br><span class="line">&lt;/sql&gt;</span><br></pre></td></tr></table></figure><p>搭配 include 标签使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;include refid=&quot;deleteSql&quot;/&gt;</span><br></pre></td></tr></table></figure><p><strong>动态删除-数组</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">    根据评论id,动态删除评论表中数据,要求参数为数组</span><br><span class="line">    DELETE FROM blog.comment WHERE id IN (2,3,5)</span><br><span class="line">    1.foreache标签: xml中的遍历标签</span><br><span class="line">    2.collection属性: 用于指定需要遍历的数据类型,array为数组,list为集合</span><br><span class="line">    3.item属性: 变量名,用于接收遍历出来的每个数据</span><br><span class="line">    4.separator属性: 用于指定多个元素之间的分隔符</span><br><span class="line">--&gt;</span><br><span class="line">&lt;delete id=&quot;deleteByIds1&quot;&gt;</span><br><span class="line">    &lt;include refid=&quot;deleteSql&quot;/&gt; (</span><br><span class="line">        &lt;foreach collection=&quot;array&quot; item=&quot;abc&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">            #&#123;abc&#125;</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    )</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure><p><strong>动态删除-集合</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;foreach collection=&quot;ids&quot; open=&quot;id in ( &quot; close=&quot;)&quot; item=&quot;uid&quot;</span><br><span class="line">separator=&quot;,&quot;&gt;</span><br><span class="line">#&#123;uid&#125;</span><br><span class="line">&lt;/foreach&gt;</span><br><span class="line"></span><br><span class="line">&lt;foreach&gt;标签用于遍历集合，它的属性：</span><br><span class="line">collection:代表要遍历的集合元素，注意编写时不要写#&#123;&#125;</span><br><span class="line">open:代表语句的开始部分</span><br><span class="line">close:代表结束部分</span><br><span class="line"></span><br><span class="line">item:代表遍历集合的每个元素，生成的变量名</span><br><span class="line">sperator:代表分隔符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line"></span><br><span class="line">动态删除,集合方式,collection属性值指定为:list</span><br><span class="line"></span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;delete id=&quot;deleteByIds2&quot;&gt;</span><br><span class="line">    &lt;include refid=&quot;deleteSql&quot;/&gt; (</span><br><span class="line">    &lt;foreach collection=&quot;list&quot; item=&quot;abc&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">        #&#123;abc&#125;</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">    )</span><br><span class="line">&lt;/delete&gt;</span><br></pre></td></tr></table></figure><p><strong>动态修改</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt; !--</span><br><span class="line"></span><br><span class="line">动态修改:根据评论ID修改评论的相关内容</span><br><span class="line"></span><br><span class="line">--&gt;</span><br><span class="line">&lt;update id=&quot;dynamicUpdate&quot;&gt;</span><br><span class="line">    UPDATE blog.comment</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">        &lt;if test=&quot;content!=null&quot;&gt;content=#&#123;content&#125;,&lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;created!=null&quot;&gt;created=#&#123;created&#125;,&lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;userId!=null&quot;&gt;user_id=#&#123;userId&#125;,&lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;weiboId!=null&quot;&gt;weibo_id=#&#123;weiboId&#125;&lt;/if&gt;</span><br><span class="line">    &lt;/set&gt;</span><br><span class="line">    WHERE id=#&#123;id&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure><p><strong>多表联查一对一</strong></p><p>建立一个VO类 用来装两个或者多张表的参数 用啥返回啥</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectById&quot;</span> resultType=<span class="string">&quot;cn.deng._03mybatisdemo.pojo.vo.WeiboDetailVO&quot;</span>&gt;</span><br><span class="line">    SELECT w.id, w.content, w.created, u.nickname</span><br><span class="line">    FROM weibo w JOIN user u ON w.user_id=u.id</span><br><span class="line">    WHERE w.id=#&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p><strong>ResultMap单表</strong></p><p>resultMap属性是用来定义查询结果和Java对象属性之间的映射关系；</p><p>通过resultMap属性可以<strong>自定义</strong>查询结果与Java对象属性的映射关系。</p><ul><li><code>&lt;resultMap&gt;标签</code><ul><li><code>id</code> 属性：唯一标识</li><li><code>type</code> 属性：指定映射的JAVA类型</li></ul></li><li><code>&lt;id&gt;标签</code> ：指定映射的主键字段，包含 <code>column属性</code> 和 <code>property属性</code><ul><li><code>column属性</code> ：查询语句中的列名（或别名）</li><li><code>property属性</code> ：JAVA对象中的属性名</li></ul></li><li><code>&lt;result&gt;标签</code> ：指定映射的非主键字段，包含 <code>column属性</code> 和 <code>property属性</code><ul><li><code>column属性</code> ：查询语句中的列名（或别名）</li><li><code>property属性</code> ：JAVA对象中的属性名</li></ul></li><li><code>&lt;collection&gt;标签</code> ：映射一对多或多对多关系<ul><li><code>property属性</code> ：JAVA对象中的属性名</li><li><code>ofType属性</code> ：集合中元素的类型</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    resultMap示例</span></span><br><span class="line"><span class="comment">    1.id属性：唯一标识</span></span><br><span class="line"><span class="comment">    2.type属性：指定映射的JAVA类型</span></span><br><span class="line"><span class="comment">    3.&lt;id&gt;标签：映射主键字段</span></span><br><span class="line"><span class="comment">    4.&lt;result&gt;标签：映射非主键字段</span></span><br><span class="line"><span class="comment">    5.column属性：查询语句中的列名(别名)</span></span><br><span class="line"><span class="comment">    6.property属性：java中的属性名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;aaa&quot;</span> <span class="attr">type</span>=<span class="string">&quot;cn.tedu._03MYBATIS.pojo.WeiboMapVO1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;content&quot;</span> <span class="attr">property</span>=<span class="string">&quot;content&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMapById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;aaa&quot;</span>&gt;</span></span><br><span class="line">    SELECT id,</span><br><span class="line">    content,</span><br><span class="line">    user_id</span><br><span class="line">    FROM weibo</span><br><span class="line">    WHERE id = #&#123;wid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 建立对应关系 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;account&quot;</span> <span class="attr">id</span>=<span class="string">&quot;accountMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;aid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;uid&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;money&quot;</span> <span class="attr">property</span>=<span class="string">&quot;money&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 它是用于指定从表方的引用实体属性的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;user&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;address&quot;</span> <span class="attr">property</span>=<span class="string">&quot;address&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;accountMap&quot;</span>&gt;</span></span><br><span class="line">    select u.*,a.id as aid,a.uid,a.money from account a,user u where a.uid =u.id;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>ResultMap多表一对多</strong> </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    查询指定的用户发布的所有的 **微博信息** ，要求将 **微博信息** 放到一个集合中</span></span><br><span class="line"><span class="comment">    要求显示：用户的id、用户昵称、`List&lt;Weibo&gt;集合`</span></span><br><span class="line"><span class="comment">    resultMap示例</span></span><br><span class="line"><span class="comment">    1.id属性：唯一标识</span></span><br><span class="line"><span class="comment">    2.type属性：指定映射的JAVA类型</span></span><br><span class="line"><span class="comment">    3.&lt;id&gt;标签：映射主键字段</span></span><br><span class="line"><span class="comment">    4.&lt;result&gt;标签：映射非主键字段</span></span><br><span class="line"><span class="comment">    5.column属性：查询语句中的列名(别名)</span></span><br><span class="line"><span class="comment">    6.property属性：java中的属性名</span></span><br><span class="line"><span class="comment">    7.&lt;collection&gt;标签：映射一对多或多对多关系</span></span><br><span class="line"><span class="comment">    8.ofType属性：集合中元素的类型</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;ccc&quot;</span> <span class="attr">type</span>=<span class="string">&quot;cn.tedu._03MYBATIS.pojo.WeiboMapVO2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;nickname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;nickname&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;weibos&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;cn.tedu._03MYBATIS.pojo.Weibo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;wid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;content&quot;</span> <span class="attr">property</span>=<span class="string">&quot;content&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;created&quot;</span> <span class="attr">property</span>=<span class="string">&quot;created&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;user_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;userId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMapByUserId&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;ccc&quot;</span>&gt;</span></span><br><span class="line">    SELECT u.id,</span><br><span class="line">    u.nickname,</span><br><span class="line">    w.id wid,</span><br><span class="line">    w.content,</span><br><span class="line">    w.created,</span><br><span class="line">    w.user_id</span><br><span class="line">    FROM user u</span><br><span class="line">    JOIN weibo w ON w.user_id = u.id</span><br><span class="line">    WHERE u.id = #&#123;uid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>多表对多</strong></p><p>相当于两个 一对多</p><p><strong>常见问题:</strong></p><ul><li><p>数据库驱动异常</p><p><strong>检查配置文件中数据库连接的URL地址</strong></p><p>Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name <strong>‘dataSource’</strong> defined in class path resource</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309191556063.png" alt="image-20230910092029653"></p></li><li><p>数据库连接异常</p><p><strong>检查配置文件中数据库连接配置信息</strong></p><p>Error updating database. Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain <strong>JDBC Connection</strong>; nested exception is java.sql.SQLException: !AuthenticationProvider.BadAuthenticationPlugin!</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309100920871.png" alt="image-20230910092057831"></p></li><li><p>xml文件语法错误</p><p><strong>根据文件提示检查xml文件具体语法</strong></p><p>Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name <strong>‘sqlSessionFactory’</strong> defined in class path resource [org/mybatis/spring/boot/autoconfigure/MybatisAutoConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309191556910.png" alt="image-20230910092112018"></p></li><li><p>绑定异常</p><ol><li><strong>配置文件中xml文件映射位置指定错误:<code>mybatis.mapper-locations=</code></strong></li><li><strong>xml文件中名称空间 namespace 属性值错误</strong></li><li><strong>检查标签中的 id 属性值 是否和 接口方法名一致</strong></li></ol><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309191556886.png" alt="image-20230910092121785"></p></li><li><p>SQL语法错误</p><p><strong>出现此异常请仔细检查SQL语句,可以放到 console 中执行SQL语句测试</strong></p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309191556308.png" alt="image-20230910092212766"></p></li><li><p>查询结果封装异常</p><p><strong>比如指定 VO 对象接收返回值,但是查询时查到多条结果</strong></p></li></ul><p><strong>Mybatis XML配置问题</strong></p><ul><li>获取新增用户 id (自增长)的返回值</li></ul><p>新增用户后，同时还要返回当前新增用户的 id 值，因为 id 是由数据库的自动增长来实现的，所以就相<br>当于我们要在新增后将自动增长 auto_increment 的值返回。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;saveUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;USER&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置保存时获取插入的 id --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyColumn</span>=<span class="string">&quot;id&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">select last_insert_id();</span><br><span class="line"><span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">insert into user(username,birthday,sex,address)</span><br><span class="line">values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>模糊查询的两种方式:防止SQL注入攻击</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">语句1:select * from user where username like ?  参数: %邓%</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.deng.domain.User&quot;</span>&gt;</span></span><br><span class="line">select * from user where username like #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">语句2:select * from user where username like %邓%  参数: 邓</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.deng.domain.User&quot;</span>&gt;</span></span><br><span class="line">select * from user where username like &#x27;%$&#123;value&#125;%&#x27;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#&#123;&#125; 表示一个占位符号</span><br><span class="line">通过#&#123;&#125;可以实现 preparedStatement 向占位符中设置值，自动进行 java 类型和 jdbc 类型转换，</span><br><span class="line">#&#123;&#125;可以有效防止 sql 注入。 #&#123;&#125;可以接收简单类型值或 pojo 属性值。 如果 parameterType 传输单个简单类</span><br><span class="line">型值，#&#123;&#125;括号中可以是 value 或其它名称。</span><br><span class="line">$&#123;&#125; 表示拼接 sql 串</span><br><span class="line">通过$&#123;&#125;可以将 parameterType 传入的内容拼接在 sql中且不进行 jdbc 类型转换， $&#123;&#125;可以接收简</span><br><span class="line">单类型值或 pojo 属性值，如果 parameterType 传输单个简单类型值，$&#123;&#125;括号中只能是 value。</span><br></pre></td></tr></table></figure><p><strong>Mybatis 使用注解配置(不能处理复杂的业务逻辑)</strong></p><p>@Mapper</p><p>​    MyBatis框架的注解，用于描述数据层接口，告诉系统底层为此接口创建其实现类，在实现类中定<br>​    义数据访问逻辑，执行与数据库的会话(交互)。</p><p>@Insert</p><p>​    MyBatis框架注解，使 MyBatis 框架根据接口方法的参数类型自动生成插入数据的JDBC代码。</p><p>@Update</p><p>@Delete</p><p>@Select</p><p><strong>Mybatis延迟加载：</strong><br>就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。延迟加载也称懒加载.<br>好处：先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速度要快。</p><h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p>MVC</p><ul><li><p>降低各个模块之间的耦合度, 使工程可扩展性和可维护性更强.</p></li><li><p>M: Model 模型, 业务逻辑处理和数据库交互.</p></li><li><p>V: View 视图, 负责数据展示(html css js images)</p></li><li><p>C: Controler 控制器, 负责接收请求,调用模型层进行业务处理,并将结果返回给视图层.</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309101436908.png" alt="image-20230910143630853"></p></li></ul><p>SpringMVC是一种基于MVC（模型-视图-控制器）模式的Web框架，它是基于Spring框架的一个子项目。</p><p>它通过将请求分派给相应的控制器来处理Web请求，然后将处理结果发送回客户端。</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309191556679.png" alt="image-20230910140027395"></p><ol><li>客户端发送请求至前端控制器DispatcherServlet</li><li>DispatcherServlet收到请求后，调用处理器映射器HandlerMapping</li><li>HandlerMapping根据请求URL找到具体的Controller。</li><li>Controller处理请求，并返回ModelAndView，其中的View只是视图名，并不指向具体的视图组件</li><li>DispatcherServlet通过ViewReslover（视图解析器）确定负责显示数据的具体View</li><li>DispatcherServlet对View进行渲染视图（即将Model填充至视图组件中），并将完整的视图响应到客户端</li></ol><ul><li><p>客户端: 更改了客户端的html代码或者添加了图片,一定要 <strong>Rebuild Static</strong></p></li><li><p>服务端: 如果服务端代码有更新必须要重启工程</p></li></ul><p>SpringMVC处理请求</p><p>静态请求:html CSS JS 数据</p><p>默认页面:inde.html </p><p>静态资源默认位置:</p><p>ResourceProperties的类，里面就定义了静态资源的默认查找路径： </p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309191556130.png" alt="image-20230911195747544"></p><p>默认的静态资源路径为：</p><ul><li>classpath:/META-INF/resources/</li><li>classpath:/resources/</li><li>classpath:/static/</li><li>classpath:/public/</li></ul><p>只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。</p><p>我们一般放在static 下面</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309111958004.png" alt="image-20230911195834969"></p><p>动态请求: 数据库数据</p><ul><li><p><code>@Controller</code> 注解</p><p>标注一个类；</p><p>表示该类是一个<strong>控制器</strong>，负责处理用户的请求，并将处理结果生成响应返回给客户端。</p></li><li><p><code>@RequestMapping</code> 注解</p><p>请求注解；</p><p>添加在控制器类或控制器方法上；</p><p>将HTTP请求映射到控制器中的方法，指定处理请求的路径</p><ul><li>控制器类上：为整个控制器指定一个基础路径</li><li>控制器方法上：指定相对于基础路径的具体路径</li></ul></li><li><p><code>@ResponseBody</code> 注解</p><p>响应注解；</p><p>添加在控制器方法上；</p><p>可以使控制器方法通过返回值的方式将响应返回给客户端。</p></li></ul><p>Http请求方法:</p><p>GET  </p><p>POST </p><p><strong>客户端发送数据-&gt; controller</strong></p><p>GET</p><p>POST</p><ul><li>html中：Form表单完成POST请求方式的发送</li><li>IDEA中：<code>.http</code> 后缀文件完成POST请求的发送</li></ul><p>服务端返回数据 -&gt;modelandview</p><p><strong>.http文件测试接口</strong></p><p>使用SpringMVC中提供的 <code>.http</code> 后缀的文件来测试 Controller 层接口。</p><p><font color=red>使用三个 # 号 作为不同测试方法的分隔符，也可以作为注释说明。</font></p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309121329610.png" alt="image-20230912132921545"></p><p>第1步：在test目录下创建 Directory ：http</p><p>第2步：创建 <code>.http</code> 后缀的文件进行测试：testUserController.http</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### GET请求测试</span><br><span class="line">GET http://localhost:8080/v1/users/login?username=liying&amp;password=123456</span><br><span class="line">Accept: application/json</span><br><span class="line"></span><br><span class="line">### POST请求测试</span><br><span class="line">POST http://localhost:8080/v1/users/login</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">username=liying&amp;password=123456</span><br></pre></td></tr></table></figure><p>第3步：执行对应的请求方法测试</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309191556770.png" alt="image-20230910170442100"></p><p><strong>服务端接收参数</strong></p><p><strong>HttpServletRequest接收</strong></p><p>客户端把用户名和密码信息传递给服务端，服务端接收传递过来的用户名和密码信息。</p><p>controller.UserController 处理请求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**方式1：使用HttpServletRequest接收数据*/</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/v1/users/login&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> username + <span class="string">&quot;:&quot;</span> + password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>声明参数接收</strong></p><p>以在处理请求的方法中通过 <strong>声明参数的方式</strong> 来接收客户端传递过来的数据。</p><p>第1步：controller.UserController处理登录请求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**方式2：通过声明参数的方式接收*/</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/v1/users/login&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="comment">// 好处：代码简洁，并且可以自动根据声明的类型进行转换</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(String username, String password)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;username = &quot;</span> + username + <span class="string">&quot;, password = &quot;</span> + password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第2步：重启工程，执行测试脚本测试</p><p><strong>声明POJO类接收</strong></p><p>如果客户端传递数据过多，</p><p>通过 <code>HttpServletRequest</code> 方式接收复用性较差，通过 <code>声明参数接收</code> 很繁琐；</p><p>所以可以将数据封装到 <code>POJO类</code> 中来接收。</p><p><strong>POJO</strong></p><p>Plain Ordinary Java Object：简单的Java对象；</p><p>是没有继承任何类或实现任何接口的简单 Java 对象，也不依赖于其他复杂的框架或技术；</p><p>POJO 对象通常包含了纯粹的数据和简单的业务逻辑，是一种用于简化 Java 应用程序开发的编程模型；</p><p><strong>是entity实体类、VO（Value Object或View Object）视图对象、DTO（Data Transfer Object）数据传输对象 这3个对象的总称。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309121331639.png" alt="image-20230912133145568"></p><p> entity实体类|DTO|VO</p><ul><li><p>entity实体类作用</p><p>用来和数据库中的表字段一一对应的，比如UserEntity(id,username,password,nickname)；</p></li><li><p>DTO作用</p><p>用来接收客户端传递给服务器的数据的，比如：UserLoginDTO(username,password)    实现登录功能，客户端向服务器端传递数据；</p><p><strong>参数数量为1-2个时,使用声明参数方式接收, 如果参数数量为3个以上, 使用声明DTO类方式接收</strong></p></li><li><p>VO作用</p><p>用来处理服务器响应给客户端的数据的，比如：UserListVO(id,username,nickname)  登录成功后的列表页显示当前用户信息。</p></li></ul><p><strong>SpringMVC 项目流程:</strong></p><ol><li>搭建整体环境<ul><li>配置文件中配置xml文件映射位置及数据库连接信息(mybatis)</li><li><strong>创建controller包(添加@Controller)</strong></li><li>创建接口(DAO层接口)</li><li>创建pojo(entity,DTO,VO)</li><li>创建mappers目录,存放xml文件, 并指定名称空间namespace</li></ul></li><li>创建实体类</li><li>创建DTO </li><li>梳理Controller中功能实现的逻辑</li><li>定义接口方法 配置xml 测试接口</li><li>完成Controller中的最终逻辑[<strong>自动装配</strong>]</li><li>重启工程,测试功能</li></ol><p><strong>注解</strong></p><ul><li><p><code>@RequestMapping</code> 注解</p><p>请求注解；</p><p>添加在控制器类或控制器方法上；</p><p>将HTTP请求映射到控制器中的方法，指定处理请求的路径</p><ul><li>控制器类上：为整个控制器指定一个基础路径</li><li>控制器方法上：指定相对于基础路径的具体路径</li></ul></li><li><p><code>@Controller</code> 注解</p><p>标注一个类；</p><p>表示该类是一个控制器，负责处理用户的请求，并将处理结果生成响应返回给客户端。</p><p>声明该类为SpringMVC的控制器组件，可以接收HTTP请求并返回响应给客户端。</p></li><li><p><code>@ResponseBody</code> 注解</p><p>响应注解；</p><p>添加在控制器方法上；</p><p>可以使控制器方法通过返回值的方式将响应返回给客户端。</p><p>将控制器方法返回的对象直接作为HTTP响应的内容返回客户端</p><p>将控制器方法返回的JAVA对象转为JSON格式的字符串返回给客户端</p></li><li><p><strong><code>@RestController</code> 注解(重要)</strong></p><p>作用于类上；组合注解, 相当于 @Controller注解 + @ResponseBody注解 ；</p><p>作用是将类中的方法返回值直接作为HTTP响应的内容；</p><p>在控制器类中加入该注解后，无需在每个方法上添加<code>@ResponseBody</code>注解；</p><p>可以让Spring框架自动将方法的返回值序列化并填充到HTTP响应中，实现Web服务端点的快速开发。</p></li><li><p><code>@MapperScan</code> 注解说明</p><p>添加在 <strong>Spring配置类</strong> 上；</p><p><strong>用于告诉 Spring 扫描 MyBatis Mapper 接口并创建对应的 Mapper 实现；</strong></p><p>可以指定扫描 MyBatis 映射器接口的包名。</p><p>该注解指定扫描路径后，当Spring Boot启动时，它会自动扫描指定<br>包及其子包下的Mapper接口，并将其注册为Spring容器中的Bean；<br>添加此注解后,接口上无需再添加 @Mapper 注解。</p></li></ul><p><strong>SpringMVC 三层架构:</strong>        </p><p>三层架构: Controller Service  Dao </p><h3 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h3><ul><li><p>请求的URL地址</p><p>协议: http/https  域名中体现 <code>api</code> 字样，版本:路径中要有版本控制 <code>v1</code> ，路径:资源用名词表示；</p></li><li><p>请求的方法</p><ul><li>GET : （SELECT） 查看资源</li><li>POST：（CREATE）新增资源</li><li>PUT ：（UPDATE） 修改资源</li><li>DELETE ：（DELETE）删除资源</li></ul></li><li><p>响应状态码</p><ul><li><p>200</p></li><li><p>405</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309121322544.png" alt="image-20230912132207485"></p></li><li><p>400</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309121321951.png" alt="image-20230912132104859"></p></li><li><p>404</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309121321128.png" alt="image-20230912132126064"></p></li><li><p>500</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309191556100.png" alt="image-20230912132145197"></p></li></ul></li><li><p>RestFul限定请求方式的注解</p><p>@RequestMapping 注解 指定method</p><p>@RequestMapping 用于指定处理请求的 URL，它可以标注在类和方法上；<br>可以通过 method 参数限定处理 GET、POST、PUT、DELETE 等HTTP的请求方法，比如：<br>处理 GET 请求<br>@RequestMapping(value = “/v1/users”, method = RequestMethod.GET)<br>处理 POST 请求<br>@RequestMapping(value = “/v1/users”, method = RequestMethod.POST)<br>处理 PUT DELETE 方式的HTTP请求同理。</p><p><strong>@GetMapping 注解</strong><br>@GetMapping 只会处理 HTTP GET 请求；<br>是 @RequestMapping(method = RequestMethod.GET) 的缩写。<br>如果限定为处理GET请求，则发送其他方式请求时HTTP状态码为 405@GetMapping 只会处理 HTTP GET 请求；<br>是 @RequestMapping(method = RequestMethod.GET) 的缩写。<br>如果限定为处理GET请求，则发送其他方式请求时HTTP状态码为 405</p></li></ul><p>​        <strong>@PostMapping 注解</strong></p><p>​        <strong>@PutMapping 注解</strong>    </p><p>​        <strong>@DeleteMapping 注解</strong></p><p> <strong>@PathVariable 注解</strong></p><p>@PathVariable 注解用于接受 RESTful API 中的 URL 中的变量；</p><p>通常与请求注解一起使用，可以将 URL 中的变量映射到 Controller 中的方法参数上。<br>用法<br>假如有一个 RESTful API： /v1/users/{id} ，<br>其中 {id} 是一个变量，表示用户 ID。<br>可以这样定义一个处理该请求的控制器方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/v1/users/&#123;id&#125;&quot;)</span><br><span class="line">public String getUserById(@PathVariable Integer id) &#123;</span><br><span class="line">  // 根据 ID 查询用户，并返回用户信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例<br>根据 id 查询用户，并返回该用户信息<br>地址： /v1/users/{id} id为用户id<br>请求方法： GET<br>查询参数：无<br>响应类型：用户对象user<br>实现</p><p>根据 id 查询用户，并返回该用户信息（ GET请求：/v1/users/{id} ）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@GetMapping(&quot;/v1/users/&#123;id&#125;&quot;)</span><br><span class="line">public String getUserById(@PathVariable Integer id) &#123;</span><br><span class="line">  // 根据 ID 查询用户，并返回用户信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>JSON（JavaScript Object Notation）是一种数据交换格式，常用于不同系统间的数据传输。<br>在使用SpringMVC框架时，常常需要将Java对象转换成JSON格式，然后返回给前端。<br>JSON格式的数据通常由一对花括号 {} 括起来，在花括号中包含键值对，键值对之间使用逗号分隔。<br>比如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Tom&quot;,</span><br><span class="line">  &quot;age&quot;: 18,</span><br><span class="line">  &quot;interests&quot;: [&quot;reading&quot;, &quot;music&quot;],</span><br><span class="line">  &quot;address&quot;: &#123;</span><br><span class="line">    &quot;city&quot;: &quot;Beijing&quot;,</span><br><span class="line">    &quot;street&quot;: &quot;xxx road&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h3><p> <strong>Lombok简介</strong></p><p>Lombok 是一个 Java 库，可以通过在代码中添加注解来消除模板代码，以简化 Java 代码的编写过程；</p><p>Lombok 支持自动生成 getter、setter、toString等方法，减少了重复性的开发工作。</p><p><strong>安装和配置 Lombok</strong></p><ul><li><p>pom.xml中引入 Lombok 的依赖并刷新Maven</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入Lombok依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在Idea中确认是否安装Lombok 插件</p><ul><li><p>引入 Lombok 的依赖是让编译器能够找到 Lombok 提供的注解并对其进行处理，但是这不足以让 IDE 可以正常地识别和支持 Lombok 的注解。       </p></li><li><p>为了在 IDE 中正常地使用 Lombok，需要安装 IDE 插件来支持 Lombok 的注解。插件会将 Lombok 的注解转换为相应的代码，以便能够在 IDE 中正确地显示代码提示等功能。      </p></li><li><p>所以，为了使 Lombok 的注解在 IDE 中正常运行，需要同时引入 Lombok 的依赖并安装对应的 IDE 插件。</p></li></ul><p><font color=red><strong>如果没有安装请安装此插件</strong></font></p><ol><li><p>打开 IntelliJ IDEA，点击 File -&gt; Settings -&gt; Plugins。</p></li><li><p>在搜索框中输入 lombok，并点击搜索按钮。</p></li><li><p>选择 Lombok 插件，点击 Install 按钮进行安装。</p></li><li><p>安装完成后，弹出提示框，一般会提示重启 IntelliJ IDEA 以激活 Lombok 插件。点击 Restart IntelliJ IDEA 按钮进行重启。</p></li><li><p>重启后，即可使用 Lombok 注解。</p></li></ol></li></ul><p><strong>Lombok常用注解</strong></p><p>Lombok 提供了许多注解，每个注解用来生成特定的代码块。下面是一些常用的注解：</p><p><strong><code>@Getter</code> 和 <code>@Setter</code></strong></p><p>用来生成 getter 和 setter 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将自动生成 <code>getName()</code>, <code>setName()</code>, <code>getAge()</code>, <code>setAge()</code> 方法。</p><p><strong><code>@ToString</code></strong></p><p>用来生成 toString 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将自动生成 <code>toString()</code> 方法。</p><p><strong><code>@AllArgsConstructor</code> 和 <code>@NoArgsConstructor</code></strong></p><p>用来生成带参数的和无参的构造函数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将自动生成一个有参构造函数和一个无参构造函数。</p><p><strong><code>@Data</code></strong></p><p>是一个组合的注解，它等价于同时使用了 <code>@Getter</code>、<code>@Setter</code>、<code>@ToString</code> 注解。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这将自动生成 <code>getName()</code>, <code>setName()</code>, <code>getAge()</code>, <code>setAge()</code>以及 <code>toString()</code> 方法。</p><p><strong>@Slf4j 日志注解</strong></p><p><code>@Slf4j</code> 是 lombok 中的注解；</p><p>此注解描述类时会在类中创建一个日志对象，基于日志对象可以输出一些日志。</p><p><strong>使用方法</strong></p><p>在需要使用日志的类上加上 <code>@Slf4j</code> 注解即可。</p><ul><li><code>log.debug(&quot;日志信息&quot;)</code></li><li><code>log.info(&quot;日志信息&quot;)</code></li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;myMethod方法被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中， <code>@Slf4j</code> 注解被加在了 <code>MyClass</code> 类上。这样就可以在 <code>MyClass</code> 中直接使用 <code>log</code> 对象输出日志了。</p><p><strong>日志级别</strong></p><p><font color=red>**日志级别：TRACE&lt;DEBUG&lt;INFO&lt;WARN&lt;ERROR**</font></p><ul><li><p>TRACE</p><p>追踪级别；</p><p>用于跟踪代码执行的详细信息。通常用于调试阶段，用于输出一些详细的调试信息，对性能影响较大；</p></li><li><p>DEBUG</p><p>调试级别；</p><p>用于输出调试信息，帮助开发人员诊断问题。通常用于开发和测试阶段，例如输出方法的输入参数和返回值；</p></li><li><p>INFO（<strong>默认的级别</strong>）</p><p>普通信息级别；</p><p>用于输出程序的一般运行信息。通常用于生产环境，记录程序运行的关键信息，如系统启动、关键操作完成等；</p></li><li><p>WARN</p><p>警告级别；</p><p>用于输出警告信息。通常用于发现一些可能的问题或不正常的情况，但不会影响程序的正常运行；</p></li><li><p>ERROR</p><p>错误级别；</p><p>用于输出错误信息。通常用于记录程序的错误信息、异常信息，表示程序出现了严重的问题，无法正常运行</p></li></ul><p>注意：在 <code>@Slf4j</code> 注解中，应根据不同的应用场景和需求，可以选择适当的日志级别。</p><p>在开发和测试阶段，可以将日志级别设置为<code>DEBUG</code>，以便获取详细的调试信息。</p><p>而在生产环境中，一般将日志级别设置为<code>INFO</code>或更高级别。</p><p><strong>设置日志级别</strong></p><p><code>@Slf4j</code> 注解默认的日志级别为 INFO，即只会输出 INFO级别 以及 比INFO日志级别更高级别的日志信息，如需配置则需要在配置文件 <code>application.properties</code> 配置文件中进行配置</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置日志级别为WARN</span></span><br><span class="line"><span class="attr">logging.level.root</span>=<span class="string">WARN</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 将cn.tedu包及其包中的所有类的日志级别设置为DEBUG级别</span></span><br><span class="line"><span class="attr">logging.level.cn.tedu</span>=<span class="string">DEBUG</span></span><br></pre></td></tr></table></figure><p><strong><code>@Slf4j</code> 注解优点</strong></p><p>使用 <code>@Slf4j</code> 注解相比 <code>System.out.println(&quot;xxx&quot;)</code> 的好处</p><ul><li><p>更加高效</p><p>使用 <code>@Slf4j</code> 注解输出日志，可以避免产生大量的无用日志信息，减少对内存和磁盘等资源的消耗。</p><p>而使用 <code>System.out.println()</code> 会产生大量冗余的输出信息，不仅对调试造成困扰，而且会对应用程序的性能产生影响。</p></li><li><p>日志级别更加明确</p><p>使用 <code>@Slf4j</code> 注解，可以根据需要输出不同级别的日志，例如，警告、错误等。通过灵活控制日志输出的级别，可以及时发现并解决问题。</p><p>而使用 <code>System.out.println()</code> 输出的日志级别是不可控的，并且无法选择性地过滤日志。</p></li></ul><h3 id="Knife4j"><a href="#Knife4j" class="headerlink" title="Knife4j"></a>Knife4j</h3><p><strong>Knife4j是基于SpringBoot构建的一个文档生成工具，它可以让开发者为我们的应用生成API文档；</strong></p><p><strong>目的是可以更加方便的基于API文档进行测试。</strong></p><p>生成的文档还可以导出，然后给到前端开发团队，前端开发团队可以基于API接口写具体的调用。</p><p><strong>Knife4j的优点</strong></p><ul><li>Knife4j 功能强大，易于操作。</li><li>Knife4j 的UI界面非常美观，使用流畅。</li><li>Knife4j 可以高度定制化，让其符合你的项目需求。</li></ul><p><strong>Knife4j的使用</strong></p><p>pom.xml添加依赖</p><p>在你的SpringBoot项目的pom.xml文件中，添加如下依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加Knife4j依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-openapi2-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>配置Swagger的相关信息</strong></p><p><font color=red><strong>工程目录下创建config.Knife4jConfig</strong></font></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.PathSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2WebMvc;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2WebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Knife4jConfig</span> &#123;</span><br><span class="line">    <span class="comment">//配置Swagger2的Docket的Bean实例</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">createRestApi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                <span class="comment">// apiInfo()：配置 API 的一些基本信息，比如：文档标题title，文档描述description，文档版本号version</span></span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                <span class="comment">// select()：生成 API 文档的选择器，用于指定要生成哪些 API 文档</span></span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">// apis()：指定要生成哪个包下的 API 文档</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;cn.tedu._04weibo.controller&quot;</span>))</span><br><span class="line">                <span class="comment">// paths()：指定要生成哪个 URL 匹配模式下的 API 文档。这里使用 PathSelectors.any()，表示生成所有的 API 文档。</span></span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文档信息配置</span></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                <span class="comment">// 文档标题</span></span><br><span class="line">                .title(<span class="string">&quot;微博项目&quot;</span>)</span><br><span class="line">                <span class="comment">// 文档描述信息</span></span><br><span class="line">                .description(<span class="string">&quot;微博项目在线API文档&quot;</span>)</span><br><span class="line">                <span class="comment">// 文档版本号</span></span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查看生成的接口文档</strong></p><p>在 SpringBoot 项目启动后，访问 <code>http://localhost:8080/doc.html</code> 地址即可查看生成的Knife4j接口文档。</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309111112057.png" alt="image-20230911111221011"></p><p><strong>常用注解应用分析</strong></p><ul><li><p><strong>@Api注解</strong></p><p>添加在控制器类上的注解；</p><p>通过此注解的tags属性可以修改原本显示控制器类名称的位置的文本；</p><p>通常建议在配置的tags属性值上添加序号，例如：“01. 用户模块”、“02. 微博模块”，则框架会根据值进行排序。</p><ul><li><p>参数说明</p><ul><li>tags：配置模块名称</li></ul></li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. UserController</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;01.用户管理模块&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. WeiboController</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;02.微博管理模块&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeiboController</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. CommentController</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;03.评论管理模块&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommentController</span> &#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>文档效果（<strong>重启工程并刷新页面：<a href="http://localhost:8080/doc.html#/home">http://localhost:8080/doc.html#/home</a></strong>）</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309111119803.png" alt="image-20230911111943757"></p></li></ul></li><li><p><strong>@ApiOperation注解</strong></p><p>添加在控制器类中处理请求的方法上的注解；</p><p>用于配置此方法处理的请求在API文档中显示的文本。</p><ul><li><p>参数说明</p><ul><li>value：配置业务名称</li></ul></li><li><p>代码示例</p><p><strong>此处以注册功能为例，其他所有方法请添加说明</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**注册功能*/</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;reg&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;注册功能&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reg</span><span class="params">(<span class="meta">@RequestBody</span> UserRegDTO userRegDTO)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>文档效果（<strong>重启工程并刷新页面：<a href="http://localhost:8080/doc.html#/home">http://localhost:8080/doc.html#/home</a></strong>）</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309111119091.png" alt="image-20230911111951036"></p></li></ul></li><li><p><strong>@ApiModelProperty注解</strong></p><p>是添加在POJO类的属性上的注解；</p><p>用于对请求参数或响应结果中的某个属性进行说明；</p><p>主要通过其value属性配置描述文本，并可通过example属性配置示例值。</p><ul><li><p>参数说明</p><ul><li>value属性：配置参数名称</li><li>required属性：配置是否必须提交此请求参数</li><li>example属性：配置示例值</li></ul><p><font color=red>注意：如果配置了 required=true,只是一种显示效果，Knife4j框架并不具备检查功能</font></p></li><li><p>代码示例</p><p><strong>以注册功能UserRegDTO为例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegDTO</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;用户名&quot;, required = true, example = &quot;赵丽颖&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;密码&quot;, required = true)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;昵称&quot;, required = true)</span></span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>文档效果（<strong>重启工程并刷新页面：<a href="http://localhost:8080/doc.html#/home">http://localhost:8080/doc.html#/home</a></strong>）</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309111124979.png" alt="image-20230911112427914"></p></li></ul></li><li><p><strong>@ApiImplicitParam注解</strong></p><p><strong>添加在控制器类中处理请求的方法上的注解；</strong></p><p>主要用于配置非封装的参数</p><ul><li><p>参数说明</p><ul><li>name：指定参数名称（<strong>参数变量名</strong>）</li><li>value：配置参数名称</li><li>dataType：配置数据类型</li><li>required：配置是否必须提交此请求参数</li><li>example：配置参数的示例值</li></ul><p><font color=red>注意：一旦使用此注解，各个参数的数据类型默认都会显示String，可以通过dataType指定数据类型</font></p></li><li><p>代码示例</p><p><strong>此处以微博详情功能为例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiImplicitParam(name = &quot;id&quot;, value = &quot;微博&quot;, required=true, dataType = &quot;int&quot;)</span></span><br><span class="line"><span class="keyword">public</span> WeiboDetailVO <span class="title function_">selectById</span><span class="params">(<span class="type">int</span> id)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>文档效果（<strong>重启工程并刷新页面：<a href="http://localhost:8080/doc.html#/home">http://localhost:8080/doc.html#/home</a></strong>）</p><p><img src="C:\Users\foo\Desktop\JavaProject\jsd2306-ssm-teacher\笔记\07Knife4j笔记\images\image-20230513234756279.png" alt="image-20230513234756279"></p></li></ul></li><li><p><strong>@ApiImplicitParams注解</strong></p><p>添加在控制器类中处理请求的方法上的注解；</p><p>当方法有多个非封装的参数时，在方法上添加此注解，并在注解内部通过@ApiImplicitParam数组配置多个参数。</p><ul><li><p>代码示例</p><p><strong>此处以微博详情功能为例</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**微博详情页功能*/</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;selectById&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(value = &quot;微博详情功能&quot;)</span></span><br><span class="line"><span class="meta">@ApiImplicitParams(value = &#123;</span></span><br><span class="line"><span class="meta">    @ApiImplicitParam(name = &quot;id&quot;, value = &quot;微博&quot;, required=true, dataType = &quot;int&quot;),</span></span><br><span class="line"><span class="meta">    @ApiImplicitParam(name = &quot;username&quot;, value = &quot;用户名&quot;, required=true)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="comment">// 额外增加username参数，仅仅用于测试</span></span><br><span class="line"><span class="keyword">public</span> WeiboDetailVO <span class="title function_">selectById</span><span class="params">(<span class="type">int</span> id, String username)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> weiboMapper.selectById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>文档效果（<strong>重启工程并刷新页面：<a href="http://localhost:8080/doc.html#/home">http://localhost:8080/doc.html#/home</a></strong>）</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309111126670.png" alt="image-20230911112600614"></p></li></ul></li></ul><ul><li><p><strong>@ApiIgnore注解</strong></p><p>添加在处理请求的方法的参数上；</p><p>用于表示API文档框架应该忽略此参数。</p><p><strong>以发布微博功能的HttpSession参数为例</strong></p><ul><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数中添加@ApiIgnore注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insert</span><span class="params">(<span class="meta">@RequestBody</span> WeiboDTO weiboDTO, <span class="meta">@ApiIgnore</span> HttpSession session)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>文档效果（<strong>重启工程并刷新页面：<a href="http://localhost:8080/doc.html#/home">http://localhost:8080/doc.html#/home</a></strong>）</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309111126586.png" alt="image-20230911112619523"></p></li></ul></li></ul><p><strong>限制请求方式</strong></p><p>API文档中默认每个功能会展示7种请求方式，遵循RESTful规则将 <code>@RequestMapping</code> 注解修改为对应请求方法的注解，比如：<code>@GetMapping  @PostMapping  @PutMapping  @DeleteMapping</code> 注解，重启工程后刷新测试。</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309111128751.png" alt="image-20230911112803693"></p><p><strong>导出离线</strong>API文档</p><ol><li><p>文档管理 - 离线文档 中存在多种格式的导出格式</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309111127017.png" alt="image-20230911112748941"></p></li><li><p>选择合适的文档格式，导出即可到本地磁盘</p></li></ol><h3 id="JsonResult"><a href="#JsonResult" class="headerlink" title="JsonResult"></a>JsonResult</h3><p><strong>统一响应结果的处理</strong></p><p><strong>为什么需要统一响应结果处理</strong></p><p>在实际开发中，我们往往需要在多个控制器方法中返回相同的响应结构；</p><p>例如，统一返回接口调用成功的状态码、提示信息、以及请求结果数据。但是，如果对于每个接口都单独进行处理的话，不仅逻辑复杂，而且容易出现疏漏，进而增加前端调用的难度。</p><p>所以为了更好定义服务端返回值的格式，统一客户端对服务端响应结果的处理，我们需要将服务端返回到客户端的数据再次进行封装。</p><ul><li>响应状态码 <code>code</code></li><li>提示信息 <code>msg</code></li><li>响应数据 <code>data</code></li></ul><p><strong>统一状态码设计</strong></p><p>当项目中的状态码越来越多时，对状态码的定义如果没有统一规划，后续对状态的理解就会相当的困难，而且容易导致操作上的失败。</p><p><strong>状态码设计</strong></p><table><thead><tr><th align="center">自定义状态码</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">1000</td><td align="center">未登录</td></tr><tr><td align="center">1001</td><td align="center">登录成功</td></tr><tr><td align="center">1002</td><td align="center">密码错误</td></tr><tr><td align="center">1003</td><td align="center">用户名错误</td></tr><tr><td align="center">1004</td><td align="center">用户名被占用</td></tr><tr><td align="center">2001</td><td align="center">操作成功</td></tr><tr><td align="center">2002</td><td align="center">操作失败</td></tr></tbody></table><p><strong>自定义状态吗</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.Getter;</span><br><span class="line">import lombok.NoArgsConstructor;</span><br><span class="line">@Getter</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public enum StatusCode &#123;</span><br><span class="line">  SUCCESS(1, &quot;OK&quot;),</span><br><span class="line">  NOT_LOGIN(1000, &quot;未登录&quot;),</span><br><span class="line">  LOGIN_SUCCESS(1001, &quot;登录成功&quot;),</span><br><span class="line">  PASSWORD_ERROR(1002, &quot;密码错误&quot;),</span><br><span class="line">  USERNAME_ERROR(1003, &quot;用户名错误&quot;),</span><br><span class="line">  USERNAME_ALREADY_EXISTS(1004, &quot;用户名被占用&quot;),</span><br><span class="line">  OPERATION_SUCCESS(2001, &quot;操作成功&quot;),</span><br><span class="line">  OPERATION_FAILED(2002, &quot;操作失败&quot;);</span><br><span class="line">  //状态码、状态码描述</span><br><span class="line">  private Integer code;</span><br><span class="line">  private String msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>统一响应结果处理的代码实现</strong></p><p><code>JsonResult</code>类的创建</p><p>首先，在工程目录中创建一个新的类<code>common.response.JsonResult</code>；该类作为统一的响应结果类；</p><p>其包含了响应结果的状态码（code）、提示信息（msg）和请求结果数据（data）三个属性：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonResult</span> &#123;</span><br><span class="line">    <span class="comment">/**响应状态码(业务状态码)*/</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="comment">/**状态码的含义(比如:用户名被占用...)*/</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="comment">/**服务端返回给客户端的具体数据(可能是VO对象,也可能是List集合...)*/</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**构造方法1:适用于不需要返回具体数据的Controller方法*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JsonResult</span><span class="params">(Integer code, String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**构造方法2:适用于不需要返回具体数据的Controller方法,使用自定义枚举类StatusCode*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JsonResult</span><span class="params">(StatusCode statusCode)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.code = statusCode.getCode();</span><br><span class="line">        <span class="built_in">this</span>.msg = statusCode.getMsg();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**构造方法3:适用于需要返回具体数据的Controller方法,使用自定义枚举类StatusCode*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JsonResult</span><span class="params">(StatusCode statusCode, Object data)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.code = statusCode.getCode();</span><br><span class="line">        <span class="built_in">this</span>.msg = statusCode.getMsg();</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**构造方法4:用于快速构建JsonResult对象,初始化3个属性:code msg data*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JsonResult</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.code = StatusCode.SUCCESS.getCode();</span><br><span class="line">        <span class="built_in">this</span>.msg = StatusCode.SUCCESS.getMsg();</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**2个静态方法,用于快速创建JsonResult对象</span></span><br><span class="line"><span class="comment">     * 一种是有返回数据data的;</span></span><br><span class="line"><span class="comment">     * 一种是无返回数据data的;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JsonResult <span class="title function_">ok</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> JsonResult <span class="title function_">ok</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ok(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>controller</code>代码重构</strong></p><p>以 <code>UserController</code> 中的 <strong>注册功能</strong> 为例</p><p>对 <code>Controller</code>中的代码进行重构，将结果封装成 <code>JsonResult</code> 类型的结果，并返回给客户端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;注册功能&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;reg&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JsonResult <span class="title function_">reg</span><span class="params">(<span class="meta">@RequestBody</span> UserRegDTO userRegDTO)</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.确认用户名是否被占用</span></span><br><span class="line"><span class="comment">     * 2.注册用户</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    log.debug(<span class="string">&quot;userRegDTO = &quot;</span> + userRegDTO);</span><br><span class="line">    <span class="type">UserVO</span> <span class="variable">userVO</span> <span class="operator">=</span> userMapper.selectByUsername(userRegDTO.getUsername());</span><br><span class="line">    <span class="keyword">if</span> (userVO != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(<span class="number">1004</span>, <span class="string">&quot;用户名被占用&quot;</span>); <span class="comment">// 用户名被占用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    BeanUtils.copyProperties(userRegDTO, user);</span><br><span class="line">    user.setCreated(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    userMapper.insert(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(<span class="number">1001</span>, <span class="string">&quot;操作成功&quot;</span>); <span class="comment">// 注册成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>Knife4j</code> 进行测试</strong></p><p>重启工程后，使用 <code>Knife4j</code> 进行测试</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309111130751.png" alt="image-20230530152603608"></p><p><strong>自定义枚举状态码</strong>(StatusCode)</p><p>1 简介</p><p>在Spring MVC中，一般通过HTTP响应状态码来表示请求是否成功。但是HTTP状态码的语义有时候比较笼统，不能够很好地表达业务逻辑。</p><p>为了解决这一问题，我们可以定义自己的状态码，将它们作为HTTP响应状态码的补充，以更加精准地表示请求的处理结果。</p><p>通常我们使用枚举类来定义自定义状态码，并且将它们应用到Spring MVC的实践中。</p><p>2 自定义枚举状态码</p><p>工程目录下创建 <code>common.response.StatusCode</code> 来自定义枚举状态码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">StatusCode</span> &#123;</span><br><span class="line">    <span class="comment">/**所有的实例都在最上面*/</span></span><br><span class="line">    SUCCESS(<span class="number">1</span>, <span class="string">&quot;OK&quot;</span>),</span><br><span class="line">    NOT_LOGIN(<span class="number">1000</span>,<span class="string">&quot;未登录&quot;</span>),</span><br><span class="line">    LOGIN_SUCCESS(<span class="number">1001</span>,<span class="string">&quot;登录成功&quot;</span>),</span><br><span class="line">    PASSWORD_ERROR(<span class="number">1002</span>, <span class="string">&quot;密码错误&quot;</span>),</span><br><span class="line">    USERNAME_ERROR(<span class="number">1003</span>, <span class="string">&quot;用户名错误&quot;</span>),</span><br><span class="line">    USERNAME_ALREADY_EXISTS(<span class="number">1004</span>, <span class="string">&quot;用户名已存在&quot;</span>),</span><br><span class="line">    OPERATION_SUCCESS(<span class="number">2001</span>, <span class="string">&quot;操作成功&quot;</span>),</span><br><span class="line">    OPERATION_FAILED(<span class="number">2002</span>, <span class="string">&quot;操作失败&quot;</span>),</span><br><span class="line">    VALIDATE_ERROR(<span class="number">3002</span>, <span class="string">&quot;参数校验失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 使用自定义枚举状态码</p><p>3.1 <code>JsonResult</code> 构造方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">JsonResult</span><span class="params">(StatusCode statusCode)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.code = statusCode.getCode();</span><br><span class="line">    <span class="built_in">this</span>.msg = statusCode.getmsg();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">JsonResult</span><span class="params">(StatusCode statusCode, Object data)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.code = statusCode.getCode();</span><br><span class="line">    <span class="built_in">this</span>.msg = statusCode.getmsg();</span><br><span class="line">    <span class="built_in">this</span>.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.2 <code>controller</code> 代码重构</p><p><strong>注册功能</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用户名被占用</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(StatusCode.USERNAME_ALREADY_EXISTS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册成功</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(StatusCode.OPERATION_SUCCESS);</span><br></pre></td></tr></table></figure><p><strong>登录功能</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用户名错误</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(StatusCode.USERNAME_ERROR);</span><br><span class="line"></span><br><span class="line"><span class="comment">//登录成功</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(StatusCode.LOGIN_SUCCESS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//密码错误</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(StatusCode.PASSWORD_ERROR);</span><br></pre></td></tr></table></figure><h3 id="BeanUtils"><a href="#BeanUtils" class="headerlink" title="BeanUtils"></a><strong>BeanUtils</strong></h3><p><strong>简化数据封,用于封装JavaBean的</strong></p><p> <strong>JavaBean</strong>：标准的Java类</p><p><strong>要求</strong>：</p><blockquote><ol><li><p>类必须被public修饰</p></li><li><p>必须提供空参的构造器</p></li><li><p>成员变量必须使用private修饰</p></li><li><p>提供公共setter和getter方法</p></li></ol></blockquote><p><strong>功能</strong>：封装数据</p><ol><li><p>概念：</p><p>成员变量：</p><p>属性：setter和getter方法截取后的产物</p><p>例如：getUsername() –&gt; Username–&gt; username</p></li><li><p>方法：</p><ol><li><p>setProperty()(了解)(操作的是属性值,不是成员变量)</p></li><li><p>getProperty()(了解)</p></li><li><p>populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中(掌握)</p><p>属性值和成员变量的区别:</p><p>getter和setter去掉get和set后面的为属性,一般属性和成员变量设置为一样.</p></li></ol></li></ol><h3 id="MVCException"><a href="#MVCException" class="headerlink" title="MVCException"></a>MVCException</h3><p>Spring MVC中异常处理</p><p><strong>全局异常处理</strong></p><p>什么是全局异常处理器</p><p>全局异常处理器是Spring MVC框架中的一种异常处理机制，用于统一 <strong>处理由控制器抛出的异常</strong>。</p><p>全局异常处理器可以帮助我们捕获和处理控制器中的异常，并且可以根据不同的异常类型进行不同的处理操作，从而保障应用的健壮性和稳定性。</p><p>当然，Spring MVC中有内置的异常处理对象，但是呈现的结果对于用户端不友好，所以实际项目我们一般会使用全局异常处理器处理异常。</p><p><strong>全局异常处理器的配置</strong></p><p>Spring MVC中的全局异常处理器可以通过以下方式进行配置：</p><ol><li><p>创建 <code>exception.GlobalExceptionHandler</code>类，并添加异常处理方法；</p><p>使用 <code>@ControllerAdvice</code> 注解 或者 <code>@RestControllerAdvice</code> 注解标注该类；</p></li><li><p>在异常处理方法上添加 <code>@ExceptionHandler</code> 注解，用于指定控制器中需要处理的异常类型。</p></li></ol><p> <strong>使用流程</strong></p><p><strong>创建全局异常处理器类</strong></p><p>工程目录下创建 <code>exception.GlobalExceptionHandler</code></p><ul><li><p><code>@ControllerAdvice</code> 注解</p><p>定义全局异常处理器，处理Controller中抛出的异常。</p></li><li><p><code>@RestControllerAdvice</code> 注解</p><p>复合注解，是<code>@ControllerAdvice</code>注解和<code>@ResponseBody</code>注解的组合；</p><p>用于捕获Controller中抛出的异常并对异常进行统一的处理，还可以对返回的数据进行处理。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import cn.tedu.baking.commons.response.JsonResult;</span><br><span class="line">import cn.tedu.baking.commons.response.StatusCode;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.web.bind.MethodArgumentNotValidException;</span><br><span class="line">import org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line">import org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * ControllerAdvice注解: 标识当前的类为全局异常处理器类型;可以处理由控制器抛出的异常</span><br><span class="line"> *   1.如果Controller中抛出了异常,首先看是否定义了全局异常处理器;</span><br><span class="line"> *   2.如果定义了会在全局异常处理器中找对应的异常处理方法;</span><br><span class="line"> *   3.如果找到了对应的异常处理方法,则执行异常处理方法中的代码逻辑.</span><br><span class="line"> *</span><br><span class="line"> * RestControllerAdvice注解: 复合注解,相当于 @ResponseBody + @ControllerAdvise注解</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">//@ControllerAdvice</span><br><span class="line">@RestControllerAdvice</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    //捕获业务层异常</span><br><span class="line">    @ExceptionHandler</span><br><span class="line">    public JsonResult doHandleServiceException(ServiceException ex)&#123;</span><br><span class="line">        log.error(ex.getStatusCode().getMsg());</span><br><span class="line">        return new JsonResult(ex.getStatusCode());</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">      ExceptionHandler注解:表示方法为具体的异常处理方法;需要一个异常处理类型的形式参数;</span><br><span class="line">      1.优先查找该控制器异常对应的异常处理方法;</span><br><span class="line">      2.如果没有对应的异常处理方法,则会找父类的异常处理方法;(IllegalArgumentException  =&gt; RuntimeException)</span><br><span class="line">      3.如果没有父类的异常处理方法,则会走SpringMVC自己的异常处理机制;</span><br><span class="line">     */</span><br><span class="line">    @ExceptionHandler</span><br><span class="line">    public JsonResult doHandleRuntimeException(RuntimeException ex)&#123;</span><br><span class="line">        /*</span><br><span class="line">            &#123;&quot;code&quot;: 3001, &quot;msg&quot;: &quot;请求参数异常&quot;, &quot;data&quot;: &quot;微博ID值无效&quot;&#125;</span><br><span class="line">         */</span><br><span class="line">        log.error(&quot;RuntimeException is: &quot; + ex.getMessage());</span><br><span class="line">        return new JsonResult(StatusCode.VALIDATE_ERROR, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler</span><br><span class="line">    public JsonResult doHandleIllegalArgumentException(IllegalArgumentException ex)&#123;</span><br><span class="line">        log.error(&quot;IllegalArgumentException is: &quot; + ex.getMessage());</span><br><span class="line">        return new JsonResult(StatusCode.VALIDATE_ERROR, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 处理由 Spring Validation 框架抛出的异常</span><br><span class="line">     * @param ex 异常处理对象</span><br><span class="line">     * @return JsonResult</span><br><span class="line">     */</span><br><span class="line">    @ExceptionHandler</span><br><span class="line">    public JsonResult doHandleMethodArgumentNotValidException(MethodArgumentNotValidException ex)&#123;</span><br><span class="line">        /**</span><br><span class="line">         * Validation框架获取提示消息:ex.getFieldError().getDefaultMessage()</span><br><span class="line">         */</span><br><span class="line">        String message = ex.getFieldError().getDefaultMessage();</span><br><span class="line">        return new JsonResult(StatusCode.VALIDATE_ERROR, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Throwable:处理所有的异常;</span><br><span class="line">     *           其他异常处理方法无法处理的异常,都会交由此方法进行处理</span><br><span class="line">     *           一般会在最后,加上此异常处理方法;</span><br><span class="line">     *           一旦加完此方法,控制器中再也没有500状态码.</span><br><span class="line">     * @param ex 异常处理对象</span><br><span class="line">     * @return JsonResult</span><br><span class="line">     */</span><br><span class="line">    /*@ExceptionHandler</span><br><span class="line">    public JsonResult doHandleThrowableException(Throwable ex)&#123;</span><br><span class="line">        return new JsonResult(8888, &quot;Throwable异常!&quot;);</span><br><span class="line">    &#125;*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service层异常</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import cn.tedu.baking.commons.response.StatusCode;</span><br><span class="line">import lombok.Getter;</span><br><span class="line"></span><br><span class="line">public class ServiceException extends RuntimeException&#123;</span><br><span class="line">    @Getter</span><br><span class="line">    private StatusCode statusCode;</span><br><span class="line"></span><br><span class="line">    public ServiceException(StatusCode statusCode) &#123;</span><br><span class="line">        this.statusCode = statusCode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>创建异常处理方法</strong></p><p>在异常处理方法上添加 <code>@ExceptionHandler</code> 注解</p><ul><li><p><code>@ExceptionHandler</code> 注解</p><p>用于捕获Controller处理请求时抛出的异常，并进行统一的处理。</p></li><li><p>示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> ex.getMessage()方法：用于捕获异常信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span></span><br><span class="line"><span class="keyword">public</span> JsonResult <span class="title function_">doHandleRuntimeException</span><span class="params">(RuntimeException ex)</span>&#123;</span><br><span class="line">    log.error(<span class="string">&quot;error is &quot;</span> + ex.getMessage());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(StatusCode.OPERATION_FAILED,ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>全局异常处理器示例</strong></p><p>微博详情页异常抛出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> JsonResult <span class="title function_">selectById</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;id值无效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>全局异常处理</strong></p><p><code>exception.GlobalExceptionHandler</code> 类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.weibo.exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.tedu.weibo.common.response.JsonResult;</span><br><span class="line"><span class="keyword">import</span> cn.tedu.weibo.common.response.StatusCode;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RestControllerAdvice 是复合注解，描述的类型为一个全局异常处理对象类型,</span></span><br><span class="line"><span class="comment"> * 等价于：<span class="doctag">@ControllerAdvice</span>+<span class="doctag">@ResponseBody</span></span></span><br><span class="line"><span class="comment"> * 当某个Controller方法中出现了异常，系统底层就会查找有没有定义全局异常处理对象。</span></span><br><span class="line"><span class="comment"> * 这个全局异常处理对象中有没有定义对应的异常处理方法，假如有就调用此方法处理异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@ExceptionHandler</span> 描述的方法为一个异常处理方法，在此注解内部可以定义具体的异常处理</span></span><br><span class="line"><span class="comment">     *  类型(例如RuntimeException),此注解描述的方法需要定义一个异常类型的形式参数，</span></span><br><span class="line"><span class="comment">     *  通过这个参数接收具体的异常对象(也可以接收其异常类型对应的子类类型的异常)。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> JsonResult <span class="title function_">doHandleRuntimeException</span><span class="params">(RuntimeException ex)</span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;error is &quot;</span> + ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(StatusCode.OPERATION_FAILED,ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 假如用全局异常处理对象处理Controller类中出现的异常，全局异常处理对象会优先查找与Controller</span></span><br><span class="line"><span class="comment">     * 中相匹配的异常处理方法，假如没有，会查找对应异常的父类异常处理方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> JsonResult <span class="title function_">doHandleRuntimeException</span><span class="params">(IllegalArgumentException ex)</span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;IllegalArgumentException is &quot;</span> + ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(StatusCode.OPERATION_FAILED,ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关于Throwable</strong> </p><p>在开发实践中，通常会添加一个处理<code>Throwable</code>的方法，它将可以处理所有类型的异常，则不会再出现<code>500</code>错误！</p><p><code>GlobalExceptionHandler</code>中添加处理 Throwable 的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span></span><br><span class="line"><span class="keyword">public</span> JsonResult <span class="title function_">handleThrowable</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(<span class="number">8888</span>, <span class="string">&quot;程序运行过程中出现了Throwable&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-Validation"><a href="#Spring-Validation" class="headerlink" title="Spring Validation"></a>Spring Validation</h3><p><strong>关于Spring Validation</strong></p><p>在实际项目我们需要对客户端传递到服务端的参数进行校验，用于判定请求参数的合法性，假如请求参数不合法则不可以再去执行后续的业务了。那如何校验呢？</p><p>一种方式是我们在控制层方法中每次都自己进行参数有效值的判断，不合法可以抛出异常，但是工作量和代码复杂度会比较高；</p><p>第二种方式就是采用市场上主流的 <code>Spring Validation</code> 框架去实现校验，所以 <code>Spring Validation</code> 框架的主要作用是  检查参数的基本有效性。</p><p><strong>使用流程</strong></p><p>在Spring Boot工程中，使用此框架需要添加依赖，并刷新maven</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Boot支持Spring Validation的依赖项，用于检查参数的基本有效性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>快速入门</strong></p><ol><li><p>在处理请求的方法的参数列表中，在POJO类型的参数上添加<code>@Validated</code>注解，表示需要通过Spring Validation框架检查此参数，例如UserController中注册功能：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;注册功能&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;reg&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JsonResult <span class="title function_">reg</span><span class="params">(<span class="meta">@RequestBody</span> <span class="meta">@Validated</span> UserRegDTO userRegDTO)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>在此POJO类中的属性上，添加对应的检查注解，以配置检查规则，</p><p>例如，添加<code>@NotNull</code>注解，就表示“不允许为<code>null</code>”的规则！</p><p>在<code>UserRegDTO</code>类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegDTO</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;用户名&quot;, required = true, example = &quot;赵丽颖&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;密码&quot;, required = true, example = &quot;123456&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;昵称&quot;, required = true, example = &quot;萤火虫&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重启工程，在Knife4j中测试，当提交请求时，如果username参数为 <code>null</code>，服务器端将响应<code>400</code>错误。</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309151711453.png" alt="image-20230915171114351"></p><p><strong>同时在终端也会出现异常</strong></p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309151711575.png" alt="image-20230915171130474"></p></li></ol><p><strong>运行异常处理</strong></p><p><strong>说明</strong></p><p>在使用Spring Validation框架执行参数的检查时，如果检查不通过，除了响应<code>400</code>错误以外，在控制台还会抛出错误：<font color=red><code>MethodArgumentNotValidException</code> 使用全局异常处理器解决。</font></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[org.springframework.web.bind.MethodArgumentNotValidException: Validation failed <span class="keyword">for</span> argument [<span class="number">0</span>] in <span class="keyword">public</span> cn.tedu._043mvcweibo.common.response.JsonResult cn.tedu._043mvcweibo.controller.UserController.reg(cn.tedu._043mvcweibo.pojo.dto.UserRegDTO): [Field error in object <span class="string">&#x27;userRegDTO&#x27;</span> on field <span class="string">&#x27;username&#x27;</span>: rejected value [<span class="literal">null</span>]; codes [NotNull.userRegDTO.username,NotNull.username,NotNull.java.lang.String,NotNull]; arguments [org.springframework.context.support.DefaultMessageSourceResolvable: codes [userRegDTO.username,username]; arguments []; <span class="keyword">default</span> message [username]]; <span class="keyword">default</span> message [不能为<span class="literal">null</span>]] ]</span><br></pre></td></tr></table></figure><p><strong>处理异常</strong></p><p><strong>使用全局异常处理器来处理 <code>MethodArgumentNotValidException</code> 异常</strong></p><p>第1步：全局异常处理器 <code>GlobalExceptionHandler</code> 中定义处理异常方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span></span><br><span class="line"><span class="keyword">public</span> JsonResult <span class="title function_">doHandleMethodArgumentNotValidException</span><span class="params">(MethodArgumentNotValidException ex)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(<span class="number">3002</span>, <span class="string">&quot;请求参数错误&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第2步：重启工程，在Knife4j中测试</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309151713381.png" alt="image-20230915171339310"></p><p><strong>明确提示消息</strong></p><p>当提交的<code>username</code>的值为 null 时，可以发现异常已被处理！</p><p>但是，处理结果并不合适，因为，客户端得到此结果后，仍无法明确出现了什么错误！</p><p>所有的检查注解都可以配置<code>message</code>参数，用于对错误进行描述。</p><p>第1步：<code>@NotNull</code> 注解中添加 <code>message</code> 参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotNull(message = &quot;必须提交用户名&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br></pre></td></tr></table></figure><p>第2步：自定义枚举状态码 <code>StatusCode</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">VALIDATE_ERROR(<span class="number">3002</span>, <span class="string">&quot;参数校验失败&quot;</span>)</span><br></pre></td></tr></table></figure><p>第3步：异常方法中获取提示信息 <code>message</code></p><p>在处理异常时，需要调用<code>MethodArgumentNotValidException</code>对象的<code>getFieldError().getDefaultMessage()</code>获取以上配置的描述文本</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span></span><br><span class="line"><span class="keyword">public</span> JsonResult <span class="title function_">handleBindException</span><span class="params">(MethodArgumentNotValidException ex)</span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       ex.getFieldError().getDefaultMessage():获取 @NotNull(message=&quot;xxx&quot;) 中message的消息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> ex.getFieldError().getDefaultMessage();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(StatusCode.VALIDATE_ERROR, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第3步：重启工程，在Knife4j中测试</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309151714054.png" alt="image-20230915171453978"></p><p><strong>常用注解</strong></p><p><strong><code>@NotNull</code>注解</strong></p><ul><li><p>作用：用于验证对象是否为 null</p></li><li><p>用法：<code>@NotNull</code> 注解用于对象类型上</p></li><li><p>示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotNull(message = &quot;用户名不能为null&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br></pre></td></tr></table></figure></li><li><p><em><code>@NotEmpty</code> 注解</em>*</p></li><li><p>作用：用于验证字符串是否为空，并且会检查是否为 null 值（为null值时报错）</p></li><li><p>用法：用于字符串类型上</p></li><li><p>示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotEmpty(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br></pre></td></tr></table></figure></li></ul><p><strong><code>@NotBlank</code> 注解</strong></p><ul><li><p>作用：不允许为空白，即不允许是“仅由空格、TAB等空白值组成的字符串”，也不允许为空字符串，也不允许为空值null</p></li><li><p>用法：用于字符串类型上</p></li><li><p>示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotBlank(message = &quot;用户名不能为空白串&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br></pre></td></tr></table></figure></li></ul><p><strong><code>@Size</code> 注解</strong></p><ul><li><p>作用：可以指定最小值和最大值限制字符串的长度</p></li><li><p>用法：用于字符串类型参数</p></li><li><p>示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Size(min = 6, max = 20, message = &quot;用户名长度必须在6到20之间&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br></pre></td></tr></table></figure></li></ul><p><strong><code>@Range</code> 注解</strong></p><ul><li><p>作用：用于验证数字类型字段的取值范围，通过配置min和max属性来限制数值类型参数的值区间包括最小值和最大值</p></li><li><p>用法：用于数值类型参数</p></li><li><p>示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Range(min = 1, max = 10, message = &quot;年龄必须在1-10岁之间&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Range(min = 0.1, max = 1.0, message = &quot;成绩必须在0.1到1.0之间&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> score;</span><br></pre></td></tr></table></figure></li></ul><p><strong>非POJO参数校验</strong></p><p>在 Spring Validation 中，除了对 POJO（Plain Old Java Object）进行校验的功能外，还支持对非 POJO 进行校验，比如 String、Integer、Double 等类型的参数。</p><p><strong>使用流程</strong></p><ul><li><font color=red><strong>在当前方法所在的类上添加 <code>@Validated</code> 注解</strong></font></li><li>在参数上添加对应的检查注解</li></ul><p><strong>使用示例</strong></p><p>对于微博详情页的 id 参数进行范围校验，范围只能在1-10之间</p><p>第1步：在类 <code>WeiboController</code> 中添加 <code>@Validated</code> 注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeiboController</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>第2步：在控制器方法参数 <code>id</code> 上添加对应的检查注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> JsonResult <span class="title function_">selectById</span><span class="params">(<span class="meta">@Range(min = 1, max=10, message = &quot;请提交合法的ID值！&quot;)</span> <span class="meta">@RequestParam</span> <span class="type">int</span> id, String username)</span></span><br></pre></td></tr></table></figure><p>第3步：重启工程，在Knife4j或者浏览器中测试</p><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h3><p>继承和聚合</p><p>父工程包含多个子工程  父工程打包方式为pom 子工程为jar</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309161441058.png" alt="image-20230916144155959"></p><p>项目开发通常是分组分模块开发,最终打包成一个独立的Jar包运行</p><p><strong>Maven私服:nexus</strong></p><p>公司在自己的局域网内搭建自己的远程仓库服务器，称为私服，私服服务器即是公司内<br>部的 maven 远程仓库，每个员工的电脑上安装 maven 软件并且连接私服服务器，员工将自<br>己开发的项目打成 jar 并发布到私服服务器，其它项目组从私服服务器下载所依赖的构件<br>（jar）。<br>私服还充当一个代理服务器，当私服上没有 jar 包会从互联网中央仓库自动下载，如下<br>图：</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309161511274.png" alt="image-20230916151150229"></p><p><strong>搭建私服:</strong></p><p>访问地址:<a href="http://localhost:8081/nexus/">http://localhost:8081/nexus/</a></p><p>使用 Nexus 内置账户admin/admin123 登陆：</p><p><img src="https://cdn.jsdelivr.net/gh/waFroppy/BlogImages@main/img202309161540342.png" alt="image-20230916154001253"></p><p>把项目发布到私服</p><p>从私服下载jar包</p><h3 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a><strong>SpringCloud</strong></h3><p>Spring Cloud是一个用于构建分布式系统的开源框架，它基于Spring框架，提供了一系列的工具和组件，以简化分布式系统开发的复杂性。它提供了诸如服务注册与发现、客户端负载均衡、声明式服务调用、容错处理、API网关、配置管理等功能</p><p>2.1 Eureka</p><ul><li>服务注册与发现组件，用于实现微服务架构中的服务发现。</li><li>可以将所有微服务的实例注册到Eureka Server上，从而实现服务的自动发现。</li><li>通过Eureka可以轻松实现服务的高可用性，当服务实例发生故障时，能够自动剔除不可用实例。</li></ul><p>2.2 Ribbon</p><ul><li>客户端负载均衡组件，用于实现微服务架构中的客户端负载均衡。</li><li>可以实现根据一定的策略从一组实例中选择一个可用的服务进行调用。</li></ul><p>2.3 Feign</p><ul><li>声明式服务调用组件，用于实现微服务架构中的服务间通讯。</li><li>可以通过简单的注解方式来定义服务接口，Feign会自动处理服务的调用细节，开发者只需要关注业务逻辑。</li></ul><p>2.4 Hystrix</p><ul><li>容错管理组件，用于实现微服务架构中的容错处理。</li><li>可以实现服务降级、熔断、限流等功能，提高系统的可靠性和稳定性。</li></ul><p>2.5 Zuul</p><ul><li>API网关组件，用于实现微服务架构中的统一访问入口。</li><li>可以实现路由转发、请求过滤、服务聚合等功能，简化了客户端和服务端的通讯。</li></ul><p>2.6 Config</p><ul><li>配置管理组件，用于实现微服务架构中的配置中心。</li><li>可以集中管理配置文件，并可以实现配置的动态刷新。</li></ul><p><strong>Spring Cloud示例项目</strong></p><p>3.1 创建一个新的Spring Boot项目</p><ul><li>使用Spring Initializr创建一个新的Spring Boot项目，选择所需的组件和依赖。</li></ul><p>3.2 引入Spring Cloud相关依赖</p><ul><li>在项目的pom.xml文件中引入所需的Spring Cloud相关依赖，例如Eureka、Ribbon、Feign、Hystrix、Zuul和Config等。</li></ul><p>3.3 编写一个简单的服务</p><ul><li>创建一个示例的微服务，并实现一个简单的功能接口。</li></ul><p>3.4 配置Eureka服务注册与发现</p><ul><li>在项目的配置文件中配置Eureka的相关信息，包括注册中心的地址和服务的名称。</li></ul><p>3.5 配置Ribbon负载均衡</p><ul><li>在服务调用的代码中使用Ribbon来调用其他服务，并配置负载均衡的策略。</li></ul><p>3.6 使用Feign进行服务调用</p><ul><li>在服务调用的代码中使用Feign来声明式地调用其他服务。</li></ul><p>3.7 实现容错处理</p><ul><li>使用Hystrix来处理服务调用失败、超时等异常情况，实现服务的容错处理。</li></ul><p>3.8 配置API网关</p><ul><li>使用Zuul来配置API网关，实现统一的访问入口、路由转发和请求过滤等功能。</li></ul><p>3.9 配置配置管理</p><ul><li>使用Config来配置配置中心，将配置文件集中管理，并实现配置的动态刷新。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle EBS R12 采购到应付产生的会计分录</title>
      <link href="/2023/06/12/Oracle-EBS-R12-%E9%87%87%E8%B4%AD%E5%88%B0%E5%BA%94%E4%BB%98%E4%BA%A7%E7%94%9F%E7%9A%84%E4%BC%9A%E8%AE%A1%E5%88%86%E5%BD%95/"/>
      <url>/2023/06/12/Oracle-EBS-R12-%E9%87%87%E8%B4%AD%E5%88%B0%E5%BA%94%E4%BB%98%E4%BA%A7%E7%94%9F%E7%9A%84%E4%BC%9A%E8%AE%A1%E5%88%86%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="Oracle-EBS-R12-采购到应付产生的会计分录"><a href="#Oracle-EBS-R12-采购到应付产生的会计分录" class="headerlink" title="Oracle EBS R12 采购到应付产生的会计分录"></a>Oracle EBS R12 采购到应付产生的会计分录</h3><h4 id="一、采购业务"><a href="#一、采购业务" class="headerlink" title="一、采购业务"></a>一、采购业务</h4><p>采购业务是一般企业都会有的业务，主要包括请购、采购、接收、入库、发票、付款几个步骤。分别对应采购、库存、成本、应付以及总账模块。<br>Oracle是财务业务一体化的系统，只要录入了相应的业务，则会自动生成相应的财务信息。</p><h5 id="1、采购接收"><a href="#1、采购接收" class="headerlink" title="1、采购接收"></a>1、采购接收</h5><p>采购模块主要功能是帮助业务部门管理采购订单，控制采购流程，审批层次，在请购单、和采购订单录入审批阶段是不产生财务信息的。</p><p>现假设企业采购两批原材料，价格50*2=100元。企业当前的银行存款为100元，库存成本为0。</p><p>在采购订单接收时，实际上表示物料采购已既成事实，我们将因此产生一笔因采购产生的应计负债，同时记一笔帐到我们的采购接收帐户。<br>采购接收的会计分录为：</p><table><thead><tr><th>商品采购</th><th>DR</th><th>100￥</th></tr></thead><tbody><tr><td>应付帐款 - 应付暂估</td><td>CR</td><td>100￥</td></tr></tbody></table><p>商品采购和应付帐款-应付暂估都是中转科目，相关科目的余额变化如下：</p><table><thead><tr><th>科目</th><th>初</th><th>末</th></tr></thead><tbody><tr><td>商品采购</td><td>0 +100</td><td>100￥</td></tr><tr><td>应付帐款-应付暂估</td><td>0 +100</td><td>100￥</td></tr></tbody></table><p>入库和创建发票分录后，这两个科目余额将会结平为0。</p><p>这里为了更直观显示财务变化境况，而实时计算了各科目的余额，并同时假设所有科目的期初金额为0，这样做的目的仅仅是为了更好理解一些中转科目的余额变化情况，EBS实际业务中科目余额的变动都是要在子模块传送至总账，并过账以后才发生的。</p><p>具体的分录产生流程如下：</p><ol><li><p>接收事务处理器<br>采购接收以后会自动运行“接收事务处理器”。接收事务处理器会在rcv_receiving_sub_ledger中产生采购接收的会计分录。<br>这也就是我们“接收事务处理汇总”界面查看到的分录。</p></li><li><p>传送总账<br>此时，R12中运行“创建会计科目 - 成本管理”请求，会产生子模块的会计分录 。<br>再提交“将日记帐分录传送至 GL - 成本管理”请求，则会插入分录信息至总账接口，则可以导入日记账过账。<br>在R12中，采购接收在总账日记账的来源为“Cost Management”，类别是“Receiving”。</p></li></ol><h5 id="2、交货入库"><a href="#2、交货入库" class="headerlink" title="2、交货入库"></a>2、交货入库</h5><p>采购接收以后则可以进一步交货入库。同样会执行“接收事务处理器”，不过这一次做的事情更多，取成本（成本核算方式不同，取成本的逻辑亦不同），插入记录至mtl_material_transactions表等。<br>此时还不会立刻产生入库的分录，成本管理器运行以后，则会产生库存模块的分录, 将商品采购科目的余额转移至库存成本帐户。<br>同时，如果采用标准成本，采购价格和入库成本的不同则可能产生PPV（采购价格差异Purchase Price Variance）。假设物料的标准成本为80￥，分录如下：</p><table><thead><tr><th>库存商品成本</th><th>DR</th><th>80￥</th></tr></thead><tbody><tr><td>PPV</td><td>DR</td><td>20￥</td></tr><tr><td>商品采购</td><td>CR</td><td>100￥</td></tr></tbody></table><p>相关科目的余额变化如下：</p><table><thead><tr><th>科目</th><th>初     发生</th><th>末</th></tr></thead><tbody><tr><td>库存商品成本</td><td>0      +80</td><td>80￥</td></tr><tr><td>PPV</td><td>0      +20</td><td>20￥</td></tr><tr><td>商品采购</td><td>100  -100</td><td>0￥</td></tr></tbody></table><p>中转科目商品采购科目的余额已结平为0。</p><p>1） 子模块<br>所有的库存物料事务处理（包括采购收货、子库转移、组织间转移、销售发放等等）的会计分录信息都在mtl_transaction_accounts表中 。<br>2） 总账<br>提交请求“将日记帐分录传送至 GL - 成本管理”，将子模块分录传送至总账。<br>此时总账将生成来源为je_source=’Cost Management’ and je_category=’Inventory‘的日记账分录。<br>到这里，东西已经买到并入库计入成本，接下来到付钱了。</p><h5 id="3、应付发票"><a href="#3、应付发票" class="headerlink" title="3、应付发票"></a>3、应付发票</h5><p>应付发票可以手工录入。与采购有关的发票需要通过匹配采购订单生成应付发票。根据采购项目的税码，会自动或手工产生税行。</p><p>如果收到的发票价格与采购价格有差异，还将产生IPV（发票价格差异Invoice Price Variance）。这里我们假设供应商给我们开出发票的价格为80￥，与我们的采购价格产生了20￥的IPV。税码为VAT17。</p><p>因此采购匹配的应付发票会计分录为：</p><table><thead><tr><th>应付帐款-应付暂估</th><th>DR</th><th>100￥</th></tr></thead><tbody><tr><td>暂估与发票差异(IPV)</td><td>DR</td><td>-20￥</td></tr><tr><td>进项税</td><td>DR</td><td>80*0.17￥</td></tr><tr><td>应付帐款-发票款</td><td>CR</td><td>93.6￥</td></tr></tbody></table><p>相关科目的余额变化如下：</p><table><thead><tr><th>科目</th><th>初     发生</th><th>末</th></tr></thead><tbody><tr><td>应付帐款-应付暂估</td><td>100    -100</td><td>0￥</td></tr><tr><td>暂估与发票差异(IPV)</td><td>0      -20</td><td>-20￥</td></tr><tr><td>进项税</td><td>0      -13.6</td><td>-13.6￥（应交税费属于负债类科目）</td></tr><tr><td>应付帐款-发票款</td><td>0      +93.6</td><td>93.6￥</td></tr></tbody></table><p>中转科目应付帐款-应付暂估科目的余额已结平为0。同时，由于供应商开出的发票价格为80，存在-20的IPV，因此我们实际的应付账款为80+80*1.17=93.6。</p><p>1） 录入发票<br>AP发票的分配记录了所有应付暂估和预付款核销的科目，再加上应付发票本身的应付账款科目 。<br>2） 创建会计分录<br>创建会计分录后，会在xla中产生分录信息<br>3） 传送总账<br>接下来，运行请求”将日记帐分录传送至 GL”，将在总账产生日记账分录。来源为je_source=’ Payables’ and je_category=’Purchase Invoices‘。</p><h5 id="4、应付贷项通知单"><a href="#4、应付贷项通知单" class="headerlink" title="4、应付贷项通知单"></a>4、应付贷项通知单</h5><p>应付贷项通知单与应付借项通知单与对应应收的概念并不等同。</p><p>应付贷项通知单：指供应商开给我们的表示应付减少的通知，负数，冲原始发票，可用0支付结清<br>应付贷项通知单常用于做采购退货业务，发生采购退货业务后，在应付录入应付贷项通知单，同时匹配退货生成贷项通知单行。</p><p>为了更容易理解，我们结合整个退货流程来认识贷项通知单业务。<br>退货流程：</p><p>1.接收-&gt;退货<br>假设我们交货后发现2批原材料中一批由于某种原因需要退货，通过接收-&gt;退货导航录入采购订单，执行退货业务。保存以后触发接收事务处理器，生成如下分录（与采购接收的分录方向恰恰相反）：</p><table><thead><tr><th>商品采购</th><th>CR</th><th>50￥</th></tr></thead><tbody><tr><td>应付帐款-应付暂估</td><td>DR</td><td>50￥</td></tr></tbody></table><p>冲减商品采购中转科目的余额，同时减少应付暂估中转科目的余额。相关科目的余额变化如下：</p><table><thead><tr><th>科目</th><th>初    发生</th><th>余额</th></tr></thead><tbody><tr><td>商品采购</td><td>0     -50</td><td>-50￥</td></tr><tr><td>应付帐款</td><td>0</td><td>-50￥</td></tr></tbody></table><p>以上分录可以通过前面的po_rcv_ledger.sql和po_rcv_xla_ledger.sql查询。</p><p>同时，在成本管理器运行以后，退货产生库存成本变动的分录，如下（与采购接收入库的分录方向恰恰相反）：        </p><table><thead><tr><th>库存商品成本</th><th>CR</th><th>40￥</th></tr></thead><tbody><tr><td>PPV</td><td>CR</td><td>10￥</td></tr><tr><td>商品采购</td><td>DR</td><td>50￥</td></tr></tbody></table><p>减少库存成本和PPV，增加商品采购，相关科目的余额变化如下：</p><table><thead><tr><th>科目</th><th>初      发生</th><th>余额</th></tr></thead><tbody><tr><td>库存商品成本</td><td>80       -40</td><td>40￥</td></tr><tr><td>PPV</td><td>20       -10</td><td>10￥</td></tr><tr><td>商品采购</td><td>-50       +50</td><td>0￥</td></tr></tbody></table><p>中转科目商品采购科目的余额已结平为0。<br>以上分录可以通过前面的po_rcv_inv_ledger.sql 和po_rcv_inv_xla_ledger.sql 查询。</p><p>2.贷项通知单匹配退货<br>通过应付款发票界面录入类型为贷项通知单的应付发票，然后通过匹配采购退货产生贷项通知单行。<br>对于采购退货业务的分录如下(与应收发票的分录方向恰恰相反)：</p><table><thead><tr><th>应付帐款-应付暂估</th><th>CR</th><th>50￥</th></tr></thead><tbody><tr><td>暂估与发票差异(IPV)</td><td>CR</td><td>-10￥</td></tr><tr><td>进项税</td><td>CR</td><td>40*0.17￥（应交税费属于负债类科目）</td></tr><tr><td>应付帐款-发票款</td><td>DR</td><td>93.6/2￥</td></tr></tbody></table><p>相关科目的余额变化如下：</p><table><thead><tr><th>科目</th><th>初       发生</th><th>余额</th></tr></thead><tbody><tr><td>应付帐款-应付暂估</td><td>-50      +50</td><td>0￥</td></tr><tr><td>暂估与发票差异(IPV)</td><td>-20      +10</td><td>-10￥</td></tr><tr><td>进项税</td><td>-13.6     +6.8</td><td>-6.8￥</td></tr><tr><td>应付帐款-发票款</td><td>93.6    -46.8</td><td>46.8￥</td></tr></tbody></table><p>中转科目应付帐款-应付暂估科目的余额已结平为0。<br>这样，退货的最终结果就是使库存成本和应付账款-发票款相应减少。<br>可以通过上面ap_inv_ledger.sql和ap_inv_xla_ledger.sql查询贷项通知单有关的分录信息。</p><h5 id="5、应付借项通知单"><a href="#5、应付借项通知单" class="headerlink" title="5、应付借项通知单"></a>5、应付借项通知单</h5><p>借项通知单，指我们自己开出的表示应付减少的通知，同样是负数，冲原始发票，可用0支付结清。<br>我个人的理解是，应付借项通知单，适用于发票做错后的反冲。功能上它与贷项通知单基本相似，也可用于退货业务。在采购退货界面有是否生成借项通知单的复选框，通过采购系统选项控制是否启用。</p><h5 id="6、付款"><a href="#6、付款" class="headerlink" title="6、付款"></a>6、<strong>付款</strong></h5><p>发票生成并验证通过以后，可以对发票进行付款。<br>可以在发票界面通过快速付款，付款界面录入人工付款，或者进行批付款对发票进行批量付款。批付款常应用于员工报销付款。<br>在付款界面，将蓝票（应付发票）和红票（贷项通知单）选入到同一个付款，先进行核销，再进行付款。</p><p>对发票付款，实际上就是用现金支付应付欠款，现金与应付款都减少，由于我们产生过退货业务，因此，产生分录如下：</p><table><thead><tr><th>应付帐款-发票款</th><th>DR</th><th>46.8￥</th></tr></thead><tbody><tr><td>银行存款</td><td>CR</td><td>46.8￥</td></tr></tbody></table><p>相关科目的余额变化如下：</p><table><thead><tr><th>科目</th><th>初    发生</th><th>余额</th></tr></thead><tbody><tr><td>应付帐款-发票款</td><td>46.8   -46.8</td><td>0￥</td></tr><tr><td>银行存款</td><td>100    -46.8</td><td>53.2￥</td></tr></tbody></table><p>可以看到，经过各个阶段的业务流程，最终形成的分录实际上等效于如下分录，在企业仅上线财务而没上线业务模块的时候，需要手工做如下分录，由此可见，财务业务一体化提供了很大的便捷性：</p><table><thead><tr><th>库存商品成本</th><th>DR</th><th>40￥</th></tr></thead><tbody><tr><td>PPV</td><td>DR</td><td>10￥</td></tr><tr><td>IPV</td><td>DR</td><td>-10￥</td></tr><tr><td>进项税</td><td>DR</td><td>6.8￥</td></tr><tr><td>银行存款</td><td>CR</td><td>46.8￥</td></tr></tbody></table><p>最后，到月底，企业结账，手工做如下两笔分录调整IPV和PPV差异<br>1）</p><table><thead><tr><th>库存商品成本</th><th>DR</th><th>10￥</th></tr></thead><tbody><tr><td>PPV</td><td>CR</td><td>10￥</td></tr></tbody></table><p>2）</p><table><thead><tr><th>库存商品成本</th><th>CR</th><th>10￥</th></tr></thead><tbody><tr><td>IPV</td><td>DR</td><td>10￥</td></tr></tbody></table><p>调整后PPV和IPV分别结平为0。</p><ol><li>对发票付款<br>创建会计分录以后，可以通过表查到分录信息。</li><li>传送总账。<br>接下来，运行请求” 将日记帐分录传送至 GL”，将在总账产生日记账分录。来源为je_source=’ Payables’ and je_category=’ Payments ‘。</li></ol><h4 id="二、其他应付业务"><a href="#二、其他应付业务" class="headerlink" title="二、其他应付业务"></a>二、其他应付业务</h4><p>其他应付业务，以及部分FA业务。<br><strong>1、费用报表</strong><br>费用报表是网上报销模块导入的一种类型的应付发票，当网上报销流程结束并审核通过后，可以通过请求“导入费用报表”导入应付发票。<br>除了与标准应付发票的科目有所不同。其他作用等同于标准应付发票。企业员工报销的分录通常如下：</p><table><thead><tr><th>员工报销科目</th><th>DR</th></tr></thead><tbody><tr><td>其他应付款-报销</td><td>CR</td></tr></tbody></table><p><strong>2、手工应付发票</strong><br>应付除了用于与采购模块集成外，还可以通过应付发票做些其他的杂项业务。记录些与采购无关的业务。<br>例如，企业招待客户时，员工张某代为支付客户招待费100元，为了之后偿还该员工供应商张某这100元，可以如下建应付发票：<br>直接用手工录入发票分配：招待费 100元；并指定负债帐户为：其他应付款。产生分录如下：</p><table><thead><tr><th>招待费</th><th>DR</th><th>100￥</th></tr></thead><tbody><tr><td>其他应付款</td><td>CR</td><td>100￥</td></tr></tbody></table><p>未上线网上报销模块时常常如上手工建立应付发票实现员工报销。</p><p><strong>3、应付发票导入固定资产</strong></p><p>应付发票可以成批增加为固定资产。有两种方式建立应付发票：<br>1） 直接定义固定资产型物料，其属性不可库存，并制定它的销售费用科目为固定资产中转科目。<br>该种类型物料接收、交货通常不会产生会计分录，然后通过应付发票匹配采购订单。这时候，应付发票的分录应为：</p><table><thead><tr><th>固定资产中转</th><th>DR</th></tr></thead><tbody><tr><td>应付帐款</td><td>CR</td></tr></tbody></table><p>2） 手工录入应付发票，并指定发票分配科目为固定资产中转科目。它的分录同上（1）。</p><p>最后，在应付模块提交请求“创建成批增加”后，则可以在FA模块成批增加资产。最终过账后，会形成如下分录。</p><table><thead><tr><th>固定资产</th><th>DR</th></tr></thead><tbody><tr><td>固定资产中转</td><td>CR</td></tr></tbody></table><p>固定资产中转科目结清为0.<br>FA创建会计分录后，产生固定资产的分录信息。</p><p><strong>4、预付款发票</strong></p><p>预付款发票可以用以核销标准发票，他与标准发票的分录有所不同，不过技术实现上是一样的。它的分录通常是：</p><table><thead><tr><th>预付账款</th><th>DR</th></tr></thead><tbody><tr><td>应付帐款</td><td>CR</td></tr></tbody></table><p>当核销时，他的分录为</p><table><thead><tr><th>应付账款</th><th>DR</th></tr></thead><tbody><tr><td>预付账款</td><td>CR</td></tr></tbody></table><p><strong>查询脚本</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--应付发票的应付账款贷项</span></span><br><span class="line"><span class="keyword">SELECT</span> ai.invoice_num,</span><br><span class="line">       ai.gl_date,</span><br><span class="line">       fnd_flex_ext.get_segs(<span class="string">&#x27;SQLGL&#x27;</span>,</span><br><span class="line">                             <span class="string">&#x27;GL#&#x27;</span>,</span><br><span class="line">                             <span class="number">50328</span>,</span><br><span class="line">                             ai.accts_pay_code_combination_id) acct,</span><br><span class="line">       xla_oa_functions_pkg.get_ccid_description(<span class="number">50328</span>,</span><br><span class="line">                                                 ai.accts_pay_code_combination_id) acct_desc,</span><br><span class="line">       <span class="number">0</span> dr,</span><br><span class="line">       ai.invoice_amount cr</span><br><span class="line">  <span class="keyword">FROM</span> ap_invoices_all ai</span><br><span class="line"> <span class="keyword">WHERE</span> ai.invoice_id <span class="operator">=</span> <span class="operator">&amp;</span>p_invoice_id</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="comment">--由于预付核销产生的应付账款借项</span></span><br><span class="line"><span class="keyword">SELECT</span> ai.invoice_num,</span><br><span class="line">       aid.accounting_date,</span><br><span class="line">       fnd_flex_ext.get_segs(<span class="string">&#x27;SQLGL&#x27;</span>,</span><br><span class="line">                             <span class="string">&#x27;GL#&#x27;</span>,</span><br><span class="line">                             <span class="number">50328</span>,</span><br><span class="line">                             ai.accts_pay_code_combination_id) acct,</span><br><span class="line">       xla_oa_functions_pkg.get_ccid_description(<span class="number">50328</span>,</span><br><span class="line">                                                 ai.accts_pay_code_combination_id) acct_desc,</span><br><span class="line">       <span class="number">-1</span> <span class="operator">*</span> aid.amount dr,</span><br><span class="line">       <span class="number">0</span> cr</span><br><span class="line">  <span class="keyword">FROM</span> ap_invoices_all ai, ap_invoice_distributions_all aid</span><br><span class="line"> <span class="keyword">WHERE</span> ai.invoice_id <span class="operator">=</span> aid.invoice_id</span><br><span class="line">   <span class="keyword">AND</span> aid.line_type_lookup_code <span class="operator">=</span> <span class="string">&#x27;PREPAY&#x27;</span></span><br><span class="line">   <span class="keyword">AND</span> ai.invoice_id <span class="operator">=</span> <span class="operator">&amp;</span>p_invoice_id</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="comment">-- 应付发票分配(借项)</span></span><br><span class="line"><span class="keyword">SELECT</span> ai.invoice_num,</span><br><span class="line">       aid.accounting_date,</span><br><span class="line">       fnd_flex_ext.get_segs(<span class="string">&#x27;SQLGL&#x27;</span>,</span><br><span class="line">                             <span class="string">&#x27;GL#&#x27;</span>,</span><br><span class="line">                             <span class="number">50328</span>,</span><br><span class="line">                             aid.dist_code_combination_id) acct,</span><br><span class="line">       xla_oa_functions_pkg.get_ccid_description(<span class="number">50328</span>,</span><br><span class="line">                                                 aid.dist_code_combination_id) acct_desc,</span><br><span class="line">       aid.amount dr,</span><br><span class="line">       <span class="number">0</span> cr</span><br><span class="line">  <span class="keyword">FROM</span> ap_invoices_all ai, ap_invoice_distributions_all aid</span><br><span class="line"> <span class="keyword">WHERE</span> ai.invoice_id <span class="operator">=</span> aid.invoice_id</span><br><span class="line">   <span class="keyword">AND</span> ai.invoice_id <span class="operator">=</span> <span class="operator">&amp;</span>p_invoice_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> gcc.segment3,</span><br><span class="line">       fnd_flex_ext.get_segs(<span class="string">&#x27;SQLGL&#x27;</span>, <span class="string">&#x27;GL#&#x27;</span>, <span class="number">50328</span>, gcc.code_combination_id) acct,</span><br><span class="line">       xla_oa_functions_pkg.get_ccid_description(<span class="number">50328</span>,</span><br><span class="line">                                                 gcc.code_combination_id) acct_desc,</span><br><span class="line">       l.accounted_dr,</span><br><span class="line">       l.accounted_cr</span><br><span class="line">  <span class="keyword">FROM</span> xla.xla_transaction_entities te,</span><br><span class="line">       xla_events                   e,</span><br><span class="line">       xla_ae_headers               h,</span><br><span class="line">       xla_ae_lines                 l,</span><br><span class="line">       gl_code_combinations         gcc</span><br><span class="line"> <span class="keyword">WHERE</span> te.entity_code <span class="operator">=</span> <span class="string">&#x27;AP_INVOICES&#x27;</span></span><br><span class="line">   <span class="keyword">AND</span> te.application_id <span class="operator">=</span> <span class="number">200</span></span><br><span class="line">   <span class="keyword">AND</span> te.ledger_id <span class="operator">=</span> <span class="number">2022</span></span><br><span class="line">   <span class="keyword">AND</span> nvl(te.source_id_int_1, (<span class="number">-99</span>)) <span class="operator">=</span> <span class="number">106688</span></span><br><span class="line">   <span class="keyword">AND</span> te.entity_id <span class="operator">=</span> h.entity_id</span><br><span class="line">   <span class="keyword">AND</span> te.application_id <span class="operator">=</span> h.application_id</span><br><span class="line">   <span class="keyword">AND</span> e.event_id <span class="operator">=</span> h.event_id</span><br><span class="line">   <span class="keyword">AND</span> e.application_id <span class="operator">=</span> h.application_id</span><br><span class="line">   <span class="keyword">AND</span> h.ae_header_id <span class="operator">=</span> l.ae_header_id</span><br><span class="line">   <span class="keyword">AND</span> h.application_id <span class="operator">=</span> l.application_id</span><br><span class="line">   <span class="keyword">AND</span> l.code_combination_id <span class="operator">=</span> gcc.code_combination_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> h.accounting_date,</span><br><span class="line">       fnd_flex_ext.get_segs(<span class="string">&#x27;SQLGL&#x27;</span>, <span class="string">&#x27;GL#&#x27;</span>, <span class="number">50328</span>, gcc.code_combination_id) acct,</span><br><span class="line">       xla_oa_functions_pkg.get_ccid_description(<span class="number">50328</span>,</span><br><span class="line">                                                 gcc.code_combination_id) acct_desc,</span><br><span class="line">       l.accounted_dr,</span><br><span class="line">       l.accounted_cr</span><br><span class="line">  <span class="keyword">FROM</span> xla.xla_transaction_entities te,</span><br><span class="line">       xla_events                   e,</span><br><span class="line">       xla_ae_headers               h,</span><br><span class="line">       xla_ae_lines                 l,</span><br><span class="line">       gl_code_combinations         gcc</span><br><span class="line"> <span class="keyword">WHERE</span> te.entity_code <span class="operator">=</span> <span class="string">&#x27;AP_PAYMENTS&#x27;</span></span><br><span class="line">   <span class="keyword">AND</span> te.application_id <span class="operator">=</span> <span class="number">200</span></span><br><span class="line">   <span class="keyword">AND</span> te.ledger_id <span class="operator">=</span> <span class="number">2022</span></span><br><span class="line">   <span class="keyword">AND</span> nvl(te.source_id_int_1, (<span class="number">-99</span>)) <span class="operator">=</span> <span class="number">55638</span></span><br><span class="line">   <span class="keyword">AND</span> te.entity_id <span class="operator">=</span> h.entity_id</span><br><span class="line">   <span class="keyword">AND</span> te.application_id <span class="operator">=</span> h.application_id</span><br><span class="line">   <span class="keyword">AND</span> e.event_id <span class="operator">=</span> h.event_id</span><br><span class="line">   <span class="keyword">AND</span> e.application_id <span class="operator">=</span> h.application_id</span><br><span class="line">   <span class="keyword">AND</span> h.ae_header_id <span class="operator">=</span> l.ae_header_id</span><br><span class="line">   <span class="keyword">AND</span> h.application_id <span class="operator">=</span> l.application_id</span><br><span class="line">   <span class="keyword">AND</span> l.code_combination_id <span class="operator">=</span> gcc.code_combination_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">--事务处理</span></span><br><span class="line"><span class="keyword">SELECT</span> fa.asset_number,</span><br><span class="line">       fth.transaction_type_code,</span><br><span class="line">       h.period_name,</span><br><span class="line">       fnd_flex_ext.get_segs(<span class="string">&#x27;SQLGL&#x27;</span>, <span class="string">&#x27;GL#&#x27;</span>, <span class="number">50328</span>, gcc.code_combination_id) acct,</span><br><span class="line">       xla_oa_functions_pkg.get_ccid_description(<span class="number">50328</span>,</span><br><span class="line">                                                 gcc.code_combination_id) acct_desc,</span><br><span class="line">       l.accounted_dr,</span><br><span class="line">       l.accounted_cr</span><br><span class="line">  <span class="keyword">FROM</span> xla.xla_transaction_entities te,</span><br><span class="line">       xla_events                   e,</span><br><span class="line">       xla_ae_headers               h,</span><br><span class="line">       xla_ae_lines                 l,</span><br><span class="line">       gl_code_combinations         gcc,</span><br><span class="line">       fa_transaction_headers       fth,</span><br><span class="line">       fa_additions                 fa</span><br><span class="line"> <span class="keyword">WHERE</span> te.entity_code <span class="operator">=</span> <span class="string">&#x27;TRANSACTIONS&#x27;</span></span><br><span class="line">   <span class="keyword">AND</span> te.application_id <span class="operator">=</span> <span class="number">140</span></span><br><span class="line">   <span class="keyword">AND</span> te.ledger_id <span class="operator">=</span> <span class="number">2022</span></span><br><span class="line">   <span class="keyword">AND</span> nvl(te.source_id_int_1, (<span class="number">-99</span>)) <span class="operator">=</span> fth.transaction_header_id</span><br><span class="line">   <span class="keyword">AND</span> fth.asset_id <span class="operator">=</span> fa.asset_id</span><br><span class="line">   <span class="keyword">AND</span> te.entity_id <span class="operator">=</span> h.entity_id</span><br><span class="line">   <span class="keyword">AND</span> te.application_id <span class="operator">=</span> h.application_id</span><br><span class="line">   <span class="keyword">AND</span> e.event_id <span class="operator">=</span> h.event_id</span><br><span class="line">   <span class="keyword">AND</span> e.application_id <span class="operator">=</span> h.application_id</span><br><span class="line">   <span class="keyword">AND</span> h.ae_header_id <span class="operator">=</span> l.ae_header_id</span><br><span class="line">   <span class="keyword">AND</span> h.application_id <span class="operator">=</span> l.application_id</span><br><span class="line">   <span class="keyword">AND</span> l.code_combination_id <span class="operator">=</span> gcc.code_combination_id</span><br><span class="line">   <span class="keyword">AND</span> fa.asset_number <span class="operator">=</span> <span class="string">&#x27;&amp;p_asset_number&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="comment">-- 折旧</span></span><br><span class="line"><span class="keyword">SELECT</span> fa.asset_number,</span><br><span class="line">       te.entity_code,</span><br><span class="line">       h.period_name,</span><br><span class="line">       fnd_flex_ext.get_segs(<span class="string">&#x27;SQLGL&#x27;</span>, <span class="string">&#x27;GL#&#x27;</span>, <span class="number">50328</span>, gcc.code_combination_id) acct,</span><br><span class="line">       xla_oa_functions_pkg.get_ccid_description(<span class="number">50328</span>,</span><br><span class="line">                                                 gcc.code_combination_id) acct_desc,</span><br><span class="line">       l.accounted_dr,</span><br><span class="line">       l.accounted_cr</span><br><span class="line">  <span class="keyword">FROM</span> xla.xla_transaction_entities te,</span><br><span class="line">       xla_events                   e,</span><br><span class="line">       xla_ae_headers               h,</span><br><span class="line">       xla_ae_lines                 l,</span><br><span class="line">       gl_code_combinations         gcc,</span><br><span class="line">       fa_additions                 fa</span><br><span class="line"> <span class="keyword">WHERE</span> te.entity_code <span class="operator">=</span> <span class="string">&#x27;DEPRECIATION&#x27;</span></span><br><span class="line">   <span class="keyword">AND</span> te.application_id <span class="operator">=</span> <span class="number">140</span></span><br><span class="line">   <span class="keyword">AND</span> te.ledger_id <span class="operator">=</span> <span class="number">2022</span></span><br><span class="line">   <span class="keyword">AND</span> nvl(te.source_id_int_1, (<span class="number">-99</span>)) <span class="operator">=</span> fa.asset_id</span><br><span class="line">   <span class="keyword">AND</span> te.entity_id <span class="operator">=</span> h.entity_id</span><br><span class="line">   <span class="keyword">AND</span> te.application_id <span class="operator">=</span> h.application_id</span><br><span class="line">   <span class="keyword">AND</span> e.event_id <span class="operator">=</span> h.event_id</span><br><span class="line">   <span class="keyword">AND</span> e.application_id <span class="operator">=</span> h.application_id</span><br><span class="line">   <span class="keyword">AND</span> h.ae_header_id <span class="operator">=</span> l.ae_header_id</span><br><span class="line">   <span class="keyword">AND</span> h.application_id <span class="operator">=</span> l.application_id</span><br><span class="line">   <span class="keyword">AND</span> l.code_combination_id <span class="operator">=</span> gcc.code_combination_id</span><br><span class="line">   <span class="keyword">AND</span> fa.asset_number <span class="operator">=</span> <span class="string">&#x27;&amp;p_asset_number&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> fnd_flex_ext.get_segs(<span class="string">&#x27;SQLGL&#x27;</span>, <span class="string">&#x27;GL#&#x27;</span>, <span class="number">50328</span>, mta.reference_account) acct,</span><br><span class="line">       xla_oa_functions_pkg.get_ccid_description(<span class="number">50328</span>,</span><br><span class="line">                                                 mta.reference_account) acct_desc,</span><br><span class="line">       mtst.transaction_source_type_name,</span><br><span class="line">       mtt.transaction_type_name,</span><br><span class="line">       mta.transaction_date,</span><br><span class="line">       decode(sign(mta.transaction_value),</span><br><span class="line">              <span class="number">1</span>,</span><br><span class="line">              mta.transaction_value,</span><br><span class="line">              <span class="number">0</span>,</span><br><span class="line">              decode(sign(mta.base_transaction_value),</span><br><span class="line">                     <span class="number">1</span>,</span><br><span class="line">                     <span class="number">0</span>,</span><br><span class="line">                     <span class="number">0</span>,</span><br><span class="line">                     decode(sign(mta.primary_quantity), <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">NULL</span>),</span><br><span class="line">                     <span class="keyword">NULL</span>),</span><br><span class="line">              <span class="keyword">NULL</span>,</span><br><span class="line">              decode(sign(mta.base_transaction_value),</span><br><span class="line">                     <span class="number">1</span>,</span><br><span class="line">                     mta.base_transaction_value,</span><br><span class="line">                     <span class="number">0</span>,</span><br><span class="line">                     decode(sign(mta.primary_quantity), <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">NULL</span>),</span><br><span class="line">                     <span class="keyword">NULL</span>),</span><br><span class="line">              <span class="keyword">NULL</span>) entered_dr,</span><br><span class="line">       decode(sign(mta.transaction_value),</span><br><span class="line">              <span class="number">-1</span>,</span><br><span class="line">              (<span class="number">-1</span> <span class="operator">*</span> mta.transaction_value),</span><br><span class="line">              <span class="number">0</span>,</span><br><span class="line">              decode(sign(mta.base_transaction_value),</span><br><span class="line">                     <span class="number">-1</span>,</span><br><span class="line">                     <span class="number">0</span>,</span><br><span class="line">                     <span class="number">0</span>,</span><br><span class="line">                     decode(sign(mta.primary_quantity), <span class="number">-1</span>, <span class="number">0</span>, <span class="keyword">NULL</span>),</span><br><span class="line">                     <span class="keyword">NULL</span>),</span><br><span class="line">              <span class="keyword">NULL</span>,</span><br><span class="line">              decode(sign(mta.base_transaction_value),</span><br><span class="line">                     <span class="number">-1</span>,</span><br><span class="line">                     (<span class="number">-1</span> <span class="operator">*</span> mta.base_transaction_value),</span><br><span class="line">                     <span class="number">0</span>,</span><br><span class="line">                     decode(sign(mta.primary_quantity), <span class="number">-1</span>, <span class="number">0</span>, <span class="keyword">NULL</span>),</span><br><span class="line">                     <span class="keyword">NULL</span>),</span><br><span class="line">              <span class="keyword">NULL</span>) entered_cr,</span><br><span class="line">       mmt.subinventory_code</span><br><span class="line">  <span class="keyword">FROM</span> mtl_transaction_accounts  mta,</span><br><span class="line">       mtl_material_transactions mmt,</span><br><span class="line">       mtl_transaction_types     mtt,</span><br><span class="line">       mtl_txn_source_types      mtst,</span><br><span class="line">       mtl_system_items_vl       msi</span><br><span class="line"> <span class="keyword">WHERE</span> mmt.organization_id <span class="operator">=</span> mta.organization_id</span><br><span class="line">   <span class="keyword">AND</span> mmt.transaction_id <span class="operator">=</span> mta.transaction_id</span><br><span class="line">   <span class="keyword">AND</span> mtt.transaction_type_id <span class="operator">=</span> mmt.transaction_type_id</span><br><span class="line">   <span class="keyword">AND</span> mtst.transaction_source_type_id <span class="operator">=</span> mmt.transaction_source_type_id</span><br><span class="line">   <span class="keyword">AND</span> msi.inventory_item_id <span class="operator">=</span> mmt.inventory_item_id</span><br><span class="line">   <span class="keyword">AND</span> msi.organization_id <span class="operator">=</span> mmt.organization_id</span><br><span class="line">   <span class="keyword">AND</span> mtst.transaction_source_type_name <span class="operator">=</span> <span class="string">&#x27;采购订单&#x27;</span></span><br><span class="line">   <span class="keyword">AND</span> mmt.transaction_source_id <span class="operator">=</span> <span class="number">2035</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> h.event_type_code,</span><br><span class="line">       l.accounting_class_code,</span><br><span class="line">       h.accounting_date,</span><br><span class="line">       l.entered_dr,</span><br><span class="line">       l.entered_cr,</span><br><span class="line">       xla_oa_functions_pkg.get_ccid_description(<span class="number">50328</span>,</span><br><span class="line">                                                 l.code_combination_id) descr,</span><br><span class="line">       ph.segment1 po_number</span><br><span class="line">  <span class="keyword">FROM</span> xla_ae_headers               h,</span><br><span class="line">       xla_ae_lines                 l,</span><br><span class="line">       xla_events                   e,</span><br><span class="line">       xla.xla_transaction_entities te,</span><br><span class="line">       mtl_material_transactions    mmt,</span><br><span class="line">       po_headers_all               ph</span><br><span class="line"> <span class="keyword">WHERE</span> h.application_id <span class="operator">=</span> l.application_id</span><br><span class="line">   <span class="keyword">AND</span> h.ae_header_id <span class="operator">=</span> l.ae_header_id</span><br><span class="line">   <span class="keyword">AND</span> h.application_id <span class="operator">=</span> e.application_id</span><br><span class="line">   <span class="keyword">AND</span> h.event_id <span class="operator">=</span> e.event_id</span><br><span class="line">   <span class="keyword">AND</span> h.application_id <span class="operator">=</span> te.application_id</span><br><span class="line">   <span class="keyword">AND</span> h.entity_id <span class="operator">=</span> te.entity_id</span><br><span class="line">   <span class="keyword">AND</span> nvl(te.source_id_int_1, <span class="number">-99</span>) <span class="operator">=</span> mmt.transaction_id</span><br><span class="line">   <span class="keyword">AND</span> mmt.transaction_source_id <span class="operator">=</span> ph.po_header_id</span><br><span class="line">   <span class="keyword">AND</span> te.application_id <span class="operator">=</span> <span class="number">707</span></span><br><span class="line">   <span class="keyword">AND</span> te.ledger_id <span class="operator">=</span> <span class="number">2022</span></span><br><span class="line">   <span class="keyword">AND</span> te.entity_code <span class="operator">=</span> <span class="string">&#x27;MTL_ACCOUNTING_EVENTS&#x27;</span></span><br><span class="line">   <span class="keyword">AND</span> nvl(te.source_id_int_1, <span class="number">-99</span>) <span class="operator">=</span> <span class="number">5050414</span>; <span class="comment">-- 采购入库的mmt id</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> poh.segment1,</span><br><span class="line">       poh.po_header_id,</span><br><span class="line">       rct.transaction_id,</span><br><span class="line">       rct.transaction_type,</span><br><span class="line">       rsh.shipment_header_id,</span><br><span class="line">       rsl.shipment_line_id,</span><br><span class="line">       rrs.je_category_name,</span><br><span class="line">       rrs.period_name,</span><br><span class="line">       rct.quantity,</span><br><span class="line">       fnd_flex_ext.get_segs(<span class="string">&#x27;SQLGL&#x27;</span>, <span class="string">&#x27;GL#&#x27;</span>, <span class="number">50328</span>, rrs.code_combination_id) acct,</span><br><span class="line">       xla_oa_functions_pkg.get_ccid_description(<span class="number">50328</span>,</span><br><span class="line">                                                 rrs.code_combination_id) acct_desc,</span><br><span class="line">       rrs.entered_dr,</span><br><span class="line">       rrs.entered_cr</span><br><span class="line">  <span class="keyword">FROM</span> po_headers_all               poh,</span><br><span class="line">       po_lines_all                 pol,</span><br><span class="line">       po_releases_all              pr,</span><br><span class="line">       po_line_locations_all        pll,</span><br><span class="line">       po_distributions_all         pod,</span><br><span class="line">       rcv_receiving_sub_ledger     rrs,</span><br><span class="line">       rcv_transactions             rct,</span><br><span class="line">       rcv_shipment_headers         rsh,</span><br><span class="line">       rcv_shipment_lines           rsl,</span><br><span class="line">       org_organization_definitions ood</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">   <span class="comment">-- PO </span></span><br><span class="line">   <span class="keyword">AND</span> poh.po_header_id <span class="operator">=</span> pol.po_header_id</span><br><span class="line">   <span class="keyword">AND</span> pol.po_line_id <span class="operator">=</span> pll.po_line_id</span><br><span class="line">   <span class="keyword">AND</span> pll.po_release_id <span class="operator">=</span> pr.po_release_id(<span class="operator">+</span>)</span><br><span class="line">   <span class="keyword">AND</span> pll.line_location_id <span class="operator">=</span> pod.line_location_id</span><br><span class="line">   <span class="comment">-- PO to Rcv</span></span><br><span class="line">   <span class="keyword">AND</span> to_char(pod.po_distribution_id) <span class="operator">=</span> rrs.reference3</span><br><span class="line">   <span class="keyword">AND</span> rrs.rcv_transaction_id <span class="operator">=</span> rct.transaction_id</span><br><span class="line">   <span class="keyword">AND</span> rct.shipment_header_id <span class="operator">=</span> rsh.shipment_header_id</span><br><span class="line">   <span class="keyword">AND</span> rct.shipment_line_id <span class="operator">=</span> rsl.shipment_line_id</span><br><span class="line">   <span class="comment">--</span></span><br><span class="line">   <span class="keyword">AND</span> rct.organization_id <span class="operator">=</span> ood.organization_id</span><br><span class="line">   <span class="keyword">AND</span> ood.set_of_books_id <span class="operator">=</span> rrs.set_of_books_id</span><br><span class="line">   <span class="keyword">AND</span> poh.segment1 <span class="operator">=</span> <span class="string">&#x27;2008000355&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> te.entity_code,</span><br><span class="line">       te.application_id,</span><br><span class="line">       gcc.segment3,</span><br><span class="line">       fnd_flex_ext.get_segs(<span class="string">&#x27;SQLGL&#x27;</span>, <span class="string">&#x27;GL#&#x27;</span>, <span class="number">50328</span>, gcc.code_combination_id) acct,</span><br><span class="line">       xla_oa_functions_pkg.get_ccid_description(<span class="number">50328</span>,</span><br><span class="line">                                                 gcc.code_combination_id) acct_desc,</span><br><span class="line">       l.accounted_dr,</span><br><span class="line">       l.accounted_cr</span><br><span class="line">  <span class="keyword">FROM</span> xla.xla_transaction_entities te,</span><br><span class="line">       xla_events                   e,</span><br><span class="line">       xla_ae_headers               h,</span><br><span class="line">       xla_ae_lines                 l,</span><br><span class="line">       gl_code_combinations         gcc,</span><br><span class="line">       rcv_transactions             rct,</span><br><span class="line">       po_headers_all               poh</span><br><span class="line"> <span class="keyword">WHERE</span> te.entity_code <span class="operator">=</span> <span class="string">&#x27;RCV_ACCOUNTING_EVENTS&#x27;</span></span><br><span class="line">   <span class="keyword">AND</span> te.application_id <span class="operator">=</span> <span class="number">707</span></span><br><span class="line">   <span class="keyword">AND</span> te.ledger_id <span class="operator">=</span> <span class="number">2022</span></span><br><span class="line">   <span class="keyword">AND</span> nvl(te.source_id_int_1, (<span class="number">-99</span>)) <span class="operator">=</span> rct.transaction_id</span><br><span class="line">   <span class="keyword">AND</span> te.entity_id <span class="operator">=</span> h.entity_id</span><br><span class="line">   <span class="keyword">AND</span> te.application_id <span class="operator">=</span> h.application_id</span><br><span class="line">   <span class="keyword">AND</span> e.event_id <span class="operator">=</span> h.event_id</span><br><span class="line">   <span class="keyword">AND</span> e.application_id <span class="operator">=</span> h.application_id</span><br><span class="line">   <span class="keyword">AND</span> h.ae_header_id <span class="operator">=</span> l.ae_header_id</span><br><span class="line">   <span class="keyword">AND</span> h.application_id <span class="operator">=</span> l.application_id</span><br><span class="line">   <span class="keyword">AND</span> l.code_combination_id <span class="operator">=</span> gcc.code_combination_id</span><br><span class="line">   <span class="keyword">AND</span> rct.po_header_id <span class="operator">=</span> poh.po_header_id</span><br><span class="line">   <span class="keyword">AND</span> poh.segment1 <span class="operator">=</span> <span class="string">&#x27;2008000762&#x27;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> EBS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle EBS R12 接口参考文档</title>
      <link href="/2023/06/10/Oracle-EBS-R12-%E6%8E%A5%E5%8F%A3%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/"/>
      <url>/2023/06/10/Oracle-EBS-R12-%E6%8E%A5%E5%8F%A3%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>模块</th><th>应用场景</th><th>类型</th><th>API/INTERFACE</th></tr></thead><tbody><tr><td>AP</td><td>付款核销</td><td>API</td><td>ap_pay_invoice_pkg.ap_pay_invoice</td></tr><tr><td>AP</td><td>应付发票审批</td><td>API</td><td>ap_approval_pkg.approval</td></tr><tr><td>AP</td><td>预付款核销</td><td>API</td><td>ap_prepay_pkg.apply_prepay_fr_prepay</td></tr><tr><td>AP</td><td>创建应付发票</td><td>API</td><td>ap_import_invoices_pkg.import_invoices</td></tr><tr><td>AP</td><td>创建付款历史记录</td><td>API</td><td>ap_reconciliation_pkg.insert_payment_history</td></tr><tr><td>AP</td><td>创建供应商头</td><td>API</td><td>ap_vendor_pub_pkg.create_vendor</td></tr><tr><td>AP</td><td>验证供应商头</td><td>API</td><td>ap_vendor_pub_pkg.validate_vendor</td></tr><tr><td>AP</td><td>更新供应商头</td><td>API</td><td>ap_vendor_pub_pkg.update_vendor</td></tr><tr><td>AP</td><td>创建供应商地点</td><td>API</td><td>ap_vendor_pub_pkg.create_vendor_site</td></tr><tr><td>AP</td><td>验证供应商地点</td><td>API</td><td>ap_vendor_pub_pkg.validate_vendor_site</td></tr><tr><td>AP</td><td>更新供应商地点</td><td>API</td><td>ap_vendor_pub_pkg.update_vendor_site</td></tr><tr><td>AP</td><td>创建供应商联系信息</td><td>API</td><td>ap_vendor_pub_pkg.create_vendor_contact</td></tr><tr><td>AP</td><td>验证供应商联系信息</td><td>API</td><td>ap_vendor_pub_pkg.validate_vendor_contact</td></tr><tr><td>AP</td><td>更新供应商联系信息</td><td>API</td><td>ap_vendor_pub_pkg.update_vendor_contact</td></tr><tr><td>AP</td><td>创建Notes</td><td>API</td><td>ap_notes_pub.create_note</td></tr><tr><td>AP</td><td>供应商导入</td><td>INTERFACE</td><td>AR.APXSUIMP</td></tr><tr><td>AP</td><td>供应商地点导入</td><td>INTERFACE</td><td>AR.APXSSIMP</td></tr><tr><td>AP</td><td>供应商地点联系人导入</td><td>INTERFACE</td><td>AR.APXSCIMP</td></tr><tr><td>AP</td><td>应付发票导入</td><td>INTERFACE</td><td>AR.APXIIMPT</td></tr><tr><td>AR</td><td>贷项通知单核销</td><td>API</td><td>ar_cm_api_pub.apply_on_account</td></tr><tr><td>AR</td><td>收款核销</td><td>API</td><td>ar_receipt_api_pub.apply</td></tr><tr><td>AR</td><td>收款撤销核销</td><td>API</td><td>ar_receipt_api_pub.unapply</td></tr><tr><td>AR</td><td>应收发票导入</td><td>INTERFACE</td><td>AR.RAXTRX</td></tr><tr><td>AR</td><td>创建应收发票</td><td>API</td><td>ar_invoice_api_pub.create_single_invoice</td></tr><tr><td>AR</td><td>创建应收收款</td><td>API</td><td>AR_RECEIPT_API_PUB.create_cash</td></tr><tr><td>AR</td><td>创建客户联系人</td><td>API</td><td>hz_contact_point_v2pub.create_phone_contact_point</td></tr><tr><td>AR</td><td>格式化地址信息</td><td>API</td><td>ARP_ADDR_PKG.FORMAT_ADDRESS</td></tr><tr><td>AR</td><td>创建客户</td><td>API</td><td>hz_party_v2pub.create_organization</td></tr><tr><td>AR</td><td>更新客户</td><td>API</td><td>hz_party_v2pub.update_organization</td></tr><tr><td>AR</td><td>创建客户地址</td><td>API</td><td>hz_location_v2pub.create_location</td></tr><tr><td>AR</td><td>更新客户地址</td><td>API</td><td>hz_location_v2pub.update_location</td></tr><tr><td>AR</td><td>创建party_site</td><td>API</td><td>hz_party_site_v2pub.create_party_site</td></tr><tr><td>AR</td><td>创建客户地点</td><td>API</td><td>hz_cust_account_site_v2pub.create_cust_acct_site</td></tr><tr><td>AR</td><td>创建客户地点的业务用途</td><td>API</td><td>hz_cust_account_site_v2pub.create_cust_site_use</td></tr><tr><td>AR</td><td>更新客户地点的业务用途</td><td>API</td><td>hz_cust_account_site_v2pub.update_cust_site_use</td></tr><tr><td>AR</td><td>创建客户配置文件</td><td>API</td><td>hz_customer_profile_v2pub.create_customer_profile</td></tr><tr><td>AR</td><td>创建客户配置文件金额</td><td>API</td><td>hz_customer_profile_v2pub.create_cust_profile_amt</td></tr><tr><td>AR</td><td>更新客户配置文件金额</td><td>API</td><td>hz_customer_profile_v2pub.update_cust_profile_amt</td></tr><tr><td>AR</td><td>创建客户帐户</td><td>API</td><td>hz_cust_account_v2pub.create_cust_account</td></tr><tr><td>AR</td><td>更新客户帐户</td><td>API</td><td>hz_cust_account_v2pub.update_cust_account</td></tr><tr><td>AR</td><td>创建客户帐户关系</td><td>API</td><td>hz_cust_account_v2pub.create_cust_acct_relate</td></tr><tr><td>AR</td><td>更新客户帐户关系</td><td>API</td><td>hz_cust_account_v2pub.update_cust_acct_relate</td></tr><tr><td>AR</td><td>创建客户联系人</td><td>API</td><td>hz_party_v2pub.create_person</td></tr><tr><td>AR</td><td>更新客户联系人</td><td>API</td><td>hz_party_v2pub.update_person</td></tr><tr><td>AR</td><td>创建客户与联系人的关系</td><td>API</td><td>hz_relationship_v2pub.create_relationship_with_usg</td></tr><tr><td>AR</td><td>创建客户帐户角色(用途)</td><td>API</td><td>hz_cust_account_role_v2pub.create_cust_account_role</td></tr><tr><td>AR</td><td>创建联系方式</td><td>API</td><td>hz_contact_point_v2pub.create_contact_point</td></tr><tr><td>AR</td><td>更新联系方式</td><td>API</td><td>hz_contact_point_v2pub.update_contact_point</td></tr><tr><td>BOM</td><td>复制工艺路线</td><td>API</td><td>bom_copy_routing.copy_routing</td></tr><tr><td>BOM</td><td>创建工艺路线</td><td>API</td><td>bom_rtg_pub.process_rtg</td></tr><tr><td>BOM</td><td>创建物料清单</td><td>API</td><td>BOM_BO_PUB.PROCESS_BOM</td></tr><tr><td>BOM</td><td>流式工艺路线绘图</td><td>API</td><td>bom_op_network_util.perform_writes</td></tr><tr><td>BOM</td><td>创建ECO</td><td>API</td><td>Eng_Eco_PUB.Process_Eco</td></tr><tr><td>BOM</td><td>物料清单展开</td><td>API</td><td>bompexpl.exploder_userexit</td></tr><tr><td>BOM</td><td>物料成本导入/更新</td><td>INTERFACE</td><td>BOM.CSTPCIMP</td></tr><tr><td>BOM</td><td>物料清单导入/更新</td><td>INTERFACE</td><td>BOM.BMCOIN</td></tr><tr><td>BOM</td><td>工艺路线导入/更新</td><td>INTERFACE</td><td>BOM.BMCOIN</td></tr><tr><td>BOM</td><td>ECO导入</td><td>INTERFACE</td><td>BOM.ENGCHGIMP</td></tr><tr><td>CE</td><td>Bank Statement银行对账单导入</td><td>INTERFACE</td><td>CE.ARPLABIM</td></tr><tr><td>CST</td><td>物料成本导入/更新</td><td>API</td><td>cst_item_cost_import_interface.start_item_cost_import_process</td></tr><tr><td>FND</td><td>获取关键性弹性域组合说明</td><td>API</td><td>fnd_flex_keyval.concatenated_descriptions</td></tr><tr><td>FND</td><td>验证键值弹性域</td><td>API</td><td>fnd_flex_descval.validate_desccols</td></tr><tr><td>FND</td><td>获取币种格式掩码</td><td>API</td><td>fnd_currency.get_format_mask</td></tr><tr><td>GL</td><td>汇率转换</td><td>API</td><td>gl_currency_api.get_rate</td></tr><tr><td>GL</td><td>查询单段帐户组合的描述</td><td>API</td><td>gl_flexfields_pkg.get_description_sql</td></tr><tr><td>GL</td><td>查询完整帐户组合的描述</td><td>API</td><td>gl_flexfields_pkg.get_concat_description</td></tr><tr><td>GL</td><td>币种金额转换</td><td>API</td><td>gl_currency_api.convert_amount</td></tr><tr><td>GL</td><td>日记账导入</td><td>INTERFACE</td><td>SQLGL.GLLEZL</td></tr><tr><td>HR</td><td>创建HR职务</td><td>API</td><td>hr_job_api.create_job</td></tr><tr><td>HR</td><td>更新HR职务分配</td><td>API</td><td>hr_assignment_api.update_emp_asg_criteria</td></tr><tr><td>HR</td><td>创建职位</td><td>API</td><td>hr_position_api.create_position</td></tr><tr><td>HR</td><td>创建雇员</td><td>API</td><td>hr_employee_api.create_employee</td></tr><tr><td>HR</td><td>解雇雇员</td><td>APi</td><td>hr_ex_employee_api.actual_termination_emp</td></tr><tr><td>IBY</td><td>创建供应商头/地点付款方法</td><td>API</td><td>iby_disbursement_setup_pub.create_external_payee</td></tr><tr><td>IBY</td><td>更行供应商头/地点付款方法</td><td>API</td><td>iby_disbursement_setup_pub.update_external_payee</td></tr><tr><td>IBY</td><td>创建银行</td><td>API</td><td>iby_ext_bankacct_pub.create_ext_bank</td></tr><tr><td>IBY</td><td>更行银行</td><td>API</td><td>iby_ext_bankacct_pub.update_ext_bank</td></tr><tr><td>IBY</td><td>创建银行分行</td><td>API</td><td>iby_ext_bankacct_pub.create_ext_bank_branch</td></tr><tr><td>IBY</td><td>更新银行分行</td><td>API</td><td>iby_ext_bankacct_pub.update_ext_bank_branch</td></tr><tr><td>IBY</td><td>创建银行账户</td><td>API</td><td>iby_ext_bankacct_pub.create_ext_bank_acct</td></tr><tr><td>IBY</td><td>更新银行账户</td><td>API</td><td>iby_ext_bankacct_pub.create_ext_bank_acct</td></tr><tr><td>IBY</td><td>检查银行是否存在</td><td>API</td><td>iby_ext_bankacct_pub.check_bank_exist</td></tr><tr><td>IBY</td><td>检查支行是否存在</td><td>API</td><td>iby_ext_bankacct_pub.check_ext_bank_branch_exist</td></tr><tr><td>IBY</td><td>检查银行账户是否存在</td><td>API</td><td>iby_ext_bankacct_pub.check_ext_acct_exist</td></tr><tr><td>INV</td><td>创建物料搬运单头</td><td>API</td><td>inv_move_order_pub.create_move_order_header</td></tr><tr><td>INV</td><td>创建保留</td><td>API</td><td>inv_reservation_form_pkg.create_reservation</td></tr><tr><td>INV</td><td>释放保留</td><td>API</td><td>inv_reservation_form_pkg.delete_reservation</td></tr><tr><td>INV</td><td>创建物料</td><td>API</td><td>inv_item_grp.create_item</td></tr><tr><td>INV</td><td>更新物料</td><td>API</td><td>inv_item_grp.update_item</td></tr><tr><td>INV</td><td>物料编码导入/更新</td><td>INTERFACE</td><td>INV.INCOIN</td></tr><tr><td>INV</td><td>创建物料类别</td><td>API</td><td>inv_item_category_pub.create_category_assignment</td></tr><tr><td>INV</td><td>更新物料类别</td><td>API</td><td>inv_item_category_pub.update_category_assignment</td></tr><tr><td>INV</td><td>物料类别分配导入</td><td>INTERFACE</td><td>INV.INV_ITEM_CAT_ASSIGN_OI</td></tr><tr><td>INV</td><td>创建物料目录</td><td>API</td><td>inv_item_catalog_elem_pub.process_item_descr_elements</td></tr><tr><td>INV</td><td>创建物料默认子库</td><td>API</td><td>inv_item_sub_default_pkg.insert_upd_item_sub_defaults</td></tr><tr><td>INV</td><td>创建物料交叉参考</td><td>API</td><td>mtl_cross_references_pub.process_xref</td></tr><tr><td>INV</td><td>创建批次</td><td>API</td><td>inv_lot_api_pub.create_inv_lot</td></tr><tr><td>INV</td><td>更新批次状态</td><td>API</td><td>inv_material_status_pub.update_status</td></tr><tr><td>INV</td><td>获取现有量</td><td>API</td><td>inv_quantity_tree_pub.query_quantities</td></tr><tr><td>INV</td><td>创建物料事务处理</td><td>API</td><td>mtl_online_transaction_pub.process_online</td></tr><tr><td>INV</td><td>创建现有量（物料事务处理）</td><td>API</td><td>inv_txn_manager_pub.process_transactions</td></tr><tr><td>INV</td><td>创建现有量（物料事务处理）</td><td>API</td><td>mtl_online_transaction_pub.process_online</td></tr><tr><td>INV</td><td>现有量导入（物料事务处理）</td><td>INTERFACE</td><td>INV.INCTCW</td></tr><tr><td>INV</td><td>物料转移（物料事务处理）</td><td>INTERFACE</td><td>INV.INCTCW</td></tr><tr><td>INV</td><td>物料事务处理：PO接收</td><td>INTERFACE</td><td>PO.RCVTPO</td></tr><tr><td>INV</td><td>工单完工入库</td><td>API</td><td>inv_txn_manager_pub.process_transactions</td></tr><tr><td>INV</td><td>获取物料单位转换率</td><td>API</td><td>inv_convert.inv_um_conversion</td></tr><tr><td>INV</td><td>获取公司间开票转移价格</td><td>API</td><td>mtl_intercompany_invoices.get_transfer_price</td></tr><tr><td>INV</td><td>修改处理物料搬运单的分配数量函数</td><td>API</td><td>INV_TO_FORM_TROLIN.VALIDATE_AND_WRITE</td></tr><tr><td>INV</td><td>处理物料搬运单</td><td>API</td><td>inv_pick_wave_pick_confirm_pub.pick_confirm</td></tr><tr><td>INV</td><td>得到物料搬运单行的相关信息</td><td>API</td><td>inv_mo_line_detail_util.query_row</td></tr><tr><td>INV</td><td>创建物料搬运单行</td><td>API</td><td>inv_move_order_pub.create_move_order_lines</td></tr><tr><td>INV</td><td>为物料搬运单生成分配(也可以顺带处理物料搬运单)</td><td>API</td><td>inv_replenish_detail_pub.line_details_pub 产生的分配记录位于以下两张表，其中批次表可以删除后自己添加记录以改变出货批次： mtl_material_transactions_tem mtl_transaction_lots_temp</td></tr><tr><td>INV</td><td>查询物料搬运单行</td><td>API</td><td>inv_trolin_util.query_rows</td></tr><tr><td>INV</td><td>查询物料搬运单分配</td><td>API</td><td>inv_mo_line_detail_util.query_rows</td></tr><tr><td>INV</td><td>创建货位</td><td>API</td><td>inv_loc_wms_pub.create_locator</td></tr><tr><td>JTF</td><td>创建CRM资源</td><td>API</td><td>jtf_rs_resource_pub.create_resource</td></tr><tr><td>JTF</td><td>创建销售人员</td><td>API</td><td>jtf_rs_salesreps_pub.create_salesrep</td></tr><tr><td>JTF</td><td>创建CRM资源成员关系</td><td>API</td><td>jtf_rs_grp_membership_pub.create_group_membership</td></tr><tr><td>JTF</td><td>创建CRM资源角色关联</td><td>API</td><td>jtf_rs_role_relate_pub.create_resource_role_relate</td></tr><tr><td>JTF</td><td>创建CRM资源组</td><td>API</td><td>jtf_rs_groups_pub.create_resource_group</td></tr><tr><td>JTF</td><td>创建CRM任务</td><td>API</td><td>jtf_tasks_pub.create_task</td></tr><tr><td>JTF</td><td>创建CRM任务分配</td><td>API</td><td>jtf_tasks_assignments_pub.create_task_assignment</td></tr><tr><td>JTF</td><td>创建CRM任务参照</td><td>API</td><td>jtf_tasks_references_pub.create_references</td></tr><tr><td>MRP</td><td>创建采购规则</td><td>API</td><td>mrp_sourcing_rule_pub.process_sourcing_rule</td></tr><tr><td>MRP</td><td>创建采购规则分配</td><td>API</td><td>mrp_src_assignment_pub.process_assignment</td></tr><tr><td>ONT</td><td>创建发货</td><td>API</td><td>wsh_delivery_details_pub.autocreate_deliveries</td></tr><tr><td>ONT</td><td>订单导入，更新，取消，暂挂</td><td>API</td><td>oe_order_pub.process_order</td></tr><tr><td>ONT</td><td>订单行导入，更新，取消</td><td>API</td><td>OE_ORDER_PUB.PROCESS_LINE</td></tr><tr><td>ONT</td><td>删除订单头</td><td>API</td><td>OE_ORDER_PUB.DELETE_ORDER</td></tr><tr><td>ONT</td><td>删除订单行</td><td>API</td><td>OE_ORDER_PUB.DELETE_LINE</td></tr><tr><td>PA</td><td>更新项目成员</td><td>API</td><td>PA_PROJECT_PARTIES_PUB.UPDATE_PROJECT_PARTY</td></tr><tr><td>PA</td><td>创建项目成员</td><td>API</td><td>PA_PROJECT_PARTIES_PUB.CREATE_PROJECT_PARTY</td></tr><tr><td>PA</td><td>创建（复制）项目</td><td>API</td><td>PA_PROJECT_CORE1.COPY_PROJECT</td></tr><tr><td>PA</td><td>创建项目客户</td><td>API</td><td>PA_PROJECTS_MAINT_PVT.CREATE_CUSTOMER</td></tr><tr><td>PA</td><td>创建（复制）项目周期</td><td>API</td><td>PA_RETENTION_UTIL.COPY_RETENTION_SETUP</td></tr><tr><td>PA</td><td>创建任务</td><td>API</td><td>PA_PROJECT_PUB.ADD_TASK</td></tr><tr><td>PA</td><td>更新任务</td><td>API</td><td>PA_TASK_PVT1.UPDATE_TASK</td></tr><tr><td>PA</td><td>创建任务分配</td><td>API</td><td>PA_TASK_ASSIGNMENTS_PUB.CREATE_TASK_ASSIGNMENTS</td></tr><tr><td>PA</td><td>删除任务</td><td>API</td><td>PA_PROJECT_PUB.DELETE_TASK</td></tr><tr><td>PA</td><td>创建项目客户</td><td>API</td><td>PA_CUSTOMERS_CONTACTS_PUB.CREATE_PROJECT_CUSTOMER</td></tr><tr><td>PA</td><td>更新项目客户</td><td>API</td><td>PA_CUSTOMERS_CONTACTS_PUB.UPDATE_PROJECT_CUSTOMER</td></tr><tr><td>PA</td><td>创建项目协议</td><td>API</td><td>PA_AGREEMENT_PUB.CREATE_AGREEMENT</td></tr><tr><td>PA</td><td>创建协议行</td><td>API</td><td>PA_AGREEMENT_PUB.ADD_FUNDING</td></tr><tr><td>PA</td><td>批量导入任务</td><td>API</td><td>PA_TASK_PUB1.COPY_TASKS_IN_BULK</td></tr><tr><td>PA</td><td>更新计划版本</td><td>API</td><td>PA_TASK_PUB1.UPDATE_SCHEDULE_VERSION</td></tr><tr><td>PA</td><td>创建计划版本</td><td>API</td><td>PA_TASK_PUB1.CREATE_SCHEDULE_VERSION</td></tr><tr><td>PA</td><td>更新结构状态</td><td>API</td><td>PA_PROJECT_PUB.CHANGE_STRUCTURE_STATUS</td></tr><tr><td>PA</td><td>更新版本属性</td><td>API</td><td>PA_PROJECT_STRUCTURE_PUB1.Update_Structure_Version_Attr</td></tr><tr><td>PA</td><td>更改项目状态</td><td>API</td><td>PA_PROJECTS_MAINT_PUB.PROJECT_STATUS_CHANGE</td></tr><tr><td>PA</td><td>更新任务状态</td><td>API</td><td>pa_status_pub.update_progress</td></tr><tr><td>PA</td><td>获取WBS最新版本</td><td>API</td><td>pa_project_structure_utils.get_latest_wp_version</td></tr><tr><td>PA</td><td>获取WBS当前版本</td><td>API</td><td>pa_project_structure_utils.get_current_working_ver_id</td></tr><tr><td>PO</td><td>创建autosourcing</td><td>API</td><td>begin PO_AUTOSOURCE_SV.REQIMPORT_SOURCING ( ‘INVENTORY’ , :request_id , :l_multi_dist_flag ) ; END ;</td></tr><tr><td>PO</td><td>关闭订单</td><td>API</td><td>po_actions.close_po</td></tr><tr><td>PO</td><td>一揽子采购协议导入</td><td>INTERFACE</td><td>PO.POXPDOI</td></tr><tr><td>PO</td><td>标准采购订单导入</td><td>INTERFACE</td><td>PO.POXPOPDOI</td></tr><tr><td>PO</td><td>BPA发放取消</td><td>API</td><td>po_document_control_pub.control_document</td></tr><tr><td>PO</td><td>取消标准采购订单</td><td>API</td><td>po_document_control_pub.control_document</td></tr><tr><td>PO</td><td>更新BPA发放</td><td>API</td><td>po_change_api1_s.update_po</td></tr><tr><td>PO</td><td>更新标准采购订单</td><td>API</td><td>po_change_api1_s.update_po</td></tr><tr><td>PO</td><td>PR自动创建PO</td><td>API</td><td>PO_INTERFACE_S.create_documents</td></tr><tr><td>PO</td><td>获取OU本位币</td><td>API</td><td>po_currency_sv.get_functional_currency_code</td></tr><tr><td>PO</td><td>获取两OU本位币汇率</td><td>API</td><td>po_currency_sv.get_cross_ou_rate</td></tr><tr><td>PO</td><td>创建采购申请</td><td>API</td><td>po_create_requisition_sv.process_requisition</td></tr><tr><td>PO</td><td>PO接收/PO退货/RMA接收</td><td>INTERFACE</td><td>PO.RVCTP</td></tr><tr><td>SR</td><td>创建服务请求</td><td>API</td><td>cs_servicerequest_pub.create_servicerequest</td></tr><tr><td>SR</td><td>更新服务请求</td><td>API</td><td>cs_servicerequest_pub.update_servicerequest</td></tr><tr><td>SR</td><td>更新服务请求状态</td><td>API</td><td>cs_servicerequest_pub.update_status</td></tr><tr><td>SR</td><td>更新服务问题编码</td><td>API</td><td>cs_servicerequest_pub.update_problem_code</td></tr><tr><td>SR</td><td>服务任务创建/更新/锁定/删除</td><td>API</td><td>jtf_task_assignments_pub.create_task_assignment jtf_task_assignments_pub.update_task_assignment jtf_task_assignments_pub.lock_task_assignment jtf_task_assignments_pub.delete_task_assignment</td></tr><tr><td>SR</td><td>创建例程</td><td>API</td><td>csi_item_instance_pub.create_item_instance</td></tr><tr><td>SR</td><td>更新例程</td><td>API</td><td>csi_item_instance_pub.update_item_instance</td></tr><tr><td>SR</td><td>终止例程</td><td>API</td><td>csi_item_instance_pub.expire_item_instance</td></tr><tr><td>SR</td><td>复制例程</td><td>API</td><td>csi_item_instance_pub.copy_item_instance</td></tr><tr><td>WIP</td><td>离散任务导入</td><td>INTERFACE</td><td>WIP.WICMLP</td></tr><tr><td>WIP</td><td>离散任务导入</td><td>API</td><td>wip_massload_pub.massloadjobs</td></tr><tr><td>WMS</td><td>LPN重用</td><td>API</td><td>wms_container_pub.reuse_lpns</td></tr><tr><td>WMS</td><td>创建LPN</td><td>API</td><td>inv_rcv_common_apis.create_lpn</td></tr><tr><td>WSH</td><td>为销售订单创建批号</td><td>API</td><td>wsh_picking_batches_pub.create_batch</td></tr><tr><td>WSH</td><td>发放销售订单</td><td>API</td><td>wsh_picking_batches_pub.release_batch</td></tr><tr><td>WSH</td><td>创建交货号</td><td>API</td><td>wsh_delivery_autocreate.autocreate_deliveries</td></tr><tr><td>WSH</td><td>发运确认销售订单</td><td>API</td><td>wsh_deliveries_pub.delivery_action</td></tr><tr><td>XLA</td><td>创建分录</td><td>API</td><td>xla_journal_entries_pub_pkg.create_journal_entry_header xla_journal_entries_pub_pkg.create_journal_entry_line xla_journal_entries_pub_pkg.complete_journal_entry</td></tr><tr><td>INV</td><td>库存客户物料导入</td><td>INTERFACE</td><td>INV.INVCIINT INV.INVCIINTX</td></tr><tr><td>PO</td><td>PO关闭头</td><td>API</td><td>po_action.close_po</td></tr><tr><td>ONT</td><td>获取订单头附属栏位信息</td><td>API</td><td>OE_OE_TOTAL_SUMMARY.ORDER_TOTALS</td></tr><tr><td>FND</td><td>获取关键性弹性域组合ccid</td><td>API</td><td>fnd_flex_ext.get_ccid</td></tr><tr><td>FA</td><td>资产分配</td><td>API</td><td>fa_transfer_pub.do_transfer</td></tr><tr><td>FA</td><td>资产报废</td><td>API</td><td>fa_retirement_pub.do_retirement</td></tr><tr><td>FA</td><td>资产成批新增</td><td>INTERFACE</td><td>fa_mass_additions</td></tr><tr><td>OM</td><td>订单头合计信息</td><td>API</td><td>oe_oe_totals_summary.order_totals(p_header_id =&gt; p_order_header_id, p_subtotal =&gt; l_subtotal, p_discount =&gt; l_discount, p_charges =&gt; l_charges, p_tax =&gt; l_tax);</td></tr><tr><td>AP</td><td>付款创建会计科目</td><td>API</td><td>AP_DRILLDOWN_PUB_PKG.PAYMENT_ONLINE_ACCOUNTING</td></tr><tr><td>XLA</td><td>子模块会计科目传GL</td><td>API</td><td>xla_transfer_pkg.gl_transfer_main</td></tr><tr><td>XLA</td><td>子模块创建会计科目</td><td>API</td><td>XLA_ACCOUNTING_PUB_PKG.accounting_program_document</td></tr><tr><td>FUN</td><td>创建公司间往来事务处理</td><td>API</td><td>fun_trx_pub.CREATE_BATCH</td></tr><tr><td>INV</td><td>杂项事务处理API</td><td>INTERFACE</td><td>mtl_transactions_interface、inv_txn_manager_pub.process_transactions</td></tr><tr><td>PO</td><td>接收事务处理INTERFACE处理器调用</td><td>API</td><td>por_rcv_ord_sv.call_txn_processor</td></tr><tr><td>INV</td><td>创建‘检验’接收事务处理</td><td>API</td><td>rcv_inspection_grp.Insert_Inspection</td></tr><tr><td>EAM</td><td>资产编号关联仪表信息</td><td>API</td><td>eam_meterassoc_pub.insert_assetmeterassoc</td></tr><tr><td>EAM</td><td>资产编号生成活动信息</td><td>API</td><td>eam_item_activities_pub.insert_item_activities</td></tr><tr><td>EAM</td><td>预防性维护计划创建</td><td>API</td><td>eam_pmdef_pub.create_pm_def</td></tr><tr><td>EAM</td><td>更新资产编号</td><td>API</td><td>eam_assetnumber_pub.Update_Asset_Number</td></tr><tr><td>EAM</td><td>创建资产编号</td><td>API</td><td>eam_assetnumber_pub.Insert_Asset_Number</td></tr><tr><td>EAM</td><td>创建资产属性</td><td>API</td><td>eam_assetattr_value_pub.insert_assetattr_value</td></tr><tr><td>PO</td><td>API方式创建一揽子采购协议</td><td>API</td><td>po_pdoi_grp.start_process</td></tr><tr><td>PO</td><td>API方式创建标准采购订单</td><td>API</td><td>po_docs_interface_sv5.process_po_headers_interface</td></tr><tr><td>INV</td><td>任务发退料</td><td>INTERFACE</td><td>INV.INCTCM</td></tr><tr><td>WIP</td><td>任务工序移动</td><td>INTERFACE</td><td>WIP.WICTMS</td></tr><tr><td>WSH</td><td>撤销交货号</td><td>API</td><td>wsh_delivery_details_actions.unassign_detail_from_delivery</td></tr><tr><td>WSH</td><td>更新发运明细</td><td>API</td><td>wsh_delivery_details_pub.update_shipping_attributes</td></tr><tr><td>FND</td><td>获取并发并请求模板</td><td>API</td><td>fnd_conc_templates.get_template_information</td></tr><tr><td>WIP</td><td>工序移动</td><td>INTERFACE</td><td>WIP.WICTMS</td></tr><tr><td>INV</td><td>导入物料</td><td>API</td><td>ego_item_pub.process_items</td></tr><tr><td>INV</td><td>创建保留</td><td>API</td><td>inv_reservation_pub.create_reservation</td></tr><tr><td>INV</td><td>查找保留</td><td>API</td><td>inv_reservation_pub.query_reservation</td></tr><tr><td>INV</td><td>单位转换</td><td>API</td><td>inv_convert.inv_um_convert</td></tr><tr><td>INV</td><td>更新保留</td><td>API</td><td>inv_reservation_pub.update_reservation</td></tr><tr><td>INV</td><td>删除物料搬运单分配</td><td>API</td><td>inv_mo_line_detail_util.delete_row</td></tr><tr><td>XLA</td><td>创建事件</td><td>API</td><td>xla_events_pub_pkg.create_event</td></tr><tr><td>XLA</td><td>生成分录</td><td>API</td><td>xla_accounting_pub_pkg.accounting_program_document</td></tr><tr><td>XLA</td><td>删除分录</td><td>API</td><td>xla_journal_entries_pkg.delete_journal_entries</td></tr><tr><td>GL</td><td>预算检查</td><td>API</td><td>xla_je_funds_checker_pkg.check_funds</td></tr><tr><td>GL</td><td>预算保留</td><td>API</td><td>xla_je_funds_checker_pkg.reserve_funds</td></tr><tr><td>FA</td><td>获取资产折旧信息</td><td>API</td><td>fa_query_balances_pkg.query_balances</td></tr><tr><td>FA</td><td>资产报废</td><td>API</td><td>fa_retirement_pub.do_retirement</td></tr><tr><td>FA</td><td>资产转移</td><td>API</td><td>fa_transfer_pub.do_transfer</td></tr><tr><td>PO</td><td>接受数量</td><td>API</td><td>rcv_invoice_matching_sv.get_quantities</td></tr><tr><td>AR</td><td>收款冲销</td><td>API</td><td>ar_receipt_api_pub.reverse</td></tr><tr><td>BOM</td><td>判断工作日</td><td>API</td><td>bom_calendar_api_bk</td></tr><tr><td>PJM</td><td>创建seiban</td><td>API</td><td>pjm_seiban_pub.create_seiban</td></tr><tr><td>PJM</td><td>更新计划组</td><td>API</td><td>pjm_project_param_pub.update_planning_group</td></tr><tr><td>FND</td><td>设置并发请求对用户隐藏</td><td>API</td><td>fnd_request.set_options</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> EBS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle EBS R12 DBA</title>
      <link href="/2023/06/03/Oracle-EBS-R12-DBA/"/>
      <url>/2023/06/03/Oracle-EBS-R12-DBA/</url>
      
        <content type="html"><![CDATA[<h4 id="Oracle-索引的作用以及失效的情况"><a href="#Oracle-索引的作用以及失效的情况" class="headerlink" title="Oracle 索引的作用以及失效的情况"></a>Oracle 索引的作用以及失效的情况</h4><p>表索引是Oracle数据库中的一种面向查询的数据结构，用于加速查询操作，提高查询性能。索引可以理解为一个指向表中记录的指针列表，通过在查询时查找这些指针，可以快速定位符合条件的记录，避免全表扫描，从而提高查询效率。</p><p><strong>索引的作用：</strong></p><ol><li>提高查询速度：索引通过快速地查找和访问表中符合特定条件的数据来加快 SQL 查询的速度。</li><li>优化查询计划：索引可以帮助数据库优化器确定最优的查询计划，降低查询复杂度，提高查询效率。</li><li>提高数据完整性：索引可以保证表中数据的唯一性和约束完整性，对于频繁更新的表尤为重要。</li><li>支持连接操作：索引可以帮助数据库支持连接操作，以提高查询效率。</li></ol><p>索引（Index）是 Oracle 数据库中用于加快数据检索速度的一种数据结构。它通过在数据库表中创建一个或多个索引来加速查询，并且可以提高 SQL 语句执行的效率。下面是索引的作用和失效的情况：</p><p><strong>索引失效的情况：</strong></p><ol><li>数据分布不均匀：索引失效的一个主要原因是数据分布不均匀。例如，如果表中某一列的值非常少时，使用索引可能比全表扫描更慢。</li><li>像操作非常频繁的表：如果一个表的操作频率非常高，那么建立索引会使得更新数据的成本极高，会降低整体的性能。</li><li>查询条件不在索引的列上：如果查询条件不在索引列上，则索引可能不起作用。在这种情况下，数据库可能会忽略索引，进行全表扫描，这将极大地降低性能。</li><li>使用函数处理查询条件：如果查询条件使用函数处理，则索引可能会失效。例如，如果查询条件为 <code>to_char(date_col,&#39;dd-mm-yyyy&#39;)=&#39;01-01-2022&#39;</code>，则索引上的 <code>date_col</code> 列可能会失效，因为查询条件需要进行函数处理。</li><li>数据量太小：在低记录数的表上创建索引是没有必要的，因为索引增加了开销和维护时间，而带来的好处相对较少。</li></ol><p>综上所述，要正确选择和使用索引来提高数据库的性能，需要根据具体的情况，进行测试和选择最优策略。</p><h4 id="Oracle-报文"><a href="#Oracle-报文" class="headerlink" title="Oracle 报文"></a>Oracle 报文</h4><p>对于开发报文，需要根据具体的应用场景和技术要求来确定，因此需要提供更详细的上下文。一般而言，开发报文可以分为前端和后端两部分，其中前端报文主要指前端请求后端的数据格式和数据内容，后端报文则指后端响应前端请求的数据格式和数据内容。下面是一个简单的示例：</p><ul><li>前端报文：采用 HTTP GET 请求方式，请求获取用户列表数据，请求 URL 为 <a href="http://example.com/api/user/list%EF%BC%8C%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E5%8C%85%E5%90%AB%E4%BB%A5%E4%B8%8B%E5%86%85%E5%AE%B9%EF%BC%9A">http://example.com/api/user/list，请求参数包含以下内容：</a></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;pageIndex&quot;: 1,</span><br><span class="line">   &quot;pageSize&quot;: 10,</span><br><span class="line">   &quot;sortField&quot;: &quot;name&quot;,</span><br><span class="line">   &quot;sortOrder&quot;: &quot;asc&quot;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>后端报文：后端通过解析前端请求参数，在数据库中查询符合条件的用户列表，并通过 JSON 格式返回给前端，示例响应报文如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;success&quot;: true,</span><br><span class="line">   &quot;message&quot;: null,</span><br><span class="line">   &quot;data&quot;: &#123;</span><br><span class="line">       &quot;total&quot;: 50,</span><br><span class="line">       &quot;pageIndex&quot;: 1,</span><br><span class="line">       &quot;pageSize&quot;: 10,</span><br><span class="line">       &quot;list&quot;: [</span><br><span class="line">           &#123;</span><br><span class="line">               &quot;id&quot;: 1,</span><br><span class="line">               &quot;name&quot;: &quot;Tom&quot;,</span><br><span class="line">               &quot;gender&quot;: &quot;male&quot;,</span><br><span class="line">               &quot;age&quot;: 25</span><br><span class="line">           &#125;,</span><br><span class="line">           &#123;</span><br><span class="line">               &quot;id&quot;: 2,</span><br><span class="line">               &quot;name&quot;: &quot;Jane&quot;,</span><br><span class="line">               &quot;gender&quot;: &quot;female&quot;,</span><br><span class="line">               &quot;age&quot;: 30</span><br><span class="line">           &#125;,</span><br><span class="line">           ...</span><br><span class="line">       ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，开发报文通常需要按照特定的技术规范或者标准进行设计，例如 RESTful API、GraphQL 等标准，以方便不同系统之间的交互和集成。</p><h4 id="Oracle-临时表"><a href="#Oracle-临时表" class="headerlink" title="Oracle 临时表"></a>Oracle 临时表</h4><p>一、存储空间</p><p>Oracle临时表不占用表空间，如果临时表（包括临时表的索引）没有指定表空间，那么插入临时表的数据会存放在临时表空间（TEMP）。</p><p>二、两种类型</p><p>Oracle临时表有两种类型：一种是会话级临时表，另一种是事物级临时表。</p><p>2.1、会话级临时表（SESSION）</p><p>临时表中的数据与会话相关，当前会话不退出临时表中的数据就存在，当前会话退出临时表中的数据就会截断（相当于 truncate table 当前会话的数据）。</p><p>一个会话看不到另外一个会话插入临时表中的数据，即两个不同会话的数据是互不干扰的。</p><p>创建会话级临时表语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE GLOBAL TEMPORARY TABLE table_name</span><br><span class="line"></span><br><span class="line">(col1 type1,col2 type2...) </span><br><span class="line"></span><br><span class="line">ON COMMIT PRESERVE ROWS;</span><br></pre></td></tr></table></figure><p>2.2、事务级临时表</p><p>临时表中的数据与事务相关，当进行事务提交（commit）或事务回滚（rollback）时，临时表中的数据就会截断（相当于 truncate table 当前事务的数据）。</p><p>其他功能与会话级临时表一致（包括退出会话时，事务级临时表也会截断）。</p><p>创建事务级临时表语法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE GLOBAL TEMPORARY TABLE table_name</span><br><span class="line"></span><br><span class="line">(col1 type1,col2 type2...)</span><br><span class="line"></span><br><span class="line">ON COMMIT DELETE ROWS;</span><br></pre></td></tr></table></figure><p>2.3、两种类型临时表的区别</p><p>（1）建表语法上，会话级临时表采用 ON COMMIT PRESERVE ROWS，而事务级临时表采用 ON COMMIT DELETE ROWS。</p><p>（2）用法上，会话级临时表只有当会话结束时，临时表中的数据才会被截断；而事务级临时表不管是事务提交（commit）、事务回滚（rollback）还是会话结束，临时表中的数据都会被截断</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Create table</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">global</span> temporary <span class="keyword">table</span> CUX.WIP_GA_AUTOTXN_JOBS_TEMP</span><br><span class="line">(</span><br><span class="line">  organization_id          NUMBER,</span><br><span class="line">  inventory_item_id        NUMBER,</span><br><span class="line">  item_number              VARCHAR2(<span class="number">40</span>),</span><br><span class="line">  description              VARCHAR2(<span class="number">240</span>),</span><br><span class="line">  item_revision            VARCHAR2(<span class="number">3</span>),</span><br><span class="line">  uom_code                 VARCHAR2(<span class="number">3</span>),</span><br><span class="line">  demand_quantity          NUMBER,</span><br><span class="line">  supply_subinventory      VARCHAR2(<span class="number">10</span>),</span><br><span class="line">  supp_subinv_quantity     NUMBER,</span><br><span class="line">  plan_issue_quantity      NUMBER,</span><br><span class="line">  material_subinventory    VARCHAR2(<span class="number">10</span>),</span><br><span class="line">  material_subinv_quantity NUMBER,</span><br><span class="line">  min_pack_mod             NUMBER,</span><br><span class="line">  lack_quantity            NUMBER,</span><br><span class="line">  txn_quantity             NUMBER</span><br><span class="line">)</span><br><span class="line"><span class="keyword">on</span> <span class="keyword">commit</span> preserve <span class="keyword">rows</span>;</span><br><span class="line"><span class="comment">-- Create/Recreate indexes </span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index CUX.WIP_GA_AUTOTXN_JOBS_TEMP_U1 <span class="keyword">on</span> CUX.WIP_GA_AUTOTXN_JOBS_TEMP (ORGANIZATION_ID, INVENTORY_ITEM_ID);</span><br></pre></td></tr></table></figure><h4 id="Oracle-GoldenGate"><a href="#Oracle-GoldenGate" class="headerlink" title="Oracle GoldenGate"></a>Oracle GoldenGate</h4><p>Oracle GoldenGate (OGG)是一种可靠的高性能数据复制和数据实时同步解决方案，可以在异构数据库和平台之间复制或同步数据。OGG可以将源数据库中的原始数据复制到目标数据库中，同时还可以实时捕获更改并将其应用于目标数据库，这使得用户可以实时访问最新的数据。OGG还支持一些高级功能，如数据筛选、数据转换和数据加密等，可以满足不同用户的需求。</p><h4 id="Oracle-DatabaseLink"><a href="#Oracle-DatabaseLink" class="headerlink" title="Oracle DatabaseLink"></a>Oracle DatabaseLink</h4><p>Database Link ，我们习惯称为db link。</p><p>作用：用于从a数据库到b数据库之间访问的一种手段。类似于 ogg 中的表同步（用户同步）。如上所述，dblink 的主要作用是跨库查询。</p><p>有很多业务都需要进行跨库查询。在我们公司有时就不得不去去创建一些dblink。 </p><p>优点：创建方式简单、易懂、可以拥有创建用户的所有权限。</p><p>缺点：自然，方便的手段就会有更多的不利。</p><p>1 大量消耗数据库资源；本地系统每通过DBLINK链接远端系统一次，都会生成一个本地session，如本地session不退出或者手动释放，只有通过session超时才能自动释放，会浪费大量的系统资源</p><p>2 容易出现数据库BUG：大量使用DBLINK，本地系统极易出现ORA-02068、ORA-03113、ORA-02080、ORA-02054、ORA-02050等ORACLE错误，这种错误大部分会影响当前session正在处理的业务</p><p>3 性能较差：由于使用DBLINK，本地系统在获取数据时，每次链接都会对远端数据库进行一次全表扫描，且所有数据都会传输回本地数据库内，导致性能降低并且严重浪费当前系统资源。尤其出现一条sql语句从两个DBLINK中取数，更被称之为“性能杀手”，尤其是OLTP型数据库</p><p>4 数据传输不稳定，占用带宽严重，容易产生丢包风险：DBLINK本身没有数据存储、监控等功能，是通过网络中的数据库进行传输时，如果在传输过程中出现数据丢包现象，DBLINK本身不会发现，只用当业务进行完毕才能发现丢包现象，这样会影响当前正在处理的业务；另外，通过DBLINK查询的数据会像数据全部传至本地数据库进行操作，数据传输量很大，占用带宽严重，可能会导致网络堵塞</p><p>5 Oracle数据功能受限：DBLINK本身不支持对oracle LOB大对象的操作，在使用PROCDURE时，使用COMMIT等操作时可能会出现错误</p><p>6 可扩展性较差：如果多系统之间 使用DBLINK进行传输，每增加一个系统，都会增加一个或多个DBLINK链接或者修改对应的接口程序，如果修改其中一个接口，需要修改所有关联系统内的接口程序</p><p>7 维护性差、安全性较低：通过DBLINK进行链接需要将远端数据库用户名、密码、IP地址存在本地数据库，如远端进行密码修改、IP地址变更，本地数据库也需要修改，如果系统较多，每个系统都需要同时修改。切本地数据库管理员能够看到远端数据的密码、IP地址，对系统安全产生影响</p><p>可是，即使是在缺点这么这么多的情况下，还是会有人用，归根到底，个人感觉还是oracle对两个库之间的交互做的并不是特别好，OGG 好用是好用，但是在表多的情况下，我们可是深受其害。</p><p>用法：创建dblink的先决条件便是两个库要能交互（local database to remote database）网络要能连接正常，其次。要在源端数据库tnsname 文件中配置上访问目标的参数。并且能 tnsping 通。</p><p>database link 分为两种：一种为 public（公有） 一种为 private（个人）。顾名思义，公有dblink即源库所有的用户都可以使用，个人dblink则只有创建者用户可以使用。</p><p>创建dblink是要有相应的权限的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from user_sys_privs where privilege like upper(&#x27;%LINK%&#x27;);</span><br></pre></td></tr></table></figure><pre><code>   USERNAME    PRIVILEGE    ADMIN_OPTION    COMMON   APPS        CREATE PUBLIC DATABASE LINK      NO    NO   APPS        CREATE DATABASE LINK          NO    NO</code></pre><p>CREATE DATABASE LINK 为创建个人dblink权限。</p><p>CREATE PUBLIC DATABASE LINK 为创建公有dblink 权限。</p><p><strong>创建dblink</strong> </p><p>当tnsnames中有了参数。且有了相应的权限之后，就可以创建dblink。创建方式有以下几种。</p><p>创建个人dblink语句为 CREATE database link 开头：</p><p>使用当前用户的用户名和密码去连接远程数据库。如果密码不对会报错</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database link test1 using &#x27;test&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建公有dblink语句CREATE PUBLIC database link</p><p>使用指定的用户和密码创建公有 dblink </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create public database link test3 connect to scott identified by tiger using &#x27;test&#x27;;</span><br></pre></td></tr></table></figure><p>建一个shared 的数据库连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create shared public database link test4 connect to scott identified by &quot;tiger&quot; authenticated by username identified by &quot;passwd&quot; using &#x27;test&#x27;;</span><br></pre></td></tr></table></figure><p>使用shared方式的 database link是数据库会限制到远程数据库的连接的数量,这样以避免过多的连接对远程数据库造成太大的压力。</p><p>还有一种创建方式是不使用tnsname的情况</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> database link link_name</span><br><span class="line"></span><br><span class="line"><span class="keyword">CONNECT</span> <span class="keyword">TO</span> <span class="keyword">user</span> IDENTIFIED <span class="keyword">BY</span> screct</span><br><span class="line"></span><br><span class="line"><span class="keyword">USING</span> <span class="string">&#x27;(DESCRIPTION =</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">(ADDRESS_LIST =</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">(ADDRESS = (PROTOCOL = TCP)(HOST = ip)(PORT = 1521))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">(CONNECT_DATA =</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">(SERVICE_NAME = sales)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">)&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>删除dblink</strong> </p><p>首先需要查询出来有哪些dblink </p><p>select owner,object_name from dba_objects where object_type=’DATABASE LINK’; </p><p>然后如果为pubilc 则删除方式为 drop public database link </p><p>如果为个人则删除方式为：drop database link</p><p>其实本质上来说，dblink 并不是一个很复杂的东西。但是鉴于对数据库的影响。本着能少用就少用的原则。如果能用一些导入导出去替换dblink（我们也正在这么做）是最好的。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE LINK erp_to_tms.INVT.COM.CN </span><br><span class="line"><span class="keyword">CONNECT</span> <span class="keyword">TO</span> invt IDENTIFIED <span class="keyword">by</span>   invt</span><br><span class="line"><span class="keyword">using</span> <span class="string">&#x27;(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=192.168.0.94)(PORT=1521))) (CONNECT_DATA=(SERVICE_NAME=TMS)))&#x27;</span>;</span><br><span class="line"><span class="comment">-----------------------------------------------------------</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE LINK OA.INVT.COM.CN</span><br><span class="line"><span class="keyword">CONNECT</span> <span class="keyword">TO</span> invt IDENTIFIED <span class="keyword">by</span>   invt</span><br><span class="line"><span class="keyword">using</span> <span class="string">&#x27;(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=192.168.1.29)(PORT=1521))) (CONNECT_DATA=(SERVICE_NAME=invtoa)))&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="Oracle-物化视图"><a href="#Oracle-物化视图" class="headerlink" title="Oracle 物化视图"></a>Oracle 物化视图</h4><p>一、与普通视图的区别</p><p>普通视图是虚拟表，不能创建索引，任何对视图的查询，Oracle都将转换为对视图SQL语句的查询，这样对整体查询性能的提升，并没有实质上的好处。但同时普通视图也不会占用存储空间。</p><p>物化视图可以看作是一种特殊的物理表（可以从 dba_tables 查询出来），可以创建索引，提升查询性能。但同时物化视图也会占用存储空间（可以从 dba_segment 查询出来）。</p><p>二、创建或删除物化视图</p><p>语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--创建物化视图</span><br><span class="line"></span><br><span class="line">CREATE MATERIALIZED VIEW [mview_name]</span><br><span class="line"></span><br><span class="line">REFRESH [FAST|COMPLETE|FORCE]</span><br><span class="line"></span><br><span class="line">[ON COMMIT|ON DEMAND|START WITH (start_time) NEXT (next_time)]</span><br><span class="line"></span><br><span class="line">AS</span><br><span class="line"></span><br><span class="line">&#123;创建物化视图使用的SQL查询语句&#125;;</span><br><span class="line"></span><br><span class="line">--删除物化视图</span><br><span class="line">DROP MATERIALIZED VIEW mview_name;</span><br></pre></td></tr></table></figure><p>举例:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--创建测试主表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cux_test_table</span><br><span class="line"></span><br><span class="line">(</span><br><span class="line"></span><br><span class="line"> test_id  NUMBER,</span><br><span class="line"></span><br><span class="line"> test_code VARCHAR2(<span class="number">10</span>),</span><br><span class="line"></span><br><span class="line"> test_desc VARCHAR2(<span class="number">100</span>),</span><br><span class="line"></span><br><span class="line"> test_date <span class="type">DATE</span></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">--如果是创建增量刷新的物化视图，主表必须有主键</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--如果是创建其他刷新方式的物化视图，主表有无主键均可</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> cux_test_table <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> cux_test_table_pk <span class="keyword">PRIMARY</span> KEY (test_id);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">--如果是创建增量刷新的物化视图，必须创建物化视图日志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--如果是创建其他刷新方式的物化视图，无需创建物化视图日志</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> MATERIALIZED <span class="keyword">VIEW</span> LOG <span class="keyword">ON</span> cux_test_table;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">--创建测试物化视图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--每天凌晨1点增量刷新</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> MATERIALIZED <span class="keyword">VIEW</span> cux_test_mv</span><br><span class="line"></span><br><span class="line">REFRESH FAST</span><br><span class="line"></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">WITH</span> SYSDATE NEXT TRUNC(SYSDATE<span class="operator">+</span><span class="number">1</span>) <span class="operator">+</span> <span class="number">1</span> <span class="operator">/</span> <span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> test_id, test_code, test_desc, test_date <span class="keyword">FROM</span> cux_test_table;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">--删除测试物化视图</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> MATERIALIZED <span class="keyword">VIEW</span> cux_test_mv;</span><br></pre></td></tr></table></figure><p>物化视图刷新方式有三种：fast（增量刷新）、complete（全量刷新）、force（默认）。</p><p>3.1、fast- 增量刷新</p><p>使用增量刷新方式必须满足两个条件：</p><p>（1）主表必须有主键；</p><p>ALTER TABLE table_name ADD CONSTRAINT primary_name PRIMARY KEY (column_name);</p><p>（2）必须创建物化视图日志，用于存放主表数据变化。</p><p>CREATE MATERIALIZED VIEW LOG ON （主表名）;</p><p>创建物化视图日志后会生成表 mlog$_主表名，主表数据变化会存放在这张表里。</p><p>3.2、complete - 全量刷新</p><p>3.3、 force - 默认</p><p>不指定刷新方式或指定刷新方式为force时，当可以使用fast方式刷新时，采用fast，否则采用complete。</p><p>四、刷新触发机制</p><p>物化视图刷新触发机制有三种：on commit、on demand、start with (start_time) next (next_time)。</p><p>4.1、on commit</p><p>当主表数据提交时，刷新物化视图。</p><p>4.2、on demand</p><p>需要刷新时再刷新，通过调用 dbms_mview.refresh 进行刷新，举例如下:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--增量刷新</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line"> dbms_mview.refresh(list =&gt; &#x27;CUX_TEST_MV&#x27;, method =&gt; &#x27;FAST&#x27;);</span><br><span class="line"></span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">--全量刷新</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line"> dbms_mview.refresh(list =&gt; &#x27;CUX_TEST_MV&#x27;, method =&gt; &#x27;COMPLETE&#x27;);</span><br><span class="line"></span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">--默认</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line"> dbms_mview.refresh(list =&gt; &#x27;CUX_TEST_MV&#x27;);</span><br><span class="line"></span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>4.3、start with (start_time) next (next_time)</p><p>从指定时间开始，每隔一段时间（由next指定）刷新一次。</p><p>五、相关查询SQL</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM dba_tables t WHERE t.table_name = &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM dba_segments s WHERE s.segment_name = &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM dba_mviews m WHERE m.mview_name = &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM dba_mview_refresh_times t WHERE t.name = &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM dba_mview_analysis a WHERE a.mview_name = &#x27;&#x27;;</span><br><span class="line"></span><br><span class="line">SELECT * FROM mlog$_主表名; --物化视图日志</span><br><span class="line"></span><br><span class="line">SELECT * FROM dba_mview_logs l WHERE l.log_table = &#x27;MLOG$_主表名&#x27;;</span><br></pre></td></tr></table></figure><h4 id="Oracle-userenv-‘LANG’"><a href="#Oracle-userenv-‘LANG’" class="headerlink" title="Oracle userenv(‘LANG’)"></a>Oracle userenv(‘LANG’)</h4><p>该语句用于获取当前用户会话的语言设置。具体来说，它返回一个字符串，该字符串表示用户会话的数据库语言环境。Oracle数据库支持多种语言，因此用户可以根据需要设置自己的语言环境。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> otta.order_category_code</span><br><span class="line">  <span class="keyword">FROM</span> oe_transaction_types_tl ottt, oe_transaction_types_all otta</span><br><span class="line"> <span class="keyword">WHERE</span> ottt.transaction_type_id <span class="operator">=</span> otta.transaction_type_id</span><br><span class="line">   <span class="keyword">AND</span> ottt.language <span class="operator">=</span> userenv(<span class="string">&#x27;LANG&#x27;</span>)</span><br><span class="line"><span class="keyword">AND</span> otta.transaction_type_code <span class="operator">=</span> <span class="string">&#x27;ORDER&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="Oracle-SYNONYM-的作用"><a href="#Oracle-SYNONYM-的作用" class="headerlink" title="Oracle SYNONYM 的作用"></a>Oracle SYNONYM 的作用</h4><p>在 Oracle 数据库中，SYNONYM（同义词）是指数据库中的对象名称的替代名称。Synonym 在 Oracle 中的作用有以下几个方面：</p><ol><li><p>简化 SQL Query：通过创建 SYNONYM，我们可以为某个对象（如表、视图、存储过程等）指定一个别名。这个别名可以直接在 SQL 查询中使用，从而简化了 SQL 查询的语法。例如，如果您创建了一个名为 emp 的表的同义词 emp_table，那么您可以使用以下语句来查询该表：<code>SELECT * FROM emp_table;</code></p></li><li><p>提高程序稳定性：如果您将程序的连接字符串或其他配置信息编码到程序代码中，那么每当您更改连接字符串或其他配置信息时，都需要更新程序代码。通过使用同义词，您可以将连接字符串编码为单个对象，仅在需要更改连接字符串时更改该对象，无需修改程序代码。</p></li><li><p>管理权限：通过分配 SYNONYM 权限，您可以控制用户对特定对象的访问权限。例如，如果您不希望用户直接访问某个表，可以创建一个同义词，然后授予用户对同义词的 SELECT、INSERT、UPDATE 和 DELETE 权限，而不是对表本身的权限。这样可以更好地控制用户对数据的访问权限。</p></li></ol><p>总的来说，SYNONYM 在 Oracle 中具有重要的作用，可以帮助您更好地管理数据库对象并简化 SQL 查询语法。</p><h4 id="Oracle-EXISTS"><a href="#Oracle-EXISTS" class="headerlink" title="Oracle EXISTS"></a>Oracle EXISTS</h4><p>在 Oracle 数据库中，EXISTS 是一个条件运算符，用于测试查询结果是否存在。具体来说，它通常用于子查询中，以确定主查询结果集中是否存在与子查询匹配的数据。</p><p>EXISTS 的语法如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name1, column_name2, ... <span class="keyword">FROM</span> table_name1 <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> table_name2 <span class="keyword">WHERE</span> <span class="keyword">condition</span>);</span><br></pre></td></tr></table></figure><p>其中，table_name1 是主查询的表名，table_name2 是子查询的表名，condition 是子查询的条件。如果子查询返回至少一行，那么 EXISTS 运算符返回 TRUE，否则返回 FALSE。</p><p>例如，如果您需要查找所有员工至少在一个项目中工作过：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees e <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> projects p <span class="keyword">WHERE</span> p.employee_id <span class="operator">=</span> e.employee_id);</span><br></pre></td></tr></table></figure><p>这个查询将返回所有在项目中工作过的员工的记录。子查询 <code>SELECT 1 FROM projects p WHERE p.employee_id = e.employee_id</code> 检查对象projects中是否存在具有匹配employee_id的记录。如果匹配，则EXISTS返回 TRUE，查询将返回主查询中与存在记录相匹配的记录。</p><p>请注意，EXISTS 运算符可以更高效地进行比大多数 JOIN 操作，因为它只需查找匹配记录的存在性，而不是查找整个结果集。</p><h4 id="Oracle-EBS-fnd-global-apps-initialize"><a href="#Oracle-EBS-fnd-global-apps-initialize" class="headerlink" title="Oracle  EBS fnd_global.apps_initialize"></a>Oracle  EBS fnd_global.apps_initialize</h4><p>“fnd_global.apps_initialize”是Oracle E-Business Suite中的一个函数，它用于初始化当前会话的应用程序上下文。该函数通常在应用程序代码中的存储过程或函数中使用，以便在会话开始时设置正确的应用程序上下文。</p><p>在调用该函数之前，必须先设置应用程序ID（即”fnd_global.apps_initialize”函数的第一个参数）和用户ID（即”fnd_global.apps_initialize”函数的第二个参数）。这通常是通过将这些值分配给PL/SQL变量来完成的，然后传递给函数作为参数使用。</p><p>例如，以下是在Oracle E-Business Suite中使用”fnd_global.apps_initialize”函数的示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">  l_user_id       NUMBER;</span><br><span class="line">  l_resp_id       NUMBER;</span><br><span class="line">  l_resp_appl_id  NUMBER;</span><br><span class="line">  l_app_id        NUMBER;</span><br><span class="line">BEGIN</span><br><span class="line">  -- Set the application ID and user ID</span><br><span class="line">  l_app_id := 123; -- Replace with a valid application ID</span><br><span class="line">  l_user_id := 456; -- Replace with a valid user ID</span><br><span class="line"></span><br><span class="line">  -- Call fnd_global.apps_initialize to initialize the application context</span><br><span class="line">  fnd_global.apps_initialize(l_user_id, l_resp_id, l_resp_appl_id, l_app_id);</span><br><span class="line"></span><br><span class="line">  -- Your code here...</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><h4 id="Oracle-EBS-mo-global-set-policy-context"><a href="#Oracle-EBS-mo-global-set-policy-context" class="headerlink" title="Oracle EBS mo_global.set_policy_context"></a>Oracle EBS mo_global.set_policy_context</h4><p><code>mo_global.set_policy_context</code>是Oracle E-Business Suite中的一个函数，用于设置安全策略上下文。该函数接受两个参数，第一个参数是策略类型，第二个参数是策略值。</p><p><code>mo_global.set_policy_context</code>函数通常用于设置多组织或多安全上下文。在多组织环境中，该函数可以用于设置当前会话的组织上下文，以实现对特定组织的访问控制。在多安全上下文中，该函数可以用于设置当前会话的权限范围，以实现对特定功能或数据的访问控制。</p><p>下面是一些示例：</p><ol><li><p>设置当前会话的组织上下文：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mo_global.set_policy_context(<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;123&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ol><p>  这将会将当前会话的组织上下文设置为组织123，以实现对组织123的访问控制。</p><ol start="2"><li>设置当前会话的安全上下文：</li></ol>  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mo_global.set_policy_context(<span class="string">&#x27;FND_RESPONSIBILITY_ID&#x27;</span>, <span class="string">&#x27;10001&#x27;</span>);</span><br></pre></td></tr></table></figure><p>  这将会将当前会话的Responsibility ID设置为10001，以实现对特定功能或数据的访问控制。</p><p>总的来说，<code>mo_global.set_policy_context</code>函数是Oracle E-Business Suite中的一个非常有用的函数，可以用于实现访问控制、安全策略管理和权限管理等功能。</p><h4 id="Oracle-EBS-fnd-request-submit-request"><a href="#Oracle-EBS-fnd-request-submit-request" class="headerlink" title="Oracle EBS fnd_request.submit_request"></a>Oracle EBS fnd_request.submit_request</h4><p>在 Oracle EBS 中，fnd_request.submit_request 是一个 PL/SQL 过程，它用于提交标准并发程序或请求组。该过程允许并发程序在后台运行，从而避免阻塞前端用户界面，以提高用户体验。</p><p>fnd_request.submit_request 过程的语法如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">fnd_request.submit_request (application <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;应用系统&#x27;</span>,</span><br><span class="line">                            program     <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;程序名称&#x27;</span>,</span><br><span class="line">                            description <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;程序描述&#x27;</span>,</span><br><span class="line">                            start_time  <span class="operator">=</span><span class="operator">&gt;</span> SYSDATE,</span><br><span class="line">                            sub_request <span class="operator">=</span><span class="operator">&gt;</span> <span class="literal">FALSE</span>,</span><br><span class="line">                            argument1   <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;参数值1&#x27;</span>,</span><br><span class="line">                            argument2   <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;参数值2&#x27;</span>...);</span><br></pre></td></tr></table></figure><p>该过程的参数解释如下：</p><ul><li>application：必填项，表示要运行的应用程序的名称；</li><li>program：必填项，表示要运行的程序的名称；</li><li>description：可选项，表示任务的描述；</li><li>start_time：可选项，表示要求任务执行的时间；</li><li>sub_request：可选项，表示此任务是否应该作为另一个任务的子任务；</li><li>argument1、argument2 等：可选项，表示程序执行所需的参数值。</li></ul><p>当 fnd_request.submit_request() 函数被调用时，它将创建一个新的并发请求，将其插入 fnd_concurrent_requests 表中，并将参数值传递给并发程序进行处理。</p><p>在使用 fnd_request.submit_request() 函数时，需要注意以下几点：</p><ol><li>确保程序名称和应用程序名称正确；</li><li>确保参数的顺序和类型与程序定义的参数一致；</li><li>如果程序需要使用值集，需要将该值集注册到数据库中；</li><li>如果需要预览并发程序输出，则必须在程序源代码中使用 FND_FILE.PUT 或 FND_FILE.PUT_LINE 函数将输出写入到输出文件中。</li></ol><p>总的来说，fnd_request.submit_request() 函数是 Oracle EBS 中一个非常有用的函数，它可以帮助将并发请求发送到后台，并且具有很高的灵活性和可定制性。</p><p>Oracle fnd_request.submit_request 函数是用于向Oracle Applications程序提交并执行请求的。该函数返回一个唯一标识符作为参数，可以用作获取请求执行状态和结果的参考。</p><p>通常情况下，可以将该参数传递给 FND_CONCURRENT.wait_for_request 函数。该函数将等待直到请求执行完成，并返回请求的状态和结果。</p><p>示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE</span><br><span class="line"> l_request_id NUMBER;</span><br><span class="line">BEGIN</span><br><span class="line"> l_request_id := fnd_request.submit_request(&#x27;XXMYPACKAGE&#x27;, &#x27;XX_MY_REQUEST&#x27;, NULL, NULL, FALSE, NULL, NULL);</span><br><span class="line"> dbms_output.put_line(&#x27;Request ID: &#x27; || l_request_id);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>该代码向 Oracle Applications 提交一个名为 XX_MY_REQUEST 的请求，并将返回的请求ID打印到输出窗口中。</p><h4 id="Oracle-EBS-oe-order-pub-header-rec-type"><a href="#Oracle-EBS-oe-order-pub-header-rec-type" class="headerlink" title="Oracle EBS oe_order_pub.header_rec_type"></a>Oracle EBS oe_order_pub.header_rec_type</h4><p><code>oe_order_pub.header_rec_type</code> 是一个记录类型 (record type)，在 Oracle E-Business Suite (EBS) 中的订单管理模块中定义，用于存储订单头信息。这个记录类型包括以下字段：</p><ul><li><code>order_number</code>：订单号</li><li><code>order_type_id</code>：订单类型 ID</li><li><code>order_date</code>：订单日期</li><li><code>ordered_by</code>：下单人员工号</li><li><code>sold_to_org_id</code>：销售组织 ID</li><li><code>bill_to_org_id</code>：账单组织 ID</li><li><code>ship_to_org_id</code>：发货组织 ID</li><li><code>order_source_id</code>：订单来源 ID</li><li><code>po_number</code>：采购订单号</li><li><code>cust_po_number</code>：客户采购订单号</li><li><code>transaction_type_id</code>：交易类型 ID</li><li><code>term_id</code>：付款条件 ID</li></ul><p>使用 <code>oe_order_pub.header_rec_type</code> 和相关的 API，可以在 EBS 中创建、修改和查询订单头信息。</p><h4 id="Oracle-EBS-oe-order-pub-line-tbl-type"><a href="#Oracle-EBS-oe-order-pub-line-tbl-type" class="headerlink" title="Oracle EBS oe_order_pub.line_tbl_type"></a>Oracle EBS oe_order_pub.line_tbl_type</h4><p><code>oe_order_pub.line_tbl_type</code> 是一个自定义的 Oracle E-Business Suite 记录类型 (record type)，用于存储订单行 (order line) 信息。这个记录类型定义了一个包含多个订单行记录的表格类型 (table type)。每个订单行记录包括以下字段：</p><ul><li><code>line_id</code>：订单行 ID</li><li><code>line_number</code>：订单行号</li><li><code>inventory_item_id</code>：存货项 (inventory item) ID</li><li><code>ordered_quantity</code>：订购数量</li><li><code>unit_selling_price</code>：销售单价</li><li><code>line_type_id</code>：订单行类型 ID</li><li><code>ship_from_org_id</code>：发货组织 ID</li><li><code>ship_to_org_id</code>：发货到的组织 ID</li><li><code>schedule_ship_date</code>：计划发货日期</li><li><code>request_date</code>：需求日期</li><li><code>flow_status_code</code>：流程状态代码</li></ul><p>在 Oracle E-Business Suite 中的订单管理模块中，<code>oe_order_pub.line_tbl_type</code> 可以和相关的 API 一起使用，实现订单行的创建、修改和查询等操作。</p><h4 id="Oracle-EBS-oe-order-pub-request-tbl-type"><a href="#Oracle-EBS-oe-order-pub-request-tbl-type" class="headerlink" title="Oracle EBS oe_order_pub.request_tbl_type"></a>Oracle EBS oe_order_pub.request_tbl_type</h4><p><code>oe_order_pub.request_tbl_type</code> 是一个记录类型 (record type)，在 Oracle E-Business Suite (EBS) 中的订单管理模块中定义，用于存储订单请求 (order request) 记录。这个记录类型定义了一个包含多个订单请求记录的表格类型 (table type)，每个订单请求记录包括以下字段：</p><ul><li><code>header_id</code>：订单头 ID</li><li><code>line_id</code>：订单行 ID</li><li><code>request_type</code>：请求类型</li><li><code>quantity</code>：请求数量</li><li><code>flow_status_code</code>：请求流程状态代码</li><li><code>request_date</code>：请求日期</li></ul><p>在 EBS 中，可以通过 <code>oe_order_pub.request_tbl_type</code> 和相关的 API 访问这个记录类型，实现订单请求的创建、更新和查询等操作。</p><h4 id="Oracle-EBS-oe-order-pub-g-miss-header-rec"><a href="#Oracle-EBS-oe-order-pub-g-miss-header-rec" class="headerlink" title="Oracle EBS oe_order_pub.g_miss_header_rec"></a>Oracle EBS oe_order_pub.g_miss_header_rec</h4><p><code>oe_order_pub.g_miss_header_rec</code> 是 Oracle E-Business Suite 的一个公共包（public package），包含一个全局的变量 <code>g_miss_header_rec</code>。该全局变量的数据类型是订单头信息的记录（record），用于存储 Oracle Order Entry (OE) 订单处理的丢失头信息。</p><p>当调用订单处理API时，如果订单的头信息缺失，会将缺失的头信息存储到 <code>g_miss_header_rec</code> 变量中。在处理缺失头信息时，可以使用 <code>g_miss_header_rec</code> 中存储的数据进行处理，避免出现错误。</p><p>需要注意的是，这个包是 Oracle E-Business Suite 内部使用的，如果不是很熟悉订单处理的细节，建议不要随意修改该包中的代码或者变量。</p><h4 id="Oracle-EBS-oe-msg-pub-initialize"><a href="#Oracle-EBS-oe-msg-pub-initialize" class="headerlink" title="Oracle EBS oe_msg_pub.initialize"></a>Oracle EBS oe_msg_pub.initialize</h4><p><code>oe_msg_pub.initialize</code> 是 Oracle EBS (E-Business Suite) 中的一个 PL/SQL 过程，用于初始化消息管理器（Message Manager）。它将创建一个用于存储消息信息的临时表，以及一些提示性数据提供给消息管理器使用。</p><p>在 Oracle EBS 中，<code>oe_msg_pub.initialize</code> 通常在自定义开发中的交易性代码中使用，以实现在订单管理模块中发送消息给用户。它可以用于将消息文本、语言代码、消息类型、消息级别等信息存储在数据库中，以便稍后在用户界面中显示。</p><p>例如，以下是一个使用 <code>oe_msg_pub.initialize</code> 过程初始化消息管理器和发送消息的示例代码片段：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">oe_msg_pub.initialize;</span><br><span class="line">oe_msg_pub.set_name(&#x27;XX_MY_CUSTOM_MSG&#x27;);</span><br><span class="line">oe_msg_pub.set_application(&#x27;OE&#x27;);</span><br><span class="line">oe_msg_pub.set_message_number(&#x27;12345&#x27;);</span><br><span class="line">oe_msg_pub.set_default_language(&#x27;US&#x27;);</span><br><span class="line">oe_msg_pub.set_text(&#x27;Your order has been processed successfully.&#x27;);</span><br><span class="line">oe_msg_pub.set_explanation(&#x27;This message indicates that your order has been successfully processed by our system.&#x27;);</span><br><span class="line">oe_msg_pub.set_type(&#x27;I&#x27;);</span><br><span class="line">oe_msg_pub.set_level(&#x27;5&#x27;);</span><br><span class="line">oe_msg_pub.show;</span><br></pre></td></tr></table></figure><p>这段代码将初始化消息管理器，设置一个消息名称为 <code>XX_MY_CUSTOM_MSG</code>，其他相关消息内容，然后将该消息显示给用户。</p><h4 id="Oracle-EBS-dbms-output-enable-1000000"><a href="#Oracle-EBS-dbms-output-enable-1000000" class="headerlink" title="Oracle EBS dbms_output.enable(1000000)"></a>Oracle EBS dbms_output.enable(1000000)</h4><p>这是一条PL/SQL代码，用于激活Oracle数据库中的dbms_output模块并设置输出缓冲区大小为1000000个字符。这样可以在SQL Developer或SQL*Plus等工具中实现大容量的输出。例如，当我们在PL/SQL中使用dbms_output.put_line()语句输出大量数据时，如果没有启用dbms_output模块或者缓冲区设置过小，可能会导致输出被截断或者不完全显示。因此，通过使用dbms_output.enable()函数并设置合适的缓冲区大小，可以避免这类问题。</p><h4 id="Oracle-EBS-oe-holds-pvt"><a href="#Oracle-EBS-oe-holds-pvt" class="headerlink" title="Oracle EBS oe_holds_pvt"></a>Oracle EBS oe_holds_pvt</h4><p>Oracle的oe_holds_pvt是一个PL/SQL包，用于支持订单管理中的暂挂功能。当一个订单被暂挂时，它不能被释放或出货，直到暂挂被取消或过期。oe_holds_pvt包提供了以下子程序：</p><ul><li>set_hold：在订单上设置暂挂。</li><li>release_hold：释放给定订单上的暂挂。</li><li>expire_hold：将在给定时间之前设置的暂挂过期。如果没有指定时间，则将所有过期暂挂释放。</li><li>check_if_order_held：检查给定订单是否有暂挂设置。</li><li>check_hold_expiry：检查给定的暂挂是否已过期。</li></ul><p>oe_holds_pvt包是Oracle E-Business Suite中订单管理模块的一部分，因此它只适用于这个特定的系统。</p><p><strong>举例：</strong></p><p>–多张销售订单批量暂挂OE_HOLDS_PVT.process_apply_holds_orders </p><p>–多个销售订单行暂挂OE_HOLDS_PVT.process_apply_holds_lines</p><h4 id="Oracle-EBS-setContext-retcode-errbuf"><a href="#Oracle-EBS-setContext-retcode-errbuf" class="headerlink" title="Oracle EBS  setContext(retcode, errbuf)"></a>Oracle EBS  setContext(retcode, errbuf)</h4><p>这是一个在Oracle数据库中设置上下文的函数。它需要两个参数：</p><ol><li>retcode：表示操作的返回代码（通常是整数或枚举类型）。</li><li>errbuf：表示操作返回的错误信息（通常是字符串）。</li></ol><p>setContext函数的作用是设置在当前数据库会话中可以用来共享信息的上下文。它在存储过程和函数中被广泛使用，可以用来保存以后可以在同一会话中使用的数据。 可以根据设置的上下文来处理不同的逻辑，从而实现不同的业务需求。</p><h4 id="Oracle-EBS-FND-FILE-OUTPUT"><a href="#Oracle-EBS-FND-FILE-OUTPUT" class="headerlink" title="Oracle EBS FND_FILE.OUTPUT"></a>Oracle EBS FND_FILE.OUTPUT</h4><p>FND_FILE.OUTPUT 是 Oracle E-Business Suite 中的一个会话全局属性，可以用于将输出信息发送到标准 EBS 输出窗口和日志文件。在 EBS 中，默认情况下，标准输出设备是标准输出窗口，而日志文件通常是 $APPLCSF/$APPLLOG，其中 $APPLCSF 和 $APPLLOG 是应用程序上下文文件系统的环境变量。</p><p>以下是一个简单的示例，展示如何在 EBS 中使用 FND_FILE.OUTPUT 输出信息：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">FND_FILE.OUTPUT(<span class="string">&#x27;This is a test message.&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在这个例子中，FND_FILE.OUTPUT 将字符串 ‘This is a test message.’ 发送到标准 EBS 输出设备和日志文件。</p><p>需要注意的是，在使用 FND_FILE.OUTPUT 时，需要使用 FND_FILE.ENABLE 来启用输出功能，并确保应用程序的日志文件和输出设备具有足够的权限和空间。同时，在实际应用程序中，可以根据需要将输出信息包装为相应的格式，并加入应用程序特定的状态和处理信息。</p><p>总之，FND_FILE.OUTPUT 是 Oracle E-Business Suite 中的一个重要会话全局属性，可用于发送输出信息到标准输出设备和日志文件。在使用这个功能时，需要注意权限、空间和格式等方面的问题，并根据实际情况将具体的应用程序状态和处理信息输出到文件中。</p><h4 id="Oracle-EBS-FND-FILE-OUTPUT-1"><a href="#Oracle-EBS-FND-FILE-OUTPUT-1" class="headerlink" title="Oracle EBS  FND_FILE.OUTPUT"></a>Oracle EBS  FND_FILE.OUTPUT</h4><p>FND_FILE.PUT_LINE 是 Oracle E-Business Suite (EBS) 应用程序中的一种过程，可以用于在应用程序日志和输出文件中写入一行信息和错误信息。在 EBS 中，FND_FILE.PUT_LINE 通常与 FND_FILE.OPEN 和 FND_FILE.CLOSE 一起使用，以便在日志中写入应用程序的运行状态和处理信息。</p><p>以下是一个简单的示例，展示如何在 EBS 中使用 FND_FILE.PUT_LINE 写入日志信息：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line"></span><br><span class="line">  log_file utl_file.file_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">  log_file :<span class="operator">=</span> fnd_file.open(<span class="string">&#x27;/u02/app/test/logs/mylog.txt&#x27;</span>, <span class="string">&#x27;W&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  fnd_file.put_line(log_file, <span class="string">&#x27;Start process at &#x27;</span> <span class="operator">||</span> to_char(sysdate, <span class="string">&#x27;YYYY-MM-DD HH24:MI:SS&#x27;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- ... 运行其他处理 ...</span></span><br><span class="line"></span><br><span class="line">  fnd_file.put_line(log_file, <span class="string">&#x27;End process at &#x27;</span> <span class="operator">||</span> to_char(sysdate, <span class="string">&#x27;YYYY-MM-DD HH24:MI:SS&#x27;</span>));</span><br><span class="line"></span><br><span class="line">  fnd_file.close(log_file);</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>这个 PL/SQL 块将打开一个名为 <code>/u02/app/test/logs/mylog.txt</code> 的日志文件，并使用 FND_FILE.PUT_LINE 打印一些开始和结束日志信息。在实际应用程序中，可以根据需要将这些信息替换为实际的应用程序状态和处理信息。</p><p>需要注意的是，在使用 FND_FILE.PUT_LINE 时，还需要特别注意文件权限和文件清理等问题。例如，确保应用程序具有足够的权限来写入和访问指定的日志文件，以及定期清理过期日志文件，避免文件占用空间过多而影响应用程序性能和稳定性。</p><p>总之，FND_FILE.PUT_LINE 是 Oracle E-Business Suite 应用程序中的一种过程，用于在日志文件中写入一行信息和错误信息。在使用这个函数时，需要注意文件权限和清理等问题，并根据实际情况将具体的应用程序状态和处理信息写入日志中。</p><h4 id="Oracle-TYPE-IS-RECORD"><a href="#Oracle-TYPE-IS-RECORD" class="headerlink" title="Oracle  TYPE IS RECORD"></a>Oracle  TYPE IS RECORD</h4><p>“Oracle TYPE IS RECORD” 的意思是在Oracle数据库中定义一个类型(type)，这个类型包含多个字段(field)，用于组合一组数据，并使用关键字 “record” 表示这个类型是一个记录类型。记录类型用来定义简单数据类型或者复杂数据类型，并可以用于存储单个或多个相关的数据元素。</p><h4 id="Oracle-TYPE-IS-TABLE-OF-INDEX-BY-BINARY-INTEGER"><a href="#Oracle-TYPE-IS-TABLE-OF-INDEX-BY-BINARY-INTEGER" class="headerlink" title="Oracle TYPE IS TABLE OF INDEX BY BINARY_INTEGER"></a>Oracle TYPE IS TABLE OF INDEX BY BINARY_INTEGER</h4><p>“Oracle TYPE IS TABLE OF INDEX BY BINARY_INTEGER” 是在 Oracle 数据库中定义一种类型，这种类型被称为 “关联数组类型”，也就是 “索引表类型”。这种类型可以存储一组数据，每个数据元素都有一个与之相关的数字索引，索引可以是二进制整数(binary integer)类型或其他类型。这种类型的声明示例如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">TYPE my_array <span class="keyword">IS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> NUMBER INDEX <span class="keyword">BY</span> BINARY_INTEGER;</span><br></pre></td></tr></table></figure><p>该声明定义了一种名为 my_array 的 “关联数组类型”，它可以存储 NUMBER 类型的数据，并使用二进制整数作为索引。我们可以通过如下方式来使用该类型： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE</span><br><span class="line"></span><br><span class="line"> my_data my_array; -- 声明一个名为 my_data 的变量，类型为 my_array</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line"> my_data(1) := 10; -- 将索引1对应的元素设置为10</span><br><span class="line"></span><br><span class="line"> my_data(2) := 20; -- 将索引2对应的元素设置为20</span><br><span class="line"></span><br><span class="line"> my_data(3) := 30; -- 将索引3对应的元素设置为30</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们声明一个 my_data 变量，这个变量是 my_array 类型的。我们可以使用这个变量来存储和访问一组数字数据，每个数据用一个唯一的索引值来标识。</p><p> 示例:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--参数变量</span></span><br><span class="line"> TYPE customer_search_record_type <span class="keyword">IS</span> RECORD(</span><br><span class="line">   source_code        VARCHAR2(<span class="number">30</span>),</span><br><span class="line">   source_id          VARCHAR2(<span class="number">150</span>),</span><br><span class="line">   operation_unit     VARCHAR2(<span class="number">50</span>), <span class="comment">--业务实体名称</span></span><br><span class="line">   sales_empoyee_code VARCHAR2(<span class="number">20</span>), <span class="comment">--销售业务人员</span></span><br><span class="line">   attribute1         VARCHAR2(<span class="number">240</span>),</span><br><span class="line">   attribute2         VARCHAR2(<span class="number">240</span>),</span><br><span class="line">   attribute3         VARCHAR2(<span class="number">240</span>),</span><br><span class="line">   attribute4         VARCHAR2(<span class="number">240</span>),</span><br><span class="line">   attribute5         VARCHAR2(<span class="number">240</span>));</span><br><span class="line"></span><br><span class="line"> TYPE customer_search_back_type <span class="keyword">IS</span> RECORD(</span><br><span class="line">   source_code     VARCHAR2(<span class="number">30</span>),</span><br><span class="line">   source_id       VARCHAR2(<span class="number">150</span>),</span><br><span class="line">   customer_number VARCHAR2(<span class="number">20</span>), <span class="comment">--客户编号</span></span><br><span class="line">   NAME            VARCHAR2(<span class="number">120</span>), <span class="comment">--客户名称</span></span><br><span class="line">   process_status  VARCHAR2(<span class="number">5</span>),</span><br><span class="line">   process_message VARCHAR2(<span class="number">240</span>));</span><br><span class="line"></span><br><span class="line"> TYPE crm_search_table_type <span class="keyword">IS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> customer_search_record_type INDEX <span class="keyword">BY</span> BINARY_INTEGER;</span><br><span class="line"></span><br><span class="line"> TYPE crm_search_back_table_type <span class="keyword">IS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> customer_search_back_type INDEX <span class="keyword">BY</span> BINARY_INTEGER;</span><br></pre></td></tr></table></figure><h4 id="Oracle-FETCH-BULK-COLLECT-INTO"><a href="#Oracle-FETCH-BULK-COLLECT-INTO" class="headerlink" title="Oracle FETCH BULK COLLECT INTO"></a>Oracle FETCH BULK COLLECT INTO</h4><p>Oracle 中的 FETCH BULK COLLECT INTO 语句是用来进行批量数据读取的一种技术。与传统的逐行读取不同，FETCH BULK COLLECT INTO 可以一次读取多行数据，大幅提高读取数据的效率。在使用 FETCH BULK COLLECT INTO 时，需要先定义一个集合类型（Collection Type），将读取的数据存储到这个集合类型中，再将其转存到其他数据表或数据对象中。</p><p>以下是一个简单的示例，展示如何使用 FETCH BULK COLLECT INTO 语句从表 Orders 中读取数据，存储到一维数组 orders 中：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  TYPE order_tab <span class="keyword">IS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> Orders<span class="operator">%</span>ROWTYPE;</span><br><span class="line">  orders order_tab;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    BULK <span class="keyword">COLLECT</span> <span class="keyword">INTO</span> orders</span><br><span class="line">    <span class="keyword">FROM</span> Orders</span><br><span class="line">   <span class="keyword">WHERE</span> order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2019-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2020-12-31&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;Number of rows fetched: &#x27;</span> <span class="operator">||</span> orders.COUNT);</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 对 orders 数组进行循环遍历操作</span></span><br><span class="line">  <span class="keyword">FOR</span> i <span class="keyword">IN</span> <span class="number">1.</span>.orders.COUNT LOOP</span><br><span class="line">    <span class="comment">-- 在此进行特定的逻辑处理</span></span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;Order ID: &#x27;</span> <span class="operator">||</span> orders(i).order_id);</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;Order Date: &#x27;</span> <span class="operator">||</span> orders(i).order_date);</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;Order Amount: &#x27;</span> <span class="operator">||</span> orders(i).amount);</span><br><span class="line">  <span class="keyword">END</span> LOOP;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，先定义了一个名为 order_tab 的集合类型，然后使用 SELECT BULK COLLECT INTO 语句来将查询到的数据存储到 orders 变量中。最后，在一个 FOR 循环中对 orders 数组进行遍历，进行特定的业务逻辑处理。</p><p>需要注意的是，在使用 FETCH BULK COLLECT INTO 时，需要注意以下几点：</p><ol><li>必须定义集合类型，集合类型的结构要与查询结果集的结构匹配。</li><li>必须使用 BULK COLLECT 子句来获取数据。</li><li>为避免数组超出存储能力，读取数据时需要对数据量进行控制，避免一次性读取过多数据。</li><li>BULK COLLECT INTO 只能在 PL/SQL 中使用。</li></ol><p>总之，FETCH BULK COLLECT INTO 是 Oracle 数据库中用于进行批量数据读取的一种技术，可以大幅提高数据读取的效率。在使用时，需要注意定义集合类型、使用 BULK COLLECT 子句来获取数据、控制数据量以及在 PL/SQL 中使用等方面的问题。</p><h4 id="Oracle-NOCPY"><a href="#Oracle-NOCPY" class="headerlink" title="Oracle NOCPY"></a>Oracle NOCPY</h4><p>“NOCOPY” 不是一个数据类型，而是一个 Oracle 提供的参数提示符号，用于告知编译器在调用子程序时不要执行参数的传递方式通常的传递方式，即值传递。该提示符可用于以下类型的参数：</p><p>- 基本数据类型（如数字、字符、日期、布尔等）。</p><p>- 大对象（LOB）或对象类型（如游标、集合类型、记录类型等）。</p><p>但是，需要注意的是，对于那些在子程序中被修改的参数，不应该使用 NOCOPY，而应该使用传值方式传递，否则可能会发生意想不到的错误。</p><p>以下是一个使用 NOCOPY 的简单示例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">PROCEDURE</span> process_data (p_data <span class="keyword">IN</span> <span class="keyword">out</span> NOCOPY my_collection) <span class="keyword">IS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个名为 <code>process_data</code> 的存储过程，其中包含一个名为 <code>p_data</code> 的参数。通过在参数名后添加 <code>NOCOPY</code> 标识符，我们告知编译器不要将 <code>p_data</code> 参数作为值传递进来，而应将其作为引用传递。这能够提高存储过程的性能，特别是在处理大型集合时。</p><p>注意，使用 NOCOPY 操作符需要非常小心，因为它可能会影响存储过程的语义和正确性。如果在存储过程中修改了传入的参数，就不能使用 NOCOPY 操作符。此外，对于较小的参数，NO COPY 可能会导致性能下降，因为它会增加一些不必要的复杂性。因此，我们需要在使用 NOCOPY 时谨慎权衡性能和正确性之间的平衡。</p><h4 id="Oracle-GOTO"><a href="#Oracle-GOTO" class="headerlink" title="Oracle GOTO"></a>Oracle GOTO</h4><p>在Oracle PL/SQL语言中，可以使用 <code>GOTO</code> 语句实现跳转控制语句。<code>GOTO</code> 语句让程序执行跳到一个标记（label）所在的位置，然后从那里继续执行。</p><p>例如，以下代码展示了如何使用 <code>GOTO</code> 语句跳转到标记处：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;Start of my program&#x27;</span>);</span><br><span class="line">   </span><br><span class="line">   GOTO mylabel;</span><br><span class="line">   </span><br><span class="line">   DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;This line is skipped&#x27;</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="operator">&lt;&lt;</span>mylabel<span class="operator">&gt;&gt;</span></span><br><span class="line">   DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;End of my program&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>GOTO</code> 语句跳转到 <code>&lt;mylabel&gt;</code> 标记后面的代码行，然后输出 “End of my program”。在 <code>GOTO</code> 语句后面的代码行（即第7行）被忽略了。</p><p>需要注意的是，<code>GOTO</code> 语句不建议滥用，因为它可能增加程序的复杂性和难以维护性。使用 <code>GOTO</code> 语句时，应当确保它对于程序结构和逻辑的理解是正确的，并且在满足特定的需要时使用。</p><h4 id="Oracle-ROLLBACK"><a href="#Oracle-ROLLBACK" class="headerlink" title="Oracle ROLLBACK"></a>Oracle ROLLBACK</h4><p>在Oracle数据库中，ROLLBACK语句用于回滚交易中未提交的更改。该语句用法如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure><p>当执行ROLLBACK语句时，Oracle数据库将撤消当前活动的事务所做出的所有更改，并将数据库状态恢复到事务开始之前的状态。这意味着原来未提交的更改将不再存在于数据库中，并且不会影响到后续的查询。</p><h4 id="Oracle-PRAGMA-AUTONOMOUS-TRANSACTION"><a href="#Oracle-PRAGMA-AUTONOMOUS-TRANSACTION" class="headerlink" title="Oracle PRAGMA AUTONOMOUS_TRANSACTION"></a>Oracle PRAGMA AUTONOMOUS_TRANSACTION</h4><p>在Oracle PL/SQL语言中，可以使用 <code>PRAGMA AUTONOMOUS_TRANSACTION</code> 来声明一个自主事务。它可以在当前事务的上下文中执行一个相对独立的子事务，不会受到当前事务的提交或回滚的影响。</p><p>声明一个带有 <code>PRAGMA AUTONOMOUS_TRANSACTION</code> 的函数时，该函数可以独立于主程序运行，且其提交或回滚的操作不会影响主程序事务的提交或回滚。当函数执行完毕后，其中执行的事务会自动提交或回滚。</p><p>例如，以下代码中展示了在 <code>PRAGMA AUTONOMOUS_TRANSACTION</code> 中执行的插入操作独立于主程序的事务并可以正常执行。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  PRAGMA AUTONOMOUS_TRANSACTION;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees (employee_id, first_name, last_name, email, phone_number, hire_date, job_id, salary)</span><br><span class="line">  <span class="keyword">VALUES</span> (<span class="number">123</span>, <span class="string">&#x27;John&#x27;</span>, <span class="string">&#x27;Doe&#x27;</span>, <span class="string">&#x27;jdoe@example.com&#x27;</span>, <span class="string">&#x27;555-1234&#x27;</span>, SYSDATE, <span class="string">&#x27;IT_PROG&#x27;</span>, <span class="number">9000</span>);</span><br><span class="line">  <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- This query returns no rows, because the transaction opened in the previous block is already committed.</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>PRAGMA AUTONOMOUS_TRANSACTION</code> 被广泛用于在事务中执行一些在主事务提交或者回滚时需要继续执行的 SQL 语句，比如发送电子邮件、写日志等操作。但是需要避免在 <code>PRAGMA AUTONOMOUS_TRANSACTION</code> 中执行对主事务数据操作的 SQL 语句，以免破坏事务的完整性和一致性。</p><h4 id="Oracle-dbms-utility-format-error-backtrace"><a href="#Oracle-dbms-utility-format-error-backtrace" class="headerlink" title="Oracle dbms_utility.format_error_backtrace"></a>Oracle dbms_utility.format_error_backtrace</h4><p>“Oracle dbms_utility.format_error_backtrace” 是一个 Oracle 数据库中的 PL/SQL 工具包，用于在发生异常错误时生成堆栈跟踪信息，方便管理员或开发人员对错误信息进行分析和调试。</p><p>当执行 PL/SQL 程序时发生异常错误时，可以使用 dbms_utility.format_error_backtrace 函数来输出该异常错误发生时的堆栈跟踪信息。该函数返回一个字符串，其中包含了堆栈跟踪信息，其中包括存储过程、函数和代码块的名称及其调用层次结构。</p><p>例如，以下代码段演示了如何在异常处理程序中使用 dbms_utility.format_error_backtrace 函数：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line"></span><br><span class="line"> l_error_msg VARCHAR2(<span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">-- 执行某些 PL/SQL 代码，可能会出现异常错误</span></span><br><span class="line"></span><br><span class="line">EXCEPTION</span><br><span class="line"></span><br><span class="line"> <span class="keyword">WHEN</span> OTHERS <span class="keyword">THEN</span></span><br><span class="line"></span><br><span class="line">  l_error_msg :<span class="operator">=</span> dbms_utility.format_error_backtrace;</span><br><span class="line"></span><br><span class="line">  dbms_output.put_line(l_error_msg);</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>在上述代码示例中，如果在执行某些 PL/SQL 代码时发生异常错误，异常处理程序将捕获该错误并调用 dbms_utility.format_error_backtrace 函数来生成堆栈跟踪信息。然后，该信息将作为字符串存储在 l_error_msg 变量中，并输出到会话的屏幕上，以便管理员或开发人员进行调试。</p><h4 id="Oracle-fnd-global-user-id"><a href="#Oracle-fnd-global-user-id" class="headerlink" title="Oracle fnd_global.user_id"></a>Oracle fnd_global.user_id</h4><p>“Oracle fnd_global.user_id” 是一个 Oracle E-Business Suite 应用程序中使用的全局变量。它由 FND_GLOBAL 访问代码库提供，用来表示当前登录用户的用户ID。</p><p>在 Oracle E-Business Suite 应用程序中，FND_GLOBAL 是一个公共的 PL/SQL 包，它包含一组可访问的全局变量和函数。通过访问 fnd_global.user_id 变量，应用程序可以获取当前已经登录的用户 ID。该变量返回的值为数字类型，对应于登录用户的唯一标识符。</p><p>在应用程序中，可以使用 fnd_global.user_id 变量来执行基于用户 ID 的安全验证，或者根据登录用户的身份来授权用户访问特定的应用程序功能等。</p> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    X_XAS <span class="type">VARCHAR</span>(<span class="number">2000</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    X_XAS :<span class="operator">=</span> FND_GLOBAL.USER_ID;</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(X_XAS);  <span class="comment">-- -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h4 id="Oracle-INSTR-SUBSTR"><a href="#Oracle-INSTR-SUBSTR" class="headerlink" title="Oracle INSTR  SUBSTR"></a>Oracle INSTR  SUBSTR</h4><p> <code>INSTR()</code> 和 <code>SUBSTR()</code> 是 Oracle 数据库中常用的字符串函数。</p><p><code>INSTR()</code> 函数用于查找一个子字符串在另一个字符串中出现的位置。其语法为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">INSTR(string, substring, start_position, occurrence);</span><br></pre></td></tr></table></figure><p>其中，<code>string</code> 是要在其中查找子字符串的字符串，<code>substring</code> 是要查找的子字符串，<code>start_position</code> 是要开始查找的位置，<code>occurrence</code> 是要在字符串中查找的第几个子字符串。如果 <code>INSTR()</code> 函数找不到子字符串，则返回 0。</p><p>以下是一个简单的示例，展示如何使用 <code>INSTR()</code> 函数查找一个字符串中子字符串的位置：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> INSTR(<span class="string">&#x27;Hello, world&#x27;</span>, <span class="string">&#x27;world&#x27;</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="comment">-- Returns 8</span></span><br></pre></td></tr></table></figure><p>这个查询将返回 8，这是 <code>world</code> 子字符串在 <code>Hello, world</code> 字符串中的起始位置。</p><p><code>SUBSTR()</code> 函数用于从一个字符串中提取一个子字符串。其语法为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SUBSTR(string, start_position, [length]);</span><br></pre></td></tr></table></figure><p>其中，<code>string</code> 是要从中提取子字符串的字符串，<code>start_position</code> 是子字符串的起始位置，<code>length</code> 是要提取的字符串的长度。如果 <code>length</code> 被省略，则 <code>SUBSTR()</code> 函数将返回从 <code>start_position</code> 开始的未截断的子字符串。</p><p>以下是一个简单的示例，展示如何使用 <code>SUBSTR()</code> 函数从一个字符串中提取子字符串：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SUBSTR(<span class="string">&#x27;Hello, world&#x27;</span>, <span class="number">1</span>, <span class="number">5</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="comment">-- Returns &#x27;Hello&#x27;</span></span><br></pre></td></tr></table></figure><p>这个查询将返回 <code>Hello</code>，这是从 <code>Hello, world</code> 字符串中提取的前 5 个字符。</p><p>需要注意的是，<code>INSTR()</code> 和 <code>SUBSTR()</code> 函数的参数名称根据具体场景而变化。有些示例中使用的是 <code>string</code> 和 <code>substring</code>，而有些示例中使用的是 <code>source</code> 和 <code>target</code>，或者是其他类似的名称。在使用这些函数时，重要的是理解函数的语法和参数，以便可以正确地构建查询。</p><p>总之，<code>INSTR()</code> 和 <code>SUBSTR()</code> 是 Oracle 数据库中经常使用的字符串函数，可以用来查找子字符串的位置和提取子字符串。熟练掌握这些函数可以让查询语句更加灵活和高效。</p><h4 id="Oracle-ROW"><a href="#Oracle-ROW" class="headerlink" title="Oracle ROW()"></a>Oracle ROW()</h4><p><code>ROW()</code> 是 Oracle 数据库中用于创建含有多个列的行的一个函数。该函数用于将多个表达式组合成一行，以便在 SELECT 语句中返回多个值。这个函数可以在 SQL 查询中用于快速构建数据集合，而无需创建一个实际的表。</p><p>以下是一个简单的示例，展示如何使用 ROW() 函数创建一个行：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="type">ROW</span>(<span class="number">1</span>, <span class="string">&#x27;John Doe&#x27;</span>, <span class="string">&#x27;1985-10-15&#x27;</span>) <span class="keyword">AS</span> person <span class="keyword">FROM</span> DUAL;</span><br></pre></td></tr></table></figure><p>这个 SQL 查询将会创建一行，其中包括三个不同的值：一个数值、一个字符串和一个日期。注意，这个函数可以接受任意数量的参数，返回一行，其中包括输入的参数。 </p><p>如果需要按行返回多个结果，则可以使用 ROW() 函数来组合多个列数据。以下是一个更为复杂的示例： </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="type">ROW</span>(id, first_name, last_name, hire_date) <span class="keyword">AS</span> employee</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span> hire_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2021-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2021-12-31&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这个 SQL 查询将会搜索一个名为 employees 的表，然后选择在 2021 年雇用的所有员工，并且将每个被选中员工的 ID、名字、姓氏和雇用日期都作为一个行返回。</p><p>这可以方便地将这些数据传递到其他 PL/SQL 程序，并在必要时进行处理。</p><p>总之，Oracle 数据库中的 ROW() 函数用于在 SELECT 语句中创建一组值，并将它们组合成一行。外面的 SELECT 语句可以使用ROW() 函数返回的行数据进行额外的处理或展示。这个函数在构建数据集合时非常有用，因为它可以方便地将多个值组合成一个行，而无需创建实际的表。</p><h4 id="Oracle-PIPE"><a href="#Oracle-PIPE" class="headerlink" title="Oracle PIPE"></a>Oracle PIPE</h4><p><code>PIPE</code> 是在 Oracle 数据库中用于创建和定义 PL/SQL 管道的一种特定类型的对象。PL/SQL 管道允许以流的形式在多个 PL/SQL 环境中共享数据，可以在 PL/SQL 程序之间或在 PL/SQL 和 SQL 语句之间传递数据。</p><p>使用 PIPE 可以将数据流发送到一个或多个消费者中，从而构建更为灵活和高效的应用程序。在使用 PIPE 时，首先需要定义一个 PIPE 对象，然后编写生产者和消费者的代码，以便根据需要生成或使用数据。</p><p>以下是一个简单的示例，展示了如何使用 PIPE 在两个 PL/SQL 程序之间共享数据：</p><p>首先，创建一个 PIPE 对象：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE TYPE my_pipe_type <span class="keyword">AS</span> OBJECT (<span class="keyword">value</span> VARCHAR2(<span class="number">50</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE TYPE my_pipe_type_list <span class="keyword">AS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> my_pipe_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE PACKAGE my_pipe_pkg <span class="keyword">AS</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">FUNCTION</span> my_pipe (input VARCHAR2) <span class="keyword">RETURN</span> my_pipe_type_list PIPELINED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span></span><br></pre></td></tr></table></figure><p>这个代码段中定义了一个 PIPE 的类型 <code>my_pipe_type</code> 和 <code>my_pipe_type_list</code>，以及一个存放在 <code>my_pipe_pkg</code> 包中的 PIPE 程序 <code>my_pipe</code>。这个 PIPE 程序接收一个字符串作为输入，并将 <code>my_pipe_type</code> 对象逐行返回 PIPE。</p><p>然后，创建一个 PIPE 生产者：</p> <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">PROCEDURE</span> my_pipe_producer</span><br><span class="line"></span><br><span class="line"><span class="keyword">IS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">FOR</span> i <span class="keyword">IN</span> <span class="number">1.</span><span class="number">.10</span></span><br><span class="line"></span><br><span class="line"> LOOP</span><br><span class="line"></span><br><span class="line">  PIPE <span class="type">ROW</span> (my_pipe_type(<span class="string">&#x27;Value &#x27;</span> <span class="operator">||</span> i));</span><br><span class="line"></span><br><span class="line"> <span class="keyword">END</span> LOOP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span></span><br></pre></td></tr></table></figure><p>这个代码段中定义了一个 <code>my_pipe_producer</code> 程序，用于生成一系列 <code>my_pipe_type</code> 对象，并将它们逐行返回管道。</p><p>最后，创建一个 PIPE 消费者：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">PROCEDURE</span> my_pipe_consumer</span><br><span class="line"></span><br><span class="line"><span class="keyword">IS</span></span><br><span class="line"></span><br><span class="line"> l_value my_pipe_type_list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"> l_value :<span class="operator">=</span> my_pipe_pkg.my_pipe(<span class="string">&#x27;Input Value&#x27;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">FOR</span> i <span class="keyword">IN</span> <span class="number">1.</span>.l_value.COUNT</span><br><span class="line"></span><br><span class="line"> LOOP</span><br><span class="line"></span><br><span class="line">  DBMS_OUTPUT.PUT_LINE(l_value(i).<span class="keyword">value</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">END</span> LOOP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span></span><br></pre></td></tr></table></figure><p>这个代码段中定义了一个 <code>my_pipe_consumer</code> 程序，用于从管道中获取 <code>my_pipe_type</code> 对象，并逐个打印它们的值。在这个程序中，我们首先调用了 <code>my_pipe_pkg.my_pipe</code> 程序来获取传递给管道的 <code>my_pipe_type</code> 对象，然后使用 <code>FOR</code> 循环迭代这些对象，并使用 <code>DBMS_OUTPUT.PUT_LINE</code> 打印它们的值。</p><p>运行上述程序后，可以在 SQL Plus 控制台上看到 <code>my_pipe_consumer</code> 程序输出的数据。</p><p>总之，PIPE 是在 Oracle 中用于创建和定义 PL/SQL 管道的一种特定类型的对象，可以用于在多个 PL/SQL 程序之间或在 PL/SQL 和 SQL 语句之间传递数据。通过定义生产者和消费者的代码，我们可以灵活地生成或使用数据，从而构建更高效和灵活的应用程序。</p><h4 id="Oracle-PIPELINED"><a href="#Oracle-PIPELINED" class="headerlink" title="Oracle PIPELINED"></a>Oracle PIPELINED</h4><p><code>PIPELINED</code> 是在 Oracle 数据库中用于创建和定义返回集合的函数的一种选项。使用 <code>PIPELINED</code> 关键字定义的函数将被认为是返回一系列行（或元组）的函数，每当一个行被生成时就会提供结果集，而不是在所有行都生成时才返回整个结果集。</p><p>使用 <code>PIPELINED</code> 让函数更像是一个生成器，可以一行一行地产生数据，而不是像普通函数那样一口气返回所有数据。这种方式可以提高函数的效率和响应时间，特别是当返回的数据集较大时，更加明显。</p><p>下面是一个例子，展示了如何使用 <code>PIPELINED</code> 返回一个包含数字的数据集：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE FUNCTION GENERATE_NUMBERS(max_num NUMBER)</span><br><span class="line"></span><br><span class="line">  RETURN sys.odcinumberlist</span><br><span class="line"></span><br><span class="line">  PIPELINED IS</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">  FOR i IN 1 .. max_num LOOP</span><br><span class="line"></span><br><span class="line">    PIPE ROW(i);</span><br><span class="line"></span><br><span class="line">  END LOOP;</span><br><span class="line"></span><br><span class="line">  RETURN;</span><br><span class="line"></span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>这个函数接收一个数字 <code>max_num</code>，然后返回一个包含从 1 到 <code>max_num</code> 的数字序列的数据集。这个函数使用了 <code>PIPELINED</code> 关键字，以便在生成数据时可以逐行返回结果集。</p><p>在使用这个函数时，可以按照如下方式进行操作：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM TABLE(GENERATE_NUMBERS(10));</span><br></pre></td></tr></table></figure><p>这个 SQL 语句会返回一个包含 10 行数据的结果集，每一行表示一个数字。由于使用了 <code>PIPELINED</code>，函数将逐行返回结果，因此查询操作会比使用普通函数更加高效。</p><p>总之，<code>PIPELINED</code> 是一个在 Oracle 中用于定义返回集合的函数的选项，它可以让函数一行一行地生成数据，并逐行返回结果集，提高函数的效率和响应时间。</p><h4 id="Oracle-PLS-INTEGE"><a href="#Oracle-PLS-INTEGE" class="headerlink" title="Oracle PLS_INTEGE"></a>Oracle PLS_INTEGE</h4><p><code>PLS_INTEGER</code> 是 Oracle 数据库中一种整数类型，它是 <code>BINARY_INTEGER</code> 的别名，用于存储大于等于 -2^31 而小于等于 2^31-1 的整数。</p><p><code>PLS_INTEGER</code> 和 <code>BINARY_INTEGER</code> 的区别在于：</p><p>- <code>PLS_INTEGER</code> 是一个可移植数据类型，而 <code>BINARY_INTEGER</code> 是一个实现特定的数据类型。<code>PLS_INTEGER</code> 的范围在不同的 Oracle 版本中是一样的，而 <code>BINARY_INTEGER</code> 的范围可能会因实现而异。</p><p>- 对于使用 <code>PLS_INTEGER</code> 类型的变量，如果期望变量的值超出范围会引发一个运行时异常；而对于使用 <code>BINARY_INTEGER</code> 类型的变量，如果变量值超出了范围，它将会在编译时发出一个警告。</p><p>在 PL/SQL 中，使用 <code>PLS_INTEGER</code> 变量的好处在于，它可以提供更好的性能和可移植性。由于 <code>PLS_INTEGER</code> 的范围固定，因此 Oracle 在编译时可以优化代码，以避免需要在运行时进行范围检查。这种优化可以在某些情况下提高程序的性能。同时，<code>PLS_INTEGER</code> 是一个可移植的数据类型，因此在不同的 Oracle 版本之间移植代码时，可以避免由于范围的不同而导致的问题。</p><p>以下是一个使用 <code>PLS_INTEGER</code> 类型的简单示例：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE</span><br><span class="line"></span><br><span class="line"> x PLS_INTEGER := 10;</span><br><span class="line"></span><br><span class="line"> y PLS_INTEGER := 20;</span><br><span class="line"></span><br><span class="line"> z PLS_INTEGER;</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line"> z := x + y;</span><br><span class="line"></span><br><span class="line"> DBMS_OUTPUT.PUT_LINE(&#x27;z = &#x27; || z);</span><br><span class="line"></span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>以上代码将声明三个 <code>PLS_INTEGER</code> 类型的变量，计算它们的和，并输出结果。注意，<code>PLS_INTEGER</code> 类型的变量赋值时需要使用 <code>:=</code> 操作符，而不是 <code>=</code> 操作符。</p><p>总之，<code>PLS_INTEGER</code> 类型是 Oracle 中的一种优化整数类型，可以在一定程度上提高程序的性能。在编写需要处理整数的 PL/SQL 代码时，可以考虑使用 <code>PLS_INTEGER</code> 类型来获得更好的性能和可移植性。</p><h4 id="Oracle-sys-DBMS-DEBUG-VC2COLL"><a href="#Oracle-sys-DBMS-DEBUG-VC2COLL" class="headerlink" title="Oracle sys.DBMS_DEBUG_VC2COLL"></a>Oracle sys.DBMS_DEBUG_VC2COLL</h4><p>sys.DBMS_DEBUG_VC2COLL` 是 Oracle 数据库中提供的一种类型定义，用于在 PL/SQL 中定义一个 Varchar2 数组类型。这个类型是用于调试目的而创建的，一般不用于实际应用。</p><p>该类型定义位于 <code>SYS.DBMS_DEBUG</code> 包中，它定义了一组用于调试的子程序和函数。其中，<code>sys.DBMS_DEBUG_VC2COLL</code> 定义一个单列的 <code>Varchar2</code> 数组类型。</p><p>可以使用以下方法来创建一个包含 <code>sys.DBMS_DEBUG_VC2COLL</code> 类型变量的函数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE FUNCTION MY_FUNCTION RETURN sys.DBMS_DEBUG_VC2COLL IS</span><br><span class="line"></span><br><span class="line">  l_var sys.DBMS_DEBUG_VC2COLL;</span><br><span class="line"></span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">  l_var(1) := &#x27;test1&#x27;;</span><br><span class="line"></span><br><span class="line">  l_var(2) := &#x27;test2&#x27;;</span><br><span class="line"></span><br><span class="line">  l_var(3) := &#x27;test3&#x27;;</span><br><span class="line"></span><br><span class="line">  RETURN l_var;</span><br><span class="line"></span><br><span class="line">END;</span><br></pre></td></tr></table></figure><p>上面的函数将返回一个包含 “test1”、”test2” 和 “test3” 三个元素的字符串数组。</p><p>需要注意的是，<code>sys.DBMS_DEBUG_VC2COLL</code> 类型并不是 Oracle 官方正式支持的类型之一，因此不建议在实际应用中使用该类型，而是应该使用 Oracle 提供的正式类型。</p><h4 id="Oracle-自定义SPLIT和SPLITSTR函数批量分隔字符串"><a href="#Oracle-自定义SPLIT和SPLITSTR函数批量分隔字符串" class="headerlink" title="Oracle 自定义SPLIT和SPLITSTR函数批量分隔字符串"></a>Oracle 自定义SPLIT和SPLITSTR函数批量分隔字符串</h4><p>RACLE使用SPLIT和SPLITSTR函数批量分隔字符串</p><p>项目中有很多需要做批量操作的需求，客户端把一组逗号分隔的ID字符串传给数据库，存储过程就需要把它们分割，然后逐个处理。</p><p>ORACLE没有提供类似JAVA中SPLIT的函数来将字符串分割成数组,需要开发者自己搞定.</p><p>首先定一个数组类型,再定义一个函数或存储过程,处理字符串分割操作,</p><p>以往的处理方式有如下几种：</p><p>1、在存储过程内写循环，逐个分析字符串中的ID，然后逐个处理。缺点：循环一次处理一个，如果每次判断都很多，效率将很受影响。适合每次处理要做单独判断的情况。</p><p>2、使用临时表，先调用一个存储过程将ID拆分并插入到临时表中，然后结合临时表可以写SQL一次处理多笔。缺点：需要插临时表，效率不高，数据量越大影响越严重。</p><p>以前的项目用的最多的还是第2中方式，毕竟方便，且效率比第1种好。</p><p>ORACLE添加SPLIT函数是完全可以实现的，避免了插入临时表，所以效率比上面的第2中方法效率高很多。</p><p>后来还添加了SPLITSTR函数，可以很方便获取字符串中的指定节点。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Oracle 创建 split 和 splitstr 函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个表类型 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE TYPE TABLETYPE <span class="keyword">AS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> VARCHAR2(<span class="number">32676</span>)；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建 split 函数 */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> split(p_list <span class="type">CLOB</span>, p_sep VARCHAR2 :<span class="operator">=</span> <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="keyword">RETURN</span> tabletype</span><br><span class="line">    PIPELINED</span><br><span class="line"><span class="comment">/**************************************</span></span><br><span class="line"><span class="comment">    * Name:        split</span></span><br><span class="line"><span class="comment">    * Author:      Xing Deng.</span></span><br><span class="line"><span class="comment">    * Date:        2023-05-03.</span></span><br><span class="line"><span class="comment">    * Function:    返回字符串被指定字符分割后的表类型。</span></span><br><span class="line"><span class="comment">    * Parameters:  p_list: 待分割的字符串。</span></span><br><span class="line"><span class="comment">                   p_sep: 分隔符，默认逗号，也可以指定字符或字符串。</span></span><br><span class="line"><span class="comment">    * Example:     SELECT *</span></span><br><span class="line"><span class="comment">                     FROM users</span></span><br><span class="line"><span class="comment">                   WHERE u_id IN (SELECT COLUMN_VALUE</span></span><br><span class="line"><span class="comment">                                     FROM table (split (&#x27;1,2&#x27;)))</span></span><br><span class="line"><span class="comment">                  返回u_id为1和2的两行数据。</span></span><br><span class="line"><span class="comment">    **************************************/</span></span><br><span class="line"> <span class="keyword">IS</span></span><br><span class="line">    l_idx  PLS_INTEGER;</span><br><span class="line">    v_list VARCHAR2(<span class="number">32676</span>) :<span class="operator">=</span> p_list;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    LOOP</span><br><span class="line">        l_idx :<span class="operator">=</span> INSTR(v_list, p_sep);</span><br><span class="line">    </span><br><span class="line">        IF l_idx <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">            PIPE <span class="type">ROW</span>(SUBSTR(v_list, <span class="number">1</span>, l_idx <span class="operator">-</span> <span class="number">1</span>));</span><br><span class="line">            v_list :<span class="operator">=</span> SUBSTR(v_list, l_idx <span class="operator">+</span> LENGTH(p_sep));</span><br><span class="line">        <span class="keyword">ELSE</span></span><br><span class="line">            PIPE <span class="type">ROW</span>(v_list);</span><br><span class="line">            EXIT;</span><br><span class="line">        <span class="keyword">END</span> IF;</span><br><span class="line">    <span class="keyword">END</span> LOOP;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建 splitstr 函数 */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> splitstr(str <span class="keyword">IN</span> <span class="type">CLOB</span>,</span><br><span class="line">                                    i   <span class="keyword">IN</span> NUMBER :<span class="operator">=</span> <span class="number">0</span>,</span><br><span class="line">                                    sep <span class="keyword">IN</span> VARCHAR2 :<span class="operator">=</span> <span class="string">&#x27;,&#x27;</span>) <span class="keyword">RETURN</span> VARCHAR2</span><br><span class="line"><span class="comment">/**************************************</span></span><br><span class="line"><span class="comment">    * Name:        splitstr</span></span><br><span class="line"><span class="comment">    * Author:      Sean Zhang.</span></span><br><span class="line"><span class="comment">    * Date:        2012-09-03.</span></span><br><span class="line"><span class="comment">    * Function:    返回字符串被指定字符分割后的指定节点字符串。</span></span><br><span class="line"><span class="comment">    * Parameters:  str: 待分割的字符串。</span></span><br><span class="line"><span class="comment">                   i: 返回第几个节点。当i为0返回str中的所有字符，当i 超过可被分割的个数时返回空。</span></span><br><span class="line"><span class="comment">                   sep: 分隔符，默认逗号，也可以指定字符或字符串。当指定的分隔符不存在于str中时返回sep中的字符。</span></span><br><span class="line"><span class="comment">    * Example:     select splitstr(&#x27;abc,def&#x27;, 1) as str from dual;  得到 abc</span></span><br><span class="line"><span class="comment">                   select splitstr(&#x27;abc,def&#x27;, 3) as str from dual;  得到 空</span></span><br><span class="line"><span class="comment">    **************************************/</span></span><br><span class="line"> <span class="keyword">IS</span></span><br><span class="line">    t_i     NUMBER;</span><br><span class="line">    t_count NUMBER;</span><br><span class="line">    t_str   VARCHAR2(<span class="number">4000</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    IF i <span class="operator">=</span> <span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">        t_str :<span class="operator">=</span> str;</span><br><span class="line">    ELSIF INSTR(str, sep) <span class="operator">=</span> <span class="number">0</span> <span class="keyword">THEN</span></span><br><span class="line">        t_str :<span class="operator">=</span> sep;</span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> t_count <span class="keyword">FROM</span> <span class="keyword">table</span>(split(str, sep));</span><br><span class="line"></span><br><span class="line">        IF i <span class="operator">&lt;=</span> t_count <span class="keyword">THEN</span></span><br><span class="line">            <span class="keyword">SELECT</span> str</span><br><span class="line">              <span class="keyword">INTO</span> t_str</span><br><span class="line">              <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> ROWNUM <span class="keyword">AS</span> item, COLUMN_VALUE <span class="keyword">AS</span> str</span><br><span class="line">                      <span class="keyword">FROM</span> <span class="keyword">table</span>(split(str, sep)))</span><br><span class="line">             <span class="keyword">WHERE</span> item <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">END</span> IF;</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">RETURN</span> t_str;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h4 id="Oracle-REGEXP-SUBSTR"><a href="#Oracle-REGEXP-SUBSTR" class="headerlink" title="Oracle REGEXP_SUBSTR"></a>Oracle REGEXP_SUBSTR</h4><p>在 Oracle 中，可以使用 <code>REGEXP_SUBSTR</code> 函数来进行字符串分隔。以下是一个示例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> REGEXP_SUBSTR(<span class="string">&#x27;A,B,C,D,E&#x27;</span>, <span class="string">&#x27;[^,]+&#x27;</span>, <span class="number">1</span>, LEVEL) <span class="keyword">result</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> dual</span><br><span class="line"></span><br><span class="line"><span class="keyword">CONNECT</span> <span class="keyword">BY</span> LEVEL <span class="operator">&lt;=</span> REGEXP_COUNT(<span class="string">&#x27;A,B,C,D,E&#x27;</span>, <span class="string">&#x27;,&#x27;</span>) <span class="operator">+</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RESULT </span><br><span class="line"></span><br><span class="line">--------</span><br><span class="line"></span><br><span class="line">A    </span><br><span class="line"></span><br><span class="line">B    </span><br><span class="line"></span><br><span class="line">C    </span><br><span class="line"></span><br><span class="line">D    </span><br><span class="line"></span><br><span class="line">E    </span><br></pre></td></tr></table></figure><p>在上面的示例中，使用了 <code>REGEXP_SUBSTR</code> 函数和 <code>CONNECT BY LEVEL</code> 子句来对字符串进行分隔。<code>REGEXP_SUBSTR</code> 函数使用正则表达式来匹配字符串中的子串，<code>CONNECT BY LEVEL</code> 子句用于循环将字符串分段。<code>REGEXP_COUNT</code> 函数用于计算分隔符出现的次数，从而确定分割的次数。</p><p>当然，你也可以将该查询语句封装成一个函数，实现批量分隔字符串的功能。例如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> SPLITSTR (</span><br><span class="line"></span><br><span class="line">  p_str <span class="keyword">IN</span> VARCHAR2,</span><br><span class="line"></span><br><span class="line">  p_delimiter <span class="keyword">IN</span> VARCHAR2</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">RETURN</span> sys.DBMS_DEBUG_VC2COLL</span><br><span class="line"></span><br><span class="line"><span class="keyword">IS</span></span><br><span class="line"></span><br><span class="line">  l_tablen PLS_INTEGER;</span><br><span class="line"></span><br><span class="line">  l_arr sys.DBMS_DEBUG_VC2COLL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> REGEXP_COUNT(p_str, p_delimiter) <span class="operator">+</span> <span class="number">1</span> <span class="keyword">INTO</span> l_tablen <span class="keyword">FROM</span> dual;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> REGEXP_SUBSTR(p_str, <span class="string">&#x27;[^&#x27;</span> <span class="operator">||</span> p_delimiter <span class="operator">||</span> <span class="string">&#x27;]+&#x27;</span>, <span class="number">1</span>, LEVEL)</span><br><span class="line"></span><br><span class="line">  BULK <span class="keyword">COLLECT</span> <span class="keyword">INTO</span> l_arr <span class="keyword">FROM</span> dual</span><br><span class="line"></span><br><span class="line">  <span class="keyword">CONNECT</span> <span class="keyword">BY</span> LEVEL <span class="operator">&lt;=</span> l_tablen;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">RETURN</span> l_arr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span> SPLITSTR;</span><br></pre></td></tr></table></figure><p>该函数的参数为要分割的字符串和分隔符，返回值为一个字符串数组。可以使用以下的方式调用该函数：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> COLUMN_VALUE results FROTABLEM (SPLITSTR(<span class="string">&#x27;A,B,C,D,E&#x27;</span>, <span class="string">&#x27;,&#x27;</span>));</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RESULT </span><br><span class="line"></span><br><span class="line">--------</span><br><span class="line"></span><br><span class="line">A    </span><br><span class="line"></span><br><span class="line">B    </span><br><span class="line"></span><br><span class="line">C    </span><br><span class="line"></span><br><span class="line">D    </span><br><span class="line"></span><br><span class="line">E    </span><br></pre></td></tr></table></figure><p>这样就可以快速地实现批量分隔字符串的功能了。</p><h4 id="Oracle-CONNECT-BY"><a href="#Oracle-CONNECT-BY" class="headerlink" title="Oracle CONNECT BY"></a>Oracle CONNECT BY</h4><p>在 Oracle 数据库中，没有内置的 <code>SPLIT</code> 和 <code>SPLITSTR</code> 函数，但可以使用 <code>REGEXP_SUBSTR</code> 函数配合 <code>CONNECT BY</code> 子句或者采用其他方法来实现字符串的分割。</p><p>以下是一个使用 <code>REGEXP_SUBSTR</code> 函数和 <code>CONNECT BY</code> 子句来实现字符串分割的示例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">TRIM</span>(REGEXP_SUBSTR(<span class="string">&#x27;A,B,C,D,E&#x27;</span>, <span class="string">&#x27;[^,]+&#x27;</span>, <span class="number">1</span>, LEVEL) ) results</span><br><span class="line"></span><br><span class="line"> <span class="keyword">FROM</span> dual</span><br><span class="line"></span><br><span class="line"><span class="keyword">CONNECT</span> <span class="keyword">BY</span> REGEXP_SUBSTR(<span class="string">&#x27;A,B,C,D,E&#x27;</span>, <span class="string">&#x27;[^,]+&#x27;</span>, <span class="number">1</span>, LEVEL) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RESULT </span><br><span class="line"></span><br><span class="line">--------</span><br><span class="line"></span><br><span class="line">A    </span><br><span class="line"></span><br><span class="line">B    </span><br><span class="line"></span><br><span class="line">C    </span><br><span class="line"></span><br><span class="line">D    </span><br><span class="line"></span><br><span class="line">E </span><br></pre></td></tr></table></figure><p>以上 SQL 语句将以逗号为分隔符的字符串 <code>&#39;A,B,C,D,E&#39;</code> 分割成多个子串，并将其作为结果集返回。</p><p>如果需要将字符串的分割结果存储到一个 <code>VARCHAR2</code> 数组变量中，可以使用 <code>BULK COLLECT</code> 语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line"></span><br><span class="line">  TYPE t_results <span class="keyword">IS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> VARCHAR2(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  t_res t_results;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="built_in">TRIM</span>(REGEXP_SUBSTR(<span class="string">&#x27;A,B,C,D,E&#x27;</span>, <span class="string">&#x27;[^,]+&#x27;</span>, <span class="number">1</span>, LEVEL) ) </span><br><span class="line"></span><br><span class="line">  BULK <span class="keyword">COLLECT</span> <span class="keyword">INTO</span> t_res</span><br><span class="line"></span><br><span class="line">  <span class="keyword">FROM</span> dual</span><br><span class="line"></span><br><span class="line">  <span class="keyword">CONNECT</span> <span class="keyword">BY</span> REGEXP_SUBSTR(<span class="string">&#x27;A,B,C,D,E&#x27;</span>, <span class="string">&#x27;[^,]+&#x27;</span>, <span class="number">1</span>, LEVEL) <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">FOR</span> i <span class="keyword">IN</span> t_res.FIRST..t_res.LAST LOOP</span><br><span class="line"></span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(t_res(i));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">END</span> LOOP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>以上示例使用 <code>BULK COLLECT</code> 将分割后的结果集存储到 <code>t_res</code> 变量中，然后逐个输出每个子串。</p><p>此外，还可以通过自定义函数的方式来实现字符串的批量分割，例如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE TYPE t_results <span class="keyword">AS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> VARCHAR2(<span class="number">4000</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> SPLITSTR(</span><br><span class="line"></span><br><span class="line">  p_str <span class="keyword">IN</span> VARCHAR2,</span><br><span class="line"></span><br><span class="line">  p_delimiter <span class="keyword">IN</span> VARCHAR2</span><br><span class="line"></span><br><span class="line">) <span class="keyword">RETURN</span> t_results <span class="keyword">IS</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">--TYPE t_results IS TABLE OF VARCHAR2(4000);</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  l_tablen PLS_INTEGER;</span><br><span class="line"></span><br><span class="line">  l_arr t_results;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> REGEXP_COUNT(p_str, p_delimiter) <span class="operator">+</span> <span class="number">1</span> <span class="keyword">INTO</span> l_tablen <span class="keyword">FROM</span> dual;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="built_in">TRIM</span>(REGEXP_SUBSTR(p_str, <span class="string">&#x27;[^&#x27;</span> <span class="operator">||</span> p_delimiter <span class="operator">||</span> <span class="string">&#x27;]+&#x27;</span>, <span class="number">1</span>, LEVEL))</span><br><span class="line"></span><br><span class="line">  BULK <span class="keyword">COLLECT</span> <span class="keyword">INTO</span> l_arr <span class="keyword">FROM</span> dual</span><br><span class="line"></span><br><span class="line">  <span class="keyword">CONNECT</span> <span class="keyword">BY</span> LEVEL <span class="operator">&lt;=</span> l_tablen;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">RETURN</span> l_arr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">--TYPE t_results IS TABLE OF VARCHAR2(4000);</span></span><br><span class="line"></span><br><span class="line">  t_res t_results;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">  t_res :<span class="operator">=</span> SPLITSTR(<span class="string">&#x27;A,B,C,D,E&#x27;</span>, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">FOR</span> i <span class="keyword">IN</span> t_res.FIRST..t_res.LAST LOOP</span><br><span class="line"></span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(t_res(i));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">END</span> LOOP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span></span><br></pre></td></tr></table></figure><p>以上示例定义了一个名为 <code>SPLITSTR</code> 的函数，函数接受两个参数，一个是要分割的字符串，另一个是分隔符。函数返回一个 <code>VARCHAR2</code> 数组类型的结果集。然后在 PL/SQL 代码中调用该函数，并输出每个子串。</p><p>总之，Oracle 数据库中可以使用 <code>REGEXP_SUBSTR</code> 函数、<code>CONNECT BY</code> 子句、<code>BULK COLLECT</code> 等方法来实现字符串的批量分割。大家可以根据自己的实际需求选择合适的方法。</p><h4 id="Oracle-INSERT-INTO-SELECT"><a href="#Oracle-INSERT-INTO-SELECT" class="headerlink" title="Oracle INSERT INTO SELECT"></a>Oracle INSERT INTO SELECT</h4><p>INSERT INTO SELECT是一种在 SQL 中用于从一个表格复制数据到另一个表格的语句。其基本语法格式如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO table2</span><br><span class="line"></span><br><span class="line">SELECT * FROM table1</span><br><span class="line"></span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure><p>其中，table2 代表目标表格，table1 代表源表格，* 表示将所有的列都复制到目标表格中。</p><p>在实际使用中，可以根据需要指定所要复制的列名称，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO table2 (col1, col2, col3)</span><br><span class="line"></span><br><span class="line">SELECT col1, col2, col3 FROM table1</span><br><span class="line"></span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure><p>这样就只会复制名为 col1、col2 和 col3 的三个列。</p><p>在执行 INSERT INTO SELECT 语句时，需要注意源表格和目标表格的列类型和数量必须匹配，否则会出现错误。同时，为了确保数据的安全性和正确性，也应该在执行 INSERT INTO SELECT 语句之前进行数据备份。</p><h4 id="Oracle-MINUS-UNION"><a href="#Oracle-MINUS-UNION" class="headerlink" title="Oracle MINUS UNION"></a>Oracle MINUS UNION</h4><p>Minux和Union是Oracle SQL中常用的两种集合运算，它们的区别在于以下几个方面：</p><ol><li><p>返回结果集的数量： Union操作返回两个查询的并集，即包含两个查询的所有行并去除重复的行，而Minus操作返回的是第一个查询与第二个查询的差集，即第一个查询的结果集中去除在第二个查询结果集中也存在的行。</p></li><li><p>结果的列：Union和Minus操作要求两个查询的结果集包含相同数量和类型的列。</p></li><li><p>数据集的排序：Union操作默认按照第一个查询结果集中的列进行排序，Minus操作则没有排序的限制。</p></li></ol><p>下面是一个示例说明：</p><p>假设我们有这么两个查询：</p><p>Query1：SELECT id FROM table1;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+</span><br><span class="line"></span><br><span class="line">| id |</span><br><span class="line"></span><br><span class="line">+----+</span><br><span class="line"></span><br><span class="line">| 1 |</span><br><span class="line"></span><br><span class="line">| 2 |</span><br><span class="line"></span><br><span class="line">| 3 |</span><br><span class="line"></span><br><span class="line">| 4 |</span><br><span class="line"></span><br><span class="line">+----+</span><br></pre></td></tr></table></figure><p>Query2：SELECT id FROM table2;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+</span><br><span class="line"></span><br><span class="line">| id |</span><br><span class="line"></span><br><span class="line">+----+</span><br><span class="line"></span><br><span class="line">| 2 |</span><br><span class="line"></span><br><span class="line">| 3 |</span><br><span class="line"></span><br><span class="line">| 5 |</span><br><span class="line"></span><br><span class="line">| 6 |</span><br><span class="line"></span><br><span class="line">+----+</span><br></pre></td></tr></table></figure><p>使用UNION操作的结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT id FROM table1</span><br><span class="line"></span><br><span class="line"> UNION</span><br><span class="line"></span><br><span class="line">SELECT id FROM table2;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">+----+</span><br><span class="line"></span><br><span class="line">| id |</span><br><span class="line"></span><br><span class="line">+----+</span><br><span class="line"></span><br><span class="line">| 1 |</span><br><span class="line"></span><br><span class="line">| 2 |</span><br><span class="line"></span><br><span class="line">| 3 |</span><br><span class="line"></span><br><span class="line">| 5 |</span><br><span class="line"></span><br><span class="line">| 6 |</span><br><span class="line"></span><br><span class="line">+----+</span><br></pre></td></tr></table></figure><p>使用MINUS操作的结果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT id FROM table1</span><br><span class="line"></span><br><span class="line"> MINUS</span><br><span class="line"></span><br><span class="line">SELECT id FROM table2;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">+----+</span><br><span class="line"></span><br><span class="line">| id |</span><br><span class="line"></span><br><span class="line">+----+</span><br><span class="line"></span><br><span class="line">| 1 |</span><br><span class="line"></span><br><span class="line">| 4 |</span><br><span class="line"></span><br><span class="line">+----+ </span><br></pre></td></tr></table></figure><p>这里可以看出，UNION操作返回了两个查询的并集，并去掉了重复项，而MINUS操作返回了第一个查询结果集中存在，但在第二个查询结果集中不存在的行。</p><p>结论</p><p>MINUS</p><p>SELECT * FROM table_a MINUS SELECT * FROM table_b; –取A表中有且B表中无的</p><p>UNION</p><p>SELECT * FROM table_a UNION SELECT * FROM table_b; –取A表中有或B表中有的</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
